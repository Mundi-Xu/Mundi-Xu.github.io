# 基本概念

Google Chrome的大致架构如下，V8主要包含堆栈的内存管理

```
+------------------------------------------------------------------------------------------+
| Google Chrome                                                                            |
|                                                                                          |
| +----------------------------------------+          +------------------------------+     |
| | Google V8                              |          |            WebAPIs           |     |
| | +-------------+ +---------------+      |          |                              |     |
| | |    Heap     | |     Stack     |      |          |                              |     |
| | |             | |               |      |          |                              |     |
| | |             | |               |      |          |                              |     |
| | |             | |               |      |          |                              |     |
| | |             | |               |      |          |                              |     |
| | |             | |               |      |          |                              |     |
| | +-------------+ +---------------+      |          |                              |     |
| |                                        |          |                              |     |
| +----------------------------------------+          +------------------------------+     |
|                                                                                          |
|                                                                                          |
| +---------------------+     +---------------------------------------+                    |
| |     Event loop      |     |          Task/Callback queue          |                    |
| |                     |     |                                       |                    |
| +---------------------+     +---------------------------------------+                    |
|                             +---------------------------------------+                    |
|                             |          Microtask queue              |                    |
|                             |                                       |                    |
|                             +---------------------------------------+                    |
|                                                                                          |
|                                                                                          |
+------------------------------------------------------------------------------------------+
```

## 内存机制

在Chrome V8中，内存机制是非常重要的，V8是一个使用C++完成的库，用于执行JavaScript，如果你在自己的JavaScript代码中声明了一个变量，那么这个变量将由V8的内存机制进行管理，且只能由它的内存回收机制所回收，而不能被我们自己进行管理（不能被delete或者free等操作符操作）。

Chrome V8中的堆内存大致可分为以下部分：

+ 新生代内存区：基本的数据对象都被分配在这里，其区域小但是回收频繁。
+ 老生代指针区：一堆指向老生代内存区具体数据内容的指针，基本上从新生代进化过来的对象会被移动到此。
+ 老生代数据区：存放数据对象而不是指向其他对象的指针，老生代指针区的指针就往这边指。
+ 大对象区：这里存放体积超越其他区大小的对象，每个对象由自己的内存，GC并不会移动大对象。
+ 代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里，也是唯一拥有执行权限的内存区。
+ Cell区，属性Cell区，Map区：存放Cell，属性Cell和Map，每个区域都是存放相同大小的元素，结构简单。

```
+----------------------- -----------------------------------------------------------+
|   Young Generation                  Old Generation          Large Object space    |
|  +-------------+--------------+  +-----------+-------------+ +------------------+ |
|  |        NEW_SPACE           |  | MAP_SPACE | OLD_SPACE   | | LO_SPACE         | |
|  +-------------+--------------+  +-----------+-------------+ +------------------+ |
|  |  from_Space   | to_Space   |                                                   |
|  +-------------+--------------+                                                   |
|  +-------------+                 +-----------+               +------------------+ |
|  | NEW_LO_SPACE|                 | CODE_SPACE|               | CODE_LO_SPACE    | |
|  +-------------+                 +-----------+               +------------------+ |
|                                                                                   |
|   Read-only                                                                       |
|  +--------------+                                                                 |
|  | RO_SPACE     |                                                                 |
|  +--------------+                                                                 |
+-----------------------------------------------------------------------------------+
```

上图中每个堆部分的空间被GC以不同的方式处理，最重要的两部分就是新生代内存和老生代内存的垃圾回收机制。

### 新生代内存

绝大多数JavaScript对象都会被分配到新生代内存中，内存区域很小但是垃圾回收频繁。

在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针并不断根据新对象的大小递增即可。当该指针到达了新生代内存区的末尾时，就会有一次清理。

新生代内存使用Scavenge算法进行回收：

```
ptrs   from_space (evacuation)   to_space
      +----------+            +------------+
----->|marked: * | ---------->|marked: s   |       (s=survived)
      +----------+            +------------+
      |marked:   |      ----->|marked: s   |
      +----------+     /      +------------+
----->|marked: * | ----       |            |
      +----------+            +------------+
      |marked:   |            |            |
      +----------+            +------------+
      |marked:   |            |            |
      +----------+            +------------+
```

该种算法中的大致思想为：将内存一分为二，每部分的空间都被成为`Semispace`。在两个`Semispace`中，总有一个处于使用状态，成为From空间；另一个处于闲置状态，称为To空间。

在分配对象时，总使用From空间进行分配；在垃圾回收时，Chrome V8检查From空间中的存活对象，然后将这些对象复制到To空间中，剩下的对象就会被释放，完成复制后From空间和To空间的角色对调，原来的From空间变成了新的To空间，而原来的To空间就变成了From空间。由此可以看出，在新生代内存中总有至少一半的内存是空闲不用的，不过新生代内存的特点就是空间小，回收频繁，所以也浪费不了多少。

当一个新生代中的对象经过多次新生代的垃圾回收而继续坚挺在内存区中时，说明它的生命周期较长，就会被移动到老生代内存，也称为对象的晋升。

晋升的标准有两条：

+ 在垃圾回收的过程中，如果该对象已经经历过一次新生代的清理，那就会晋升
+ 在垃圾回收的过程中，如果其中To空间的使用已经超过了25%，那么这个对象也会晋升

### 老生代内存

老生代内存所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多，如果这里再使用Scavenge算法进行垃圾回收，那浪费的内存就太大了。

所以GC就采用Mark-Sweep和Mark-Compact的结合体进行垃圾回收，主要采用Mark-Sweep，如果老生代空间不足以分配从新生代晋升过来的对象时，才使用Mark-Compact。

```
 Page 1              FreeList                        Page 1
+----------+        +--------------+		+------------+
|marked: * |---\    |    Size 1    |	--------|marked: s   |
+----------+    \   | +----------+ |   /	+------------+
|marked:   |     ---|>|__________| |  /	       -|marked: s   |
+----------+        | |__________|<|--        /	+------------+
|marked: * |--\     | |__________| |         /	|            |
+----------+   \    |    Size 2    |        /	+------------+
|marked:   |    \   | +----------+ |       /	|            |
+----------+     ---|>|__________|<|-------	+------------+
|marked:   |        | |__________| |		|            |
+----------+        | |__________| |            +------------+
                    +--------------+
```

#### Mark-Sweep（标记清除）

其分为两个阶段：

+ 标记：在标记阶段需要遍历老生代堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。
+ 清除：在清除阶段，Chrome V8只清除没有被标记的对象。

由于Mark-Sweep只清除死亡对象，而死亡对象在老生代中占用的比例通常较小，因此效率还是比较高的。就像从一堆白球中拿出几个红球还是很快的，至少比从一堆白球中拿出半堆红球快得多。

#### Mark-Compact（标记整理）

在Mark-Sweep时，容易产生内存碎片的问题,所以Mark-Compact在标记清除的基础上进行了压缩步骤，在清除时让它们变得紧缩。这相当于在清除的时候，让活着的剩余对象尽可能往内存区域的前面靠，直到内存区域前排全部排满，而后部区域是空的。

Mark-Compact的过程涉及内存区域的紧缩，所以效率比Mark-Sweep要低，不过其优势是不会产生内存碎片。

#### 惰性清理

Chrome V8在标记时就可以了解到哪些对象是死的，哪些对象是活的，但清理释放是需要开销的，所以Chrome V8并不急着去清理，而是延迟进行，GC可以根据需要来清理死掉的对象。

## 隔离实例（Isolate）

在Chrome V8中，一个引擎实例的数据类型叫Isolate，这是Chrome V8中所有要执行的地方都要出现的数据。它就是一个V8引擎的实例，也可以理解为引擎本体。每个实例内部拥有完全独立的各种状态，包括堆管理、垃圾回收等。

通过一个实例生成的任何对象都不能在另一个实例中使用，可以创建多个Isolate实例并且并行的在多个线程中使用，但同一个实例不能在多线程中使用。实例自身并不执行JavaScript，也没有JavaScript环境里面的上下文。

可以通过下述代码创建一个实例：

```c++
// 省略 V8 初始化过程

// 实例所必要的参数
v8::Isolate::CreateParams create_params;

// 省略参数设置过程

// 创建一个实例
v8::Isolate* isolate = v8::Isolate::New(create_params);
```

## 上下文（Context）

上下文是用来定义JavaScript执行环境的一个对象，其数据类型是Context，在创建时要指明属于哪个实例。

```c++
v8::Isolate* isolate = ...;
v8:Local<v8::Context> context = v8::Context::New(isolate);
```

其大致相当于一个沙箱化的执行上下文环境，内部预置了一系列的对象和函数，具体细节将在后文继续探讨。

## 脚本（Script）

顾名思义，脚本就是一个包含一段已经编译好的JavaScript脚本的对象，数据类型就是Script。它在编译时就与一个处于活动状态的Context进行绑定。

```c++
v8::Local<v8::Context> context = ...;

v8::Local<v8::String> source = 一段JavaScript代码；

// 与上下文绑定并编译
v8::Local<v8::Value> result = v8::Script::Compile(context, source).ToLocalChecked();

//执行脚本
v8::Local<v8::Value> result = script->Run(context).ToLocalChecked();
```

# 句柄（Handle）

句柄是Chrome V8中的一个重要概念，它提供了对于堆内存中JavaScript数据对象的一个引用。与对象（Object）相似，Handle也包含一个地址成员（在HandleBase中定义，称为location_），但和对象不同的是句柄充当抽象层的作用，其可以被GC重新定位。

Chrome V8在进行垃圾回收的时候，通常会将JavaScript的数据对象移来移去。和对象指针相比，一旦一个对象被移走，这个指针就成了野指针。而在移动的过程中，GC会更新引用了这个数据块的那些句柄，让其断不了联系。当一个对象不再被句柄引用时，那么它将被认定为垃圾，Chrome V8的垃圾回收机制会不时的对其进行回收。具体细节可以参阅`src/handles/handles.h`

````c++
class HandleBase {  
 ...
 protected:
  Address* location_; 
}
template <typename T>                                                           
class Handle final : public HandleBase {
  ...
}
````



```
+----------+                  +--------+         +---------+
|  Handle  |                  | Object |         |   int   |
|----------|      +-----+     |--------|         |---------|
|*location_| ---> |&ptr_| --> | ptr_   | ----->  |     5   |
+----------+      +-----+     +--------+         +---------+
```



```apl
(gdb) p handle
$8 = {<v8::internal::HandleBase> = {location_ = 0x7ffdf81d60c0}, <No data fields>}
```

location_包含一个指针

```apl
(gdb) p /x *(int*)0x7ffdf81d60c0
$9 = 0xa9d330
```

其值和对象中的一样

```apl
(gdb) p /x obj.ptr_
$14 = 0xa9d330
```

我们可以用指针去访问这个int值

```apl
(gdb) p /x *value
$16 = 0x5
(gdb) p /x *obj.ptr_
$17 = 0x5
(gdb) p /x *(int*)0x7ffdf81d60c0
$18 = 0xa9d330
(gdb) p /x *(*(int*)0x7ffdf81d60c0)
$19 = 0x5
```

测试代码：

```c++
#include <iostream>
#include "gtest/gtest.h"
#include "v8.h"
#include "src/handles/handles.h"
#include "src/objects/objects-inl.h"

namespace i = v8::internal;

TEST(Handle, DefaultConstructor) {
  i::Handle<int> handle{};
  EXPECT_TRUE(handle.is_null());
  EXPECT_EQ(handle.location(), nullptr);
}

TEST(Handle, AddressConstructor) {
  int* value = new int{5};
  i::Address addr = reinterpret_cast<i::Address>(value);
  i::Object obj{addr};

  i::Address ptr = obj.ptr();
  i::Address* location = &ptr;
  i::Handle<i::Object> handle(location);

  EXPECT_EQ(handle.location(), &ptr);
  EXPECT_EQ(*handle.location(), ptr);
  i::Object deref = *handle;
  i::Address deref_addr = deref.ptr();
  int* deref_value = reinterpret_cast<int*>(deref_addr);
  EXPECT_EQ(*deref_value, *value);
  delete value;
}
```

话说回来，句柄在Chrome V8中只是一个统称，它其实还分为多种类型：

+ 本地句柄(v8::Local)
+ 持久句柄(v8::Persistent)
+ 永生句柄(v8::Eternal)
+ 待实本地句柄
+ 其他句柄

本地句柄存在于栈内存中，并在对应的析构函数调用时被删除，其生命周期由其所在的句柄作用域（Handle Scope）决定。

**句柄存在的形式是C++的一个模板类，其需要根据不同的Chrome V8数据类型进行不同的声明。** 例如：

+ `v8::Local<v8::Number>` 本地JavaScript数据类型句柄
+ `v8::Persistent<v8::String>` 持久JavaScript字符串类型句柄

# 句柄作用域（HandleScope）

在代码中，句柄作用域以HandleScope或者EscapableHandleScope的形式存在于栈内存中，其实际上是一个维护一堆句柄的容器。

