{"meta":{"title":"Mundi's Space","subtitle":"Be wise and fool.","description":null,"author":"寒雨","url":"https://mundi-xu.github.io"},"pages":[{"title":"about","date":"2020-12-22T15:38:55.000Z","updated":"2020-12-24T14:02:06.726Z","comments":false,"path":"about/index.html","permalink":"https://mundi-xu.github.io/about/index.html","excerpt":"","text":"My name is Mundi, and this is my Blog!!!Hope you have fun here~Then just enjoy the music of my beloved one."}],"posts":[{"title":"密码学初探-基于RUST的密码系统与算法简析","slug":"密码学初探-基于RUST的密码算法简析","date":"2020-12-27T06:05:31.000Z","updated":"2020-12-27T10:47:07.846Z","comments":true,"path":"2020/12/27/密码学初探-基于RUST的密码算法简析/","link":"","permalink":"https://mundi-xu.github.io/2020/12/27/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%8E%A2-%E5%9F%BA%E4%BA%8ERUST%E7%9A%84%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E7%AE%80%E6%9E%90/","excerpt":"基于 rust 开发的在线加解密系统与各类加密函数的简析。","text":"Introduction密码学（Cryptography）一般可分为古典密码学和现代密码学。 其中，古典密码学，作为一种实用性艺术存在，其编码和破译通常依赖于设计者和敌手的创造力与技巧，并没有对密码学原件进行清晰的定义。古典密码学主要包含以下几个方面： 单表替换加密（Monoalphabetic Cipher） 多表替换加密（Polyalphabetic Cipher） 奇奇怪怪的加密方式 而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面： 对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。 非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。 哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。 数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA 签名为代表。 其中，对称加密体制主要分为两种方式： 分组密码（Block Cipher），又称为块密码。 序列密码（Stream Cipher），又称为流密码。 一般来说，密码设计者的根本目标是保障信息及信息系统的 机密性（Confidentiality） 完整性（Integrity） 可用性（Availability） 认证性（Authentication） 不可否认性（Non-repudiation） 其中，前三者被称为信息安全的 CIA 三要素 。 本文主要介绍了仿射密码，流密码（RC4,LFSR+JK)，分组密码（DES,AES），非对称加密（rsa）和密码协议（Diffie_Hellman）。项目详细代码已于Github开源[1]。 仿射密码原理仿射密码的加密函数是 $E(x)=(ax+b)\\pmod m$，其中 $x$ 表示明文按照某种编码得到的数字 $a$ 和 $m$ 互质 $m$ 是编码系统中字母的数目。 解密函数是 $D(x)=a^{-1}(x-b)\\pmod m$，其中 $a^{-1}$ 是 $a$ 在 $\\mathbb{Z}_{m}$ 群的乘法逆元。 下面我们以 $E(x) = (5x + 8) \\bmod 26$ 函数为例子进行介绍，加密字符串为 AFFINE CIPHER，这里我们直接采用字母表26个字母作为编码系统 明文 A F F I N E C I P H E R x 0 5 5 8 13 4 2 8 15 7 4 17 $y=5x+8$ 8 33 33 48 73 28 18 48 83 43 28 93 $y\\mod26$ 8 7 7 22 21 2 18 22 5 17 2 15 密文 I H H W V C S W F R C P 其对应的加密结果是 IHHWVCSWFRCP。 对于解密过程，正常解密者具有a与b，可以计算得到 $a^{-1}$ 为 21，所以其解密函数是$D(x)=21(x-8)\\pmod {26}$ ，解密如下 密文 I H H W V C S W F R C P $y$ 8 7 7 22 21 2 18 22 5 17 2 15 $x=21(y-8)$ 0 -21 -21 294 273 -126 210 294 -63 189 -126 147 $x\\mod26$ 0 5 5 8 13 4 2 8 15 7 4 17 明文 A F F I N E C I P H E R 可以看出其特点在于只有 26 个英文字母。 Rust实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// Encryptlet mut ans = String::new();for ch in msg.chars() &#123; if ch.is_ascii_alphabetic() &#123; if ch.is_uppercase() &#123; // 大写字母 let x = ch as u32 - &#x27;A&#x27; as u32; let y = (upper_a * x + upper_b) % 26; let target = &#x27;A&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; // 小写字母 let x = ch as u32 - &#x27;a&#x27; as u32; let y = (lower_a * x + lower_b) % 26; let target = &#x27;a&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; &#125; else if ch.is_ascii_digit() &#123; // 数字 let x = ch as u32 - &#x27;0&#x27; as u32; let y = (number_a * x + number_b) % 26; let target = &#x27;0&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; ans.push(ch); &#125;&#125;return Ok(ans);// Decryptlet lower_a_ = exgcd(lower_a as i32, 26) as u32;let upper_a_ = exgcd(upper_a as i32, 26) as u32;let number_a_ = exgcd(number_a as i32, 10) as u32;let mut ans = String::new();for ch in msg.chars() &#123; if ch.is_ascii_alphabetic() &#123; if ch.is_uppercase() &#123; // 大写字母 let x = ch as u32 - &#x27;A&#x27; as u32; let y = (upper_a_ * (x + 26 - upper_b)) % 26; let target = &#x27;A&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; // 小写字母 let x = ch as u32 - &#x27;a&#x27; as u32; let y = (lower_a_ * (x + 26 - lower_b)) % 26; let target = &#x27;a&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; &#125; else if ch.is_ascii_digit() &#123; // 数字 let x = ch as u32 - &#x27;0&#x27; as u32; let y = (number_a_ * (x + 10 - number_b)) % 10; let target = &#x27;0&#x27; as u32 + y; let new_ch = char::try_from(target).unwrap(); ans.push(new_ch); &#125; else &#123; ans.push(ch); &#125;&#125;return Ok(ans); 破解首先，我们可以看到的是，仿射密码对于任意两个不同的字母，其最后得到的密文必然不一样，所以其也具有最通用的特点。当密文长度足够长时，我们可以使用频率分析的方法来解决。 其次，我们可以考虑如何攻击该密码。可以看出当$a=1$ 时，仿射加密是凯撒加密。而一般来说，我们利用仿射密码时，其字符集都用的是字母表，一般只有26个字母，而不大于26的与26互素的个数一共有 $$\\phi(26)=\\phi(2) \\times \\phi(13) = 12$$ 算上b的偏移可能，一共有可能的密钥空间大小也就是 $$12 \\times 26 = 312$$ 一般来说，对于该种密码，我们至少得是在已知部分明文的情况下才可以攻击。下面进行简单的分析。 这种密码由两种参数来控制，如果我们知道其中任意一个参数，那我们便可以很容易地快速枚举另外一个参数得到答案。 但是，假设我们已经知道采用的字母集，这里假设为26个字母，我们还有另外一种解密方式，我们只需要知道两个加密后的字母 $y_1,y_2$ 即可进行解密。那么我们还可以知道 $$y_1=(ax_1+b)\\pmod{26} \\y_2=(ax_2+b)\\pmod{26}$$ 两式相减，可得 $$y_1-y_2=a(x_1-x_2)\\pmod{26}$$ 这里 $y_1,y_2$ 已知，如果我们知道密文对应的两个不一样的字符 $x_1$ 与 $x_2$ ，那么我们就可以很容易得到 $a$ ，进而就可以得到 $b$ 了。 流密码流密码一般逐字节或者逐比特处理信息。一般来说 流密码的密钥长度会与明文的长度相同。 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。 需要注意的是，流加密目前来说都是对称加密。 伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。 流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。 流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。 反馈移位寄存器一般的，一个 n 级反馈移位寄存器如下图所示 其中 $a_0$，$a_1$，…，$a_{n-1}$ 为初态。 F 为反馈函数或者反馈逻辑。如果 F 为线性函数，那么我们称其为线性反馈移位寄存器（LFSR），否则我们称其为非线性反馈移位寄存器（NFSR）。 $a_{i+n}=F(a_i,a_{i+1},…,a_{i+n-1})$ 。 一般来说，反馈移位寄存器都会定义在某个有限域上，从而避免数字太大和太小的问题。因此，我们可以将其视为同一个空间中的变换，即 $(a_i,a_{i+1},…,a_{i+n-1}) \\rightarrow (a_{i+1},…,a_{i+n-1},a_{i+n})$.对于一个序列来说，我们一般定义其生成函数为其序列对应的幂级数的和。 线性反馈移位寄存器 - LFSR介绍线性反馈移位寄存器的反馈函数一般如下 $a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j}$ 其中，$c_j$ 均在某个有限域 $F_q$ 中。 既然线性空间是一个线性变换，我们可以得知这个线性变换为 $$ \\begin{align*}&amp;\\left[ a_{i+1},a_{i+2},a_{i+3}, …,a_{i+n}\\right]\\\\ \\\\ =&amp;\\left[ a_{i},a_{i+1},a_{i+2}, …,a_{i+n-1}\\right]\\left[ \\begin{matrix} 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_n \\\\ 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_{n-1} \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; c_{n-2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; c_1 \\\\ \\end{matrix} \\right] \\\\ \\\\ =&amp;\\left[ a_{0},a_{1},a_{2}, …,a_{n-1}\\right]\\left[ \\begin{matrix} 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_n \\\\ 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; c_{n-1} \\\\ 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; c_{n-2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; c_1 \\\\ \\end{matrix} \\right]^{i+1}\\end{align*} $$ 进而，我们可以求得其特征多项式为 $f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i}$ 同时，我们定义其互反多项式为 $\\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i}$ 我们也称互反多项式为线性反馈移位寄存器的联结多项式。 这里有一些定理需要我们记一下，感兴趣的可以自行推导。 样例 特征多项式与生成函数已知某个 n 级线性反馈移位寄存器的特征多项式，那么该序列对应的生成函数为 $A(x)=\\frac{p(x)}{\\overline f(x)}$ 其中，$p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1})$。可以看出 p(x) 完全由初始状态和反馈函数的系数决定。 序列周期与生成函数序列的的周期为其生成函数的既约真分式的分母的周期。 对于 n 级线性反馈移位寄存器，最长周期为 $2^{n}-1$（排除全零）。达到最长周期的序列一般称为 m 序列。 特殊性质 将两个序列累加得到新的序列的周期为这两个序列的周期的和。 序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。 B-M 算法一般来说，我们可以从两种角度来考虑 LFSR 密钥生成角度，一般我们希望使用级数尽可能低的 LFSR 来生成周期大，随机性好的序列。 密码分析角度，给定一个长度为 n 的序列 a，如何构造一个级数尽可能小的 LFSR 来生成它。其实这就是 B-M 算法的来源。 一般来说，我们定义一个序列的线性复杂度如下 若 s 为一个全零序列，则线性复杂度为0。 若没有 LFSR 能生成 s，则线性复杂度为无穷。 否则，s 的线性复杂度为生成 L(s) 的最小级的 LFSR。 BM 算法的要求我们需要知道长度为 2n 的序列。其复杂度 时间复杂度：O(n^2) 次比特操作 空间复杂度：O(n) 比特。 关于 BM 算法的细节，后续添加，目前处于学习过程中。 但是其实如果我们知道了长度为 2n 的序列，我们也可以一种比较笨的方法来获取原先的序列。不妨假设已知的序列为$a_1,…,a_{2n}$，我们可以令 $S_1=(a_1,…,a_n)$ $S_2=(a_2,…,a_{n+1})$ …. $S_{n+1}=(a_{n+1},…,a_{2n})$ 那么我们可以构造矩阵 $X=(S_1,…,S_n)$，那么 $S_{n+1}=(c_n,…,c_1)X$ 所以 $(c_n,…,c_1)=S_{n+1}X^{-1}$ 进而我们也就知道了 LFSR 的反馈表达式，进而我们就可以推出初始化种子。 非线性反馈移位寄存器介绍为了使得密钥流输出的序列尽可能复杂，会使用非线性反馈移位寄存器，常见的有三种 非线性组合生成器，对多个 LFSR 的输出使用一个非线性组合函数 非线性滤波生成器，对一个 LFSR 的内容使用一个非线性组合函数 钟控生成器，使用一个（或多个）LFSR 的输出来控制另一个（或多个）LFSR 的时钟 非线性组合生成器简介组合生成器一般如下图所示。 JK触发器 利用J-K触发器的非线性序列生成器 样例 Rust实现123456789101112131415161718192021222324252627282930313233343536373839404142pub struct LfsrJk &#123; j_state: u32, k_state: u32, j_state_c: u32, k_state_c: u32, data_state: u8,&#125;impl LfsrJk &#123; pub fn new(j_state: u32, k_state: u32, j_state_c: u32, k_state_c: u32, data_state: u8) -&gt; Self &#123; Self &#123; j_state: 0x12345678 - j_state, k_state: 0x87654321 - k_state, j_state_c: 0xffffffff - j_state_c, k_state_c: 0xffffffff - k_state_c, data_state, &#125; &#125; pub fn crypt(&amp;self, data: &amp;mut [u8]) &#123; let mut j_state = self.j_state; let mut k_state = self.k_state; let mut data_state = self.data_state; let len = data.len(); for i in 0..len &#123; let j = Self::round(&amp;mut j_state, self.j_state_c); let k = Self::round(&amp;mut k_state, self.k_state_c); data_state = j ^ (!(j ^ k) &amp; data_state); data[i] ^= data_state; &#125; &#125; #[inline] fn round(state: &amp;mut u32, state_c: u32) -&gt; u8 &#123; let mut output = 0u8; for _ in 0..8 &#123; let t = *state &amp; state_c; let new_out = t.count_ones() % 2; let out = (0x80000000 &amp; t) &gt;&gt; 31; output = (output &lt;&lt; 1) + out as u8; *state = (*state &lt;&lt; 1) + new_out; &#125; output &#125;&#125; RC4基本介绍RSA 由 Ron Rivest 设计，加解密使用相同的密钥，因此也属于对称加密算法。它是面向字节的流密码，密钥长度可变，非常简单，但也很有效果。RC4 算法曾广泛应用于 SSL/TLS 协议和 WEP/WPA 协议，但由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。 基本流程RC4 主要包含三个流程 初始化 S 和 T 数组。 初始化置换 S。 生成密钥流。 初始化 S 和 T 数组初始化 S 和 T 的代码如下 123for i = 0 to 255 do S[i] = i T[i] = K[i mod keylen]) 初始化置换 S1234j = 0for i = 0 to 255 do j = (j + S[i] + T[i]) (mod 256) swap (S[i], S[j]) 生成流密钥1234567i = j = 0 for each message byte b i = (i + 1) (mod 256) j = (j + S[i]) (mod 256) swap(S[i], S[j]) t = (S[i] + S[j]) (mod 256) print S[t] 我们一般称前两部分为 KSA ，最后一部分是 PRGA。 Rust实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748pub struct Rc4 &#123; s: [u32; 256], key: Vec&lt;u8&gt;,&#125;impl Rc4 &#123; pub fn new(key: Vec&lt;u8&gt;) -&gt; Self &#123; let mut key = key; if key.len() == 0 &#123; key = vec![1, 2, 3, 4, 5]; &#125; let mut rc4 = Self &#123; s: [0u32; 256], key, &#125;; rc4.init(); rc4 &#125; pub fn init(&amp;mut self) &#123; let mut k = vec![0u32; 256]; for i in 0..256 &#123; self.s[i] = i as u32; k[i] = self.key[i % self.key.len()] as u32; &#125; let mut j = 0; for i in 0..256 &#123; j = (j + self.s[i] + k[i]) % 256; let tmp = self.s[i]; self.s[i] = self.s[j as usize]; self.s[j as usize] = tmp; &#125; &#125; pub fn crypt(&amp;mut self, data: &amp;mut [u8]) &#123; let mut i = 0; let mut j = 0; let mut t = 0; let mut s = self.s.clone(); for k in 0..data.len() &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; let tmp = s[i]; s[i] = s[j as usize]; s[j as usize] = tmp; t = (s[i] + s[j as usize]) % 256; data[k] ^= s[t as usize] as u8; &#125; &#125;&#125; 块加密概述所谓块加密就是每次加密一块明文，常见的加密算法有 IDEA 加密 DES 加密 AES 加密 块加密也是对称加密。 其实，我们也可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 复杂 的加解密算法来加解密明密文。 而与此同时，明文往往可能很长也可能很短，因此在块加密时往往需要两个辅助 padding，即 padding 到指定分组长度 分组加密模式，即明文分组加密的方式。 填充规则正如我们之前所说，在分组加密中，明文的长度往往并不满足要求，需要进行 padding，而如何 padding 目前也已经有了不少的规定。 常见的 填充规则 如下。需要注意的是，即使消息的长度是块大小的整数倍，仍然需要填充。 一般来说，如果在解密之后发现 Padding 不正确，则往往会抛出异常。我们也因此可以知道 Paddig 是否正确。 Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6F 72 05 05 05 05 05KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40 Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6F 72 80 00 00 00 00KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 这里其实就是和 md5 和 sha1 的 padding 差不多。 Pad with zeroes except make the last byte equal to the number of padding bytes1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 00 00 00 00 05KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8 Pad with zero (null) characters1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 00 00 00 00 00KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75 Pad with spaces1234DES INPUT BLOCK = f o r _ _ _ _ _(IN HEX) 66 6f 72 20 20 20 20 20KEY = 01 23 45 67 89 AB CD EFDES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25 工作模式分组密码的工作模式是：根据不同的数据格式和安全性要求, 以一个具体的分组密码算法为基础构造一个分组密码系统的方法。分组密码的工作模式应当力求简单, 有效和易于实现，需要采用适当的工作模式来隐蔽明文的统计特性、数据的格式等，降低删除、重放、插入和伪造成功的机会。 分组密码的主要工作模式： 电码本(ECB)模式 密码分组链接(CBC)模式 密码反馈(CFB)模式 输出反馈(OFB)模式 计数器(CTR)模式 基本策略在分组密码设计时，充分使用了 Shannon 提出的两大策略：混淆与扩散两大策略。 混淆混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下 S 盒 乘法 扩散扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有 线性变换 置换 移位，循环移位 常见加解密结构目前块加密中主要使用的是结构是 迭代结构，这是因为迭代结构便于设计与实现，同时方便安全性评估。 迭代结构概述迭代结构基本如下，一般包括三个部分 密钥置换 轮加密函数 轮解密函数 轮函数目前来说，轮函数主要有主要有以下设计方法 Feistel Network，由 Horst Feistel 发明，DES 设计者之一。 DES Substitution-Permutation Network(SPN) AES 其他方案 密钥扩展目前，密钥扩展的方法有很多，没有见到什么完美的密钥扩展方法，基本原则是使得密钥的每一个比特尽可能影响多轮的轮密钥。 DES基本介绍Data Encryption Standard(DES)，数据加密标准，是典型的块加密，其基本信息如下 输入 64 位。 输出 64 位。 密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。 Feistel 迭代结构 明文经过 16 轮迭代得到密文。 密文经过类似的 16 轮迭代得到明文。 基本流程给出一张简单的 DES 流程图。 加密我们可以考虑一下每一轮的加密过程 $L_{i+1}=R_i$ $R_{i+1}=L_i\\oplus F(R_i,K_i)$ 那么在最后的 Permutation 之前，对应的密文为$(R_{n+1},L_{n+1})$。 解密那么解密如何解密呢？首先我们可以把密文先进行逆置换，那么就可以得到最后一轮的输出。我们这时考虑每一轮 $R_i=L_{i+1}$ $L_i=R_{i+1}\\oplus F(L_{i+1},K_i)$ 因此，$(L_0,R_0)$ 就是加密时第一次置换后的明文。我们只需要再执行逆置换就可以获得明文了。 可以看出，DES 加解密使用同一套逻辑，只是密钥使用的顺序不一致。 核心部件DES 中的核心部件主要包括（这里只给出加密过程的） 初始置换 F 函数 E 扩展函数 S 盒，设计标准未给出。 P 置换 最后置换 其中 F 函数如下 如果对 DES 更加感兴趣，可以进行更加仔细地研究。欢迎提供 PR。 衍生在 DES 的基础上，衍生了以下两种加密方式 双重 DES 三种 DES 双重 DES双重 DES 使用两个密钥，长度为 112 比特。加密方式如下 $C=E_{k2}(E_{k1}(P))$ 但是双重 DES 不能抵抗中间相遇攻击，我们可以构造如下两个集合 $I={E_{k1}(P)}$ $J=D_{k2}(C)$ 即分别枚举 K1 和 K2 分别对 P 进行加密和对 C 进行解密。 在我们对 P 进行加密完毕后，可以对加密结果进行排序，这样的复杂度为$2^nlog(2^n)=O(n2^n)$ 当我们对 C 进行解密时，可以每解密一个，就去对应的表中查询。 总的复杂度为还是$O(n2^n)$。 三重 DES三重 DES 的加解密方式如下 $C=E_{k3}(D_{k2}(E_{k1}(P)))$ $P=D_{k1}(E_{k2}(D_{k3}(C)))$ 在选择密钥时，可以有两种方法 3 个不同的密钥，k1，k2，k3 互相独立，一共 168 比特。 2 个不同的密钥，k1 与 k2 独立，k3=k1，112 比特。 攻击方法 差分攻击 线性攻击 AES基本介绍Advanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下 输入：128 比特。 输出：128 比特。 SPN 网络结构。 其迭代轮数与密钥长度有关系，如下 密钥长度（比特） 迭代轮数 128 10 192 12 256 14 基本流程基本概念在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。 在 AES 中，块与 State 之间的转换过程如下 所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。 而对于明文来说，一般我们会选择使用其十六进制进行编码。 加解密过程这里给个看雪上比较好的 图例 ，以便于介绍基本的流程，每一轮主要包括 轮密钥加，AddRoundKey 字节替换，SubBytes 行移位，ShiftRows 列混淆，MixColumns 上面的列混淆的矩阵乘法等号左边的列向量应该在右边。 这里再给一张其加解密的全图，其解密算法的正确性很显然。 我们这里重点关注一下以下。 字节替换在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下 这里的运算均定义在 $GF(2^8)$ 内。 列混淆这里的运算也是定义在 $GF(2^8)$ 上，使用的模多项式为 $x^8+x^4+x^3+1$。 密钥扩展 等价解密算法简单分析一下，我们可以发现 交换逆向行移位和逆向字节代替并不影响结果。 交换轮密钥加和逆向列混淆并不影响结果，关键在于 首先可以把异或看成域上的多项式加法 然后多项式中乘法对加法具有分配率。 攻击方法 积分攻击 非对称加密介绍在非对称密码中，加密者与解密者所使用的密钥并不一样，典型的有 RSA 加密，背包加密，椭圆曲线加密。 RSARSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。 RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2020 年为止，还没有任何可靠的攻击 RSA 算法的方式。 基本原理公钥与私钥的产生 随机选择两个不同大质数 $p$ 和 $q$，计算 $N = p \\times q$ 根据欧拉函数，求得 $\\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1)$ 选择一个小于 $\\varphi (N)$ 的整数 $e$，使 $e$ 和 $\\varphi (N)$ 互质。并求得 $e$ 关于 $\\varphi (N)$ 的模反元素，命名为 $d$，有 $ed\\equiv 1 \\pmod {\\varphi (N)}$ 将 $p​$ 和 $q​$ 的记录销毁 此时，$(N,e)$ 是公钥，$(N,d)$ 是私钥。 消息加密首先需要将消息 以一个双方约定好的格式转化为一个小于 $N$，且与 $N$ 互质的整数 $m$。如果消息太长，可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密： $$m^{e}\\equiv c\\pmod N$$ 消息解密利用密钥 $d​$ 进行解密。 $$c^{d}\\equiv m\\pmod N$$ 正确性证明即我们要证$m^{ed} \\equiv m \\bmod N$，已知$ed \\equiv 1 \\bmod \\phi(N)$，那么 $ed=k\\phi(N)+1$，即需要证明 $$m^{k\\phi(N)+1} \\equiv m \\bmod N$$ 这里我们分两种情况证明 第一种情况 $gcd(m,N)=1​$，那么 $m^{\\phi(N)} \\equiv 1 \\bmod N​$，因此原式成立。 第二种情况 $gcd(m,N)\\neq 1$，那么 $m$ 必然是 $p$ 或者 $q$ 的倍数，并且 $n=m$ 小于 $N$。我们假设 $$m=xp$$ 那么 $x$ 必然小于 $q$，又由于 $q$ 是素数。那么 $$m^{\\phi(q)} \\equiv 1 \\bmod q$$ 进而 $$m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q$$ 那么 $$m^{k\\phi(N)+1}=m+uqm$$ 进而 $$m^{k\\phi(N)+1}=m+uqxp=m+uxN$$ 所以原式成立。 样例例1计算公钥和私钥 p = 13 , q = 5 N = pq = 65 r = (p-1)(q-1) = (13-1)(5-1) = 48 计算模反元素r=48，选择e=5，得到二元一次方程：5d-48k=1 , 获得一组解：d=29，k=3 因此，公钥是 (N, e) = (65, 5)，私钥是 (N, d) = (65, 29)。 加密信息 明文：m=3 计算: $ c \\equiv 3^{5} \\pmod 65 \\equiv 48 $ 因此：3被加密为48 解密信息 密文：c=48 计算：$ n \\equiv 48^{29} \\pmod 65 \\equiv 3 $ 因此：48被解密为3 例2 密码协议Diffie-Hellman 密钥交换 密钥交换是实现安全通信的基础 商用加密算法AES和DES需要在安全通信之前，实现通信双方的密钥共享。 密钥交换的方法： 基于RSA的密钥交换； 基于KDC技术 (Key Distributed Center，密钥分发中心)； Diffie-Hellman密钥交换（简称：DH算法）； 基于物理层的密钥交换。 DH算法是不安全信道下实现安全密钥共享的一种方法，由 W. Diffie 和 M.Hellman 在1976年提出的第一个公开的公钥密码算法。 DH协议案例 参考https://github.com/Mundi-Xu/cipher_web_rocket ↩ctf-wiki ↩深入浅出密码学——常用加密技术原理与应用 ↩","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://mundi-xu.github.io/tags/crypto/"},{"name":"rsa","slug":"rsa","permalink":"https://mundi-xu.github.io/tags/rsa/"},{"name":"rust","slug":"rust","permalink":"https://mundi-xu.github.io/tags/rust/"},{"name":"仿射密码","slug":"仿射密码","permalink":"https://mundi-xu.github.io/tags/%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/"},{"name":"流密码","slug":"流密码","permalink":"https://mundi-xu.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"分组密码","slug":"分组密码","permalink":"https://mundi-xu.github.io/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"},{"name":"密码协议","slug":"密码协议","permalink":"https://mundi-xu.github.io/tags/%E5%AF%86%E7%A0%81%E5%8D%8F%E8%AE%AE/"},{"name":"RC4","slug":"RC4","permalink":"https://mundi-xu.github.io/tags/RC4/"},{"name":"des","slug":"des","permalink":"https://mundi-xu.github.io/tags/des/"},{"name":"aes","slug":"aes","permalink":"https://mundi-xu.github.io/tags/aes/"}]},{"title":"基于区块链的安全日志系统","slug":"基于区块链的安全日志系统","date":"2020-07-01T11:00:00.000Z","updated":"2020-12-27T10:06:42.754Z","comments":true,"path":"2020/07/01/基于区块链的安全日志系统/","link":"","permalink":"https://mundi-xu.github.io/2020/07/01/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AE%89%E5%85%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","excerpt":"基于区块链技术设计并实现了安全日志系统，采用链上数据存储模式，将本地日志提取关键字段并上传至区块链中存储，同时提供可视化界面让用户能够使用日志相关的安全分析功能。","text":"摘要信息系统中存在着大量的安全设备日志，这些日志对系统监控、查询、安全审计和故障诊断等都十分重要。与此同时，黑客入侵系统时，日志为黑客的行为提供了证据。因此对其进行安全的存储与处理具有重要意义。区块链技术的发展，为实现日志信息的保护、分享、取证、多边利益最大化提供了可能，为实现安全日志系统提供了保障。 基于区块链技术，本项目设计并实现了安全日志系统。该系统采用链上数据存储模式，将本地日志上传至区块链中存储，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。通过安全性分析论证了该系统能够保证安全设备日志的安全可靠存储，同时为日志分析，日志取证提供便利。本项目解决了日志易被删除，篡改，伪造等问题，满足了学校、公司等云存储系统的安全日志审计，并极大的提高了数据存储的安全性，减轻运维人员的压力。 概述背景云计算已经被认为是下一代的信息技术基础设施，因为它在信息技术的发展史上有着史无前例的优势：自助按需服务，随时随地地进行网络访问，位置独立的资源池、弹性资源，基于使用的计费以及风险转移。作为一项具有深远影响的颠覆性技术，云计算正在改变企业使用信息技术的模式，一个典型的方面是数据正在被集中外包给云。从用户角度来看，包括个人和企业用户，将数据灵活的以按需分配的方式存储到云端带来了有吸引力的好处：缓解了存储管理负担，减少了在硬件、软件以及维护人员上的花销。云存储的概念正是从云计算引申而来的，它是一种通过将网络中不同的存储设备利用分布式和集群技术组合起来协同工作的新型存储技术，并能够对外提供大量数据的存储服务以及业务访问服务。日志即为一种云存储的方式。用户通过URL请求特定域名下的资源，这些资源会被保存在特定服务器上，Web服务器在响应用户请求的同时可以以日志文件记录用户请求的全过程，即Web日志。日志几乎内建于所有的系统中，它被用于记录系统运行时产生的信息，如日常操作、网络访问、系统警告等事件的相关属性和信息。 随着互联网的迅速发展，计算机系统从防火墙、数字加密、身份认证、访问控制、数字签名技术等方面加强安全维护，但仍存在被非授权用户攻击的风险。日志经常是入侵者的主要攻击目标，容易受到篡改、删除、伪造等破坏。存储安全是数据安全的关键。因此，建立安全的日志系统是非常必要的。 区块链技术的发展，为实现日志信息的保护、分享、多边利益最大化提供了可能，为实现安全日志系统提供了保障。区块链技术具有去中心化、不可篡改和追踪溯源等特性，其应用场景已涉及医疗、电网、农产品追溯方向。区块链将信任关系从中心化的机构转移到所有参与计算的个体上，一旦某个交易被篡改，区块链网络中的节点会检测出该行为，只有多个节点同时遭受攻击时才会面临数据的丢失和泄露等风险，从而可以防止数据泄露、合谋攻击、伪造等不良行为。 特色描述目前，区块链和日志服务系统存在以下匹配或矛盾的地方： 区块链有多个副本，有助于日志的保存； 共识机制缓慢不利于日志的保存； 共识机制可保障日志的先后顺序不被打乱； 具有可追溯性，每个日志都有数字签名，可以明确查到提交者； 区块链节点数量少时安全性降低； 由于每个节点都保存日志的完整版本，对存储空间消耗大。 综上所述，我们对本项目进行了系统性分析、规划，以下为该项目的特点： 分布式存储多个副本； 灵活支持多种日志格式，便于程序化分析； 顺序性有保障； 防篡改； 多方签名防日志伪造； 机器使用可信根作为信任基； 日志存储准确率高； 提供可视化界面，方便查看。 前景分析区块链因为比特币的的出现为人们所熟知，从产生迄今，在金融、证券、资本和科技行业的应用呈现出爆发式增长。虽然比特币是区块链最著名的应用，但区块链可以应用于远不止加密货币的各种应用。由于它可以在没有银行或任何第三方可信中间机构的情况下在双方之间完成支付，区块链可以应用于数字资产、汇款以及在线支付等各种金融服务。此外，构建于区块链技术之上的各种应用，例如智能合约应用、物联网和安全服务等，也正在成为构建下一代互联网应用最有前景的技术之一。 区块链技术的出现也为云存储安全的研究提供了一种新的研究思路。因为在现实环境中，完全公平公开的第三方机构是不可能的，且存在多个参与方共谋攻击或者欺骗另一方的问题。区块链技术去中心化的分布式架构和去信任化的运行机制使得建立一个不依赖于可信第三方的去中心化审计架构成为可能。区块链中每个区块的数据以时间顺序加密存放，具有唯一性。倘若篡改其中某区块的数据，从理论上来说其计算开销是相当巨大的，而且修改是不可逆的，这样就制约了服务商随意篡改数据的行为。区块链技术的去中心化存储架构，只有区块链网络中的多个对等节点同时遭受攻击时才会面临数据的丢失和泄露等风险，从而可以防止数据泄露等危险。 伴随着高级持续威胁攻击的复杂多变，安全技术、产品不断推陈出新，安全厂商推出的防火墙、网络入侵检测、网络入侵防御、蜜罐、上网行为管理、安全审计、网络流量分析等众多产品涵盖到了网络安全、主机安全、Web安全、数据安全、移动安全、安全管理、工控安全等各个方面，同时也就是因为产品多样、技术多变，导致安全信息无法整合、高效利用。常见的日志服务器虽然实现了系统相关信息的存储，不能保证日志的安全问题。加强Web网站的网络和信息安全，仍需一种安全的日志系统。在这种情况下，基于区块链的安全日志系统就为解决问题提供了可能。该项目通过结合区块链技术，设计链上数据存储模式，有效地解决了日志文件易被篡改的问题，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。 本项目的针对范围是提供Web服务的中小企业，它们内部维护有大量服务器，每天需要产生大量的日志，怎样合理地对日志进行分析，抓住重点，在日志中找到入侵或者非常规请求的操作，解决潜在的Web安全问题，对于有大量Web服务器的公司来说，开发一套安全的日志系统就显得尤为重要，这样不仅增强了系统的安全性，更易于服务器的维护。 设计与实现整体设计功能设计本项目设计并实现了基于区块链的安全日志系统。该系统共有三个模块：日志收集模块，日志存储模块，日志分析展示模块。日志收集模块提供日志过滤，关键字提取和日志发送的功能，支持处理任意格式日志。对于日志存储模块，我们基于fabric v0.6区块链实现日志接收，安全存储与查询功能。同时我们利用grafana数据可视化工具与区块链进行对接，实现日志可视化分析功能。在各个模块的数据传输中，会对数据进行签名来进行身份验证，以防日志伪造等问题。 整个项目的功能设计图如下： 硬件拓扑设计本项目的整体框架是在各个产生日志的web服务器上部署日志收集模块来获取日志，将日志发送到区块链，各节点进行共识后存储。然后grafana从区块链中读取日志数据，进行可视化分析与展示。整个系统的硬件拓扑图如下： 具体流程设计日志收集模块设计日志收集模块安装于各个产生日志的服务器上，运维人员通过HTTP API的方式进行日志收集任务管理、更新，脱离配置文件。日志收集模块接收到任务后，对指定的日志文件进行按行读取，等待读取至100条（默认值，可自定义修改）时，将日志打包根据任务内容进行过滤与关键字段提取，最后发送至区块链。 工作流程如下： 区块链存储模块设计区块链存储模块是在 hyperledger fabricv0.6 的基础上改写智能合约实现的，提供 RESTFUL API 进行日志接收，查询日志功能。 在Fabric v0.6版本中，主要分为Membership、Consensus、Chaincode、Ledger、P2P、Event Stream等核心模块。 Membership：负责签发相应的E-cert、T-cert、TLS-cert等证书。会员注册、⾝身份保护、 内容保密、交易审计功 能，以保证平台访问的安全性。 Consensus：负责整个区块链的共识，统一交易顺序，保证区块链的一致性。 Chaincode：即链码（Fabric中的智能合约），用于执行区块链网络中的交易。 Ledger：用于存储Transaction log以及交易中的Key-Value。 P2P：基于Google的Grpc框架的底层网络通信层。 Event Stream：事件订阅发布组建，用于接收交易及区块事件。贯穿于其他各个组件中间，为各个组件间的异步通信提供了技术实现 区块服务（Blockchain Services）：负责节点间的共识管理、账本的分布式计算、账本的存储以及节 点间的P2P协议功能的实现，是区块链的核⼼心组成部分，为区块 链的主体功能提供了底层⽀撑。 Fabric v0.6版本的架构图如下： hyperledger fabricv0.6使用pbft (Practical Byzantine Fault Tolerance,实用拜占庭容错算法)作为共识算法，可以在信任程度较低的场景下避免拜占庭问题。在3f+1个共识节点中能忍受f个节点出错且依然能实现正确共识，提高现实使用中的容错率，增强实用性。 下图为Fabric v0.6的运行流程图： 日志收集模块需要先向Membership申请E-cert，通过E-cert去申请T-cert，由T-cert对应的私钥进行签名日志发送至VP节点进行三阶段共识，完成之后各个节点会通过Chaincode按顺序执行区块中的交易，并更新账本。 可视化分析模块设计可视化分析模块基于grafana实现。我们开发grafana的插件，使其能够从区块链中读取日志并进行可视化分析。 Grafana是一款用Go语言开发的开源数据可视化工具，可以做数据监控和数据统计。Grafana具有以下特点： 可视化：快速和灵活的客户端图形具有多种选项。面板插件为许多不同的方式可视化指标和日志。 报警：可视化地为最重要的指标定义警报规则。Grafana将持续评估它们，并发送通知。 通知：警报更改状态时，它会发出通知。接收电子邮件通知。 动态仪表盘：使用模板变量创建动态和可重用的仪表板，这些模板变量作为下拉菜单出现在仪表板顶部。 混合数据源：在同一个图中混合不同的数据源!可以根据每个查询指定数据源。这甚至适用于自定义数据源。 注释：注释来自不同数据源图表。将鼠标悬停在事件上可以显示完整的事件元数据和标记。 过滤器：过滤器允许您动态创建新的键/值过滤器，这些过滤器将自动应用于使用该数据源的所有查询。 功能强大的grafana可以帮助我们方便地进行日志分析。 详细实现日志收集模块Filter在日志收集任务部署时可指定每行日志必须包含的字符串数组incl[]与不可包含的字符串数组exec[]。对每行日志进行判断是否满足包含所有incl[]内的字符串，及不包含exec[]内的字符串。若不满足要求，则把该行日志丢弃。 extractor在日志收集任务部署时指定日志分隔符用于将该行日志分成若干段，并根据指定的对应关键字段名称及字段位置，提取出关键字段，同时将其余日志字段丢弃。也可通过不指定分隔符和关键字段名称，位置来不进行关键字段提取，这时返回整行日志。为了使日志在区块链中按时间顺序储存，在extract过程中判断有无timestamp字段，若无，则把当前时间添加到timestam字段。 sender在日志收集任务部署时指定目标区块链各节点的url，并以当前日志任务名作为日志包索引，将已经过滤和提取关键字段的日志利用fabric v0.6的restful api进行日志发送。在发送时，根据任务配置中的区块链节点，每次随机选取其中一个节点作为pbft共识的主节点，进行日志发送，从而每个区块链节点都作为主节点进行共识，提高共识并行性。 区块链存储模块接收并存储日志当区块链节点接收到日志收集模块发送的chaincode invoke请求时，chaincode通过一个事务请求来执行对账本的当前状态数据库操作。chaincode执行会生成一组读写集，将接收到的第一个参数，即日志文件路径作为ID，这组读写集将被提交到状态数据库储存，并转发给其他共识节点进行pbft共识。 下图为pbft执行过程： 假设系统要求每次产生区块的时间间隔为𝑡，则在一切正常的情况下，算法按照以下流程执行： 任意节点向全网广播日志数据，并附上发送者的签名 所有备份节点均独立监听全网的日志数据，并记录在内存 主节点在经过时间𝑡后,发送〈𝑃𝑒𝑟𝑝𝑎𝑟𝑒𝑅𝑒𝑞𝑢𝑒𝑠𝑡,ℎ,𝑣,𝑝,𝑏𝑙𝑜𝑐𝑘,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑝〉 备份节点𝑖在收到提案后，发送〈𝑃𝑒𝑟𝑝𝑎𝑟𝑒𝑅𝑒𝑠𝑝𝑜𝑛𝑠𝑒,ℎ,𝑣,𝑖,〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖〉 任意节点在收到至少𝑛−𝑓个〈𝑏𝑙𝑜𝑐𝑘〉𝜎𝑖后，共识达成并发布完整的区块 任意节点在收到完整区块后，将包含的日志从内存中删除，并开始下一轮共识 该算法要求参与共识的节点中，至少有𝑛−𝑓个节点具有相同的初始状态：即对于所有的节点𝑖，具有相同的区块高度ℎ和视图编号𝑣。而这个要求很容易达成：通过区块同步来达到ℎ的一致性，通过视图更换来达到𝑣的一致性。节点在监听全网交易以及在收到提案后，需要对交易进行合法性验证。如果发现非法交易，则不能将其写入内存池；如果非法交易包含在提案中，则放弃本次共识并立即开始视图更换。 交易的验证流程如下： 交易的数据格式是否符合系统规则，如果不符合则判定为非法； 交易在区块链中是否已经存在，如果存在则判定为非法； 交易的所有合约脚本是否都正确执行，如果没有则判定为非法； 交易中有没有多重支付行为，如果有则判定为非法； 如果以上判定都不符合，则为合法交易； 当节点𝑖在经过2𝑣+1.𝑡的时间间隔后仍未达成共识，或接收到包含非法交易的提案后，开始进入视图更换流程： 令𝑘 = 1，𝑣𝑘 = 𝑣 + 𝑘； 节点𝑖发出视图更换请求〈𝐶ℎ𝑎𝑛𝑔𝑒𝑉𝑖𝑒𝑤,ℎ,𝑣,𝑖,𝑣𝑘〉； 任意节点收到至少𝑛 − 𝑓个来自不同𝑖的相同𝑣𝑘后，视图更换达成，令𝑣 = 𝑣𝑘并开始共识； 如果在经过2𝑣𝑘+1.𝑡的时间间隔后，视图更换仍未达成，则𝑘递增并回到第2步； 随着𝑘的增加，超时的等待时间也会呈指数级增加，可以避免频繁的视图更换操作，并使各节点尽快对𝑣达成一致。 而在视图更换达成之前，原来的视图𝑣依然有效，由此避免了因偶然性的网络延迟超时而导致不必要的视图更换。 最终日志在链上储存如下： 节点主动恢复的功能区块链网络在运行过程中，可能出现网络抖动、磁盘故障等原因，可能会导致部分节点的执行速度落后大多数节点，因此需要添加主动恢复的功能才能参与后续的共识流程，为了解决这类问题，就需要通过主动索取共识网络中所有节点的视图，最新的区块高度等信息才能更新自身的数据状态，最终与系统的数据保持一致。 在节点启动、节点状态异常或者多次发起 viewchange 却不被其他节点接受的时候，节点就应该发起主动恢复数据的请求，同步区块高度、共识网络视图等信息。 主动恢复的流程主要分为 2 步： NegotiateView 同步当前的视图信息和路由信息； 同步全网最新区块信息。 以下为具体流程： 待恢复节点首先广播 QueryView 消息，获取网络中所有节点的当前视图信息和路由信息 其余正常节点收到 QueryView 消息后，返回当前节点的当前视图信息 view，当前节点名称 ReplicaId 和路由信息 N（节点总数） 待恢复节点如果收到 quorum 个（2f+1）包含相同的 N 和 view 的QueryViewResonse 消息，或者收到 2f 个包含相同 N 和 view 的报文且报文的 view 不等于当前待恢复节点的 view，则将本节点的视图 view 同步成全成网络的 view 和 N 待恢复节点广播 RevoeryToCheckpoint 消息到网络所有节点，请求其余节点的检查点 checkpoint 信息和 pset、qset 和 cset 的信息（即 PBFT 算法中 pre-prepare阶段、prepare 阶段和 commit 阶段的数据） 正常节点收到 RevoeryToCheckpoint 消息和 RecoveryToPQC 信息后，将自身的检查点信息和 PQC 信息返回给待恢复节点 待恢复节点收到 quorum 个 RevoeryToCheckpointResponse 消息后，找到待恢复的稳定的 chekpoin 点，调用 stateUpdate 更新至 chekpoin 点状态，更新完毕后如果发现自身的 checkpoint 仍然落后，则发送 RecoveryToPQC 消息，获取 PQC 消息更新自身的 pset、qset 和 cset 集合。 当坏节点主动恢复时流程如下图： 查询日志通过写 query chaincode,在其中调用 ChaincodeStubInterface 接口的 GetHistoryForKey()方法来查询指定 ID 的历史日志。外界可利用 fabric 的 http api 调用 query chaincode。 chaincode智能合约initInit方法会在chaincode接收到instantiate（实例化）或者upgrade(升级)交易时被调用，进而使得chaincode顺利执行必要的初始化操作。在init参数中需给出当前日志任务名和其关键字名，创建一个空 []map[string]interface&#123;&#125;，用于以后存储日志。同时将关键字名存储在[]string中，用于grafana查询。并初始化日志条数为0。 invoke日志收集模块触发invoke来进行日志存储。将sender发过来的日志切片进行Unmarshal反序列化后，append到已有的日志切片中，并按时间戳进行排序，保证按时间顺序存储。 queryQuery chiancode设计了search_keywords，get_num，get_logs，get_delete_info四种方法供grafana查询。search_keywords用于查询有哪些关键字，返回[]string；get_num用于查询该任务在区块链中存了多少条日志，返回[]byte(int64); get_logs返回每条日志的要查询的关键字段，返回map[string][]interface&#123;&#125;,即map[关键字名称][content1,content2,...]；get_delete_info查询历史delete操作信息，包括删除操作的时间，所删除的日志数。 delete用于对chaincode中所设定的时间以前的日志数据进行删除。触发delete chaincode，首先对所有日志按时间顺序进行遍历，并删除所有规定时间前的数据，最后记录本次删除操作的时间和删除日志数。 定期清理日志为降低存储成本，我们考虑对区块链中存储的日志区块进行定期截断。当前考虑对区块链中半年前（时间可自定义，但是固定在chiancode中的，部署之后不可修改）的日志区块进行删除。我们在init,invoke,query chaincode的基础上添加delete chaincode，用于执行区块删除操作。在peer节点启动时开启一个线程去每天触发一次delete交易，这样该delete交易通过pbft共识到达所有peer节点后，执行delete chaincode去清理半年前的日志区块。 为不破坏区块链结构，我们保留一个半年前的区块，作为被截断后的区块链的创世区块，使得截断后的区块链能够通过hash校验，保证安全性。 可视化分析模块Grafana作为最火热的开源数据可视化工具，最大的特点就是支持多种数据源以及丰富的插件库。SimpleJson是Grafana开源社区提供的数据源，它本身并不依赖某种特定的后端存储，只需要后端能实现Grafana报表的几个查询接口就行。SimpleJson是Grafana众多数据源插件中的一种，但它又不像其他插件配置好数据库信息就能用，开发者需要自己实现一部分数据源插件的功能来使SimpleJson插件能够使用。 我们基于SimpleJson编写grafana datasource插件，使grafana 可以通过 fabric的 http api 调用 query chaincode 读取储存在区块链中的日志数据。 系统分析本项目通过以区块链存储技术为支撑，设计并实现了一套为企业和个人用户存储日志的安全系统。相比于市面上已有的产品，具有较高的安全性，能有效防止日志遭到篡改或删除。同时提供了查询与可视化功能，方便用户针对日志进行分析，能及时有效了解服务器运行状况。 本项目的安全性分析如下： 以区块链为依托提高数据安全性 本项目将日志实时发送至区块链并存储，黑客若想在本地节点篡改某一日志内容，那么根据存储的原理，首先需要伪造日志提交者的签名，姑且不论能否获得日志提交者的私钥，在签名伪造成功后，仍需持续更改本区块的hash值，这就会直接导致后续区块无法通过Hash值连接本区块，也就需要对后续区块的所有Hash值进行再计算，再更改。即使进行了如此大量的运算与更改，但也仅仅局限于本地节点的账本中区块链结构，仍需继续更改索引数据库和状态数据库。假设这些更改在本地都可以正确实施，但是，区块链是一个分布式的网络系统，单一节点的更改，必须得到其他足够多节点的认可并同步数据，这才能使后续业务正确实施。 引用pbft共识机制降低存储出错率 Pbft共识机制可以在信任程度较低的场景下避免拜占庭问题。在3f+1个共识节点中能忍受f个节点出错且依然能实现正确共识，存储日志，提高现实使用中的容错率，增强实用性；日志收集模块随机选取区块链peer节点当作共识主节点，使得多交易能够并行共识，提高系统共识效率。 多方签名防止日志、请求伪造 在系统部署时，区块链CA会对日志收集模块，区块链各节点和grafana插件发放证书，之后发送日志请求时，数据在分布式系统的节点间传播之前，均在本节点对数据进行一次摘要处理（Hash），并使用节点私钥对摘要实施非对称加密（签名），之后将数据与签名打包成消息传输给目标节点。在目标节点处对传输数据再实施一次摘要处理（Hash），并用原始节点的公钥解密签名后，将解密结果与摘要对比，验证一致方认为消息内容没有被篡改。从而可以防止非法用户对区块链调用chaincode，造成破坏。同时对与正常请求可根据签名追溯日志发送者，方便日后取证。 防止重复delete攻击 本系统新设置了delete chaincode方法用于定期截断区块链，删除设定时间之前的区块。如果黑客成功通过签名验证，为防止该chaincode被黑客利用去删除其他区块，我们将设定时间设为const变量，写死在chaincode中，一旦部署chaincode就不能更改，使得黑客即使重复调用delete chaincode也不能删除设定时间内的区块；同时，chaincode由go语言编写，利用go语言的安全性质，很难出现缓冲区溢出等漏洞去篡改时间变量。 日志多副本存储实现灾备 用区块链多节点共识存储的特性，使日志实现多副本存储，大大减小了因硬盘损坏等问题导致日志丢失的可能性。 总结云存储技术的发展让人们看到了下一代互联网技术的发展方向，但同时数据泄露、数据篡改等问题限制了云存储技术的进一步发展。 基于区块链的安全日志系统为数据安全提供了很好的保障，该日志系统通过结合区块链技术，设计链上数据存储模式，有效地解决了日志文件易被篡改、数据泄露等问题，同时提供了可视化界面让用户能够使用日志相关的安全分析功能。 随着智能技术的不断发展，日志分析也应紧跟潮流，积极引入先进的技术，同时攻击手段和方法也在不停的变化和完善，因此需要多加注意这些变化，及时更新日志分析的方法，避免误判漏判的情况。目前本项目也存在一些问题： 利用区块链存储日志记录，当日志变得很多的时候，由于所有的节点都需要保存有整个系统副本，因此会带来较大的存储开销。之后我们将进一步研究利用区块链的交叉级联特性，尽可能的减少冗余； 日志收集的任务部署尚未实现UI，目前只能手发http请求去部署收集任务； 可视化界面需要进一步优化，之后我们会丰富日志分析功能，同时设计界面布局，达到美观大方简洁的效果； 目前的工作只是简单地实现了一个基于区块链的安全日志系统，接下来还需要对系统的提速，提高存储空间利用率进行更深一步研究，同时对于区块链在其他场景里的应用也可以做进一步的探索。 参考文献[1] 费禹，宁静，胡青.基于区块链的日志存储系统 [J] .网络空间安全，2018, Vol. 9(6): 80-85. [2] 韩菊茹，纪兆轩，李一鸣.基于区块链的可信日志存储与验证系统 [J] .计算机工程，2019, Vol. 45(5): 13-17. [3] 徐治理，封化民，刘飙.一种基于信用的改进PBFT高效共识机制[J/OL].2019,36(10).[2018-06-09] [4] 刘忆宁, 周元健, 蓝如师,等. 基于区块链的云数据删除验证协议[J]. 计算机研究与发展, 2018, 55(10):107-115.","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"https://mundi-xu.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"云存储","slug":"云存储","permalink":"https://mundi-xu.github.io/tags/%E4%BA%91%E5%AD%98%E5%82%A8/"},{"name":"日志系统","slug":"日志系统","permalink":"https://mundi-xu.github.io/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"},{"name":"智能合约","slug":"智能合约","permalink":"https://mundi-xu.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"Fabric v0.6","slug":"Fabric-v0-6","permalink":"https://mundi-xu.github.io/tags/Fabric-v0-6/"}]},{"title":"stl-list实现分析","slug":"stl-list实现","date":"2019-10-31T18:14:00.000Z","updated":"2020-12-23T15:54:13.113Z","comments":true,"path":"2019/11/01/stl-list实现/","link":"","permalink":"https://mundi-xu.github.io/2019/11/01/stl-list%E5%AE%9E%E7%8E%B0/","excerpt":"stl_list 介绍与源码分析","text":"stl_list 介绍今天我们来总结一下stl_List, 与单链表比较而言，stl_list无非就是链表结构不一样，至于其中的增删改查的细节实现本质是一样的，都是处理指针偏移。相比于vector，stl_List在插入和删除的时候可以达到O(1)的时间复杂度。 stl_list是一个双向循环链表，相对单链表来说查找效率高，无论是插入时的前插和后插，还是从后往前查找某个元素等。既然查找效率高了，自然添加，删除和修改元素时效率也就更高。唯一一个可以称为不足的就是每个节点需要耗费4字节指针来保存前一个节点的地址，因此如果遇到对内存要求比较苛刻的场景，而且一些操作单链表即可满足，那么可以考虑使用标准库中的forward_list（单链表）。 stl_list 源码分析分析gnu c++标准库中的stl_list，我们只需把握住整体结构即可，实现总共由三部分组成，链表节点(struct _List_node : public __detail::_List_node_base) ，迭代器（struct _List_iterator），链表数据结构（class list : protected _List_base&lt;_Tp, _Alloc&gt;）。 gnu下最新版本的stl_list实现加了一些额外的继承关系，_list_base中保存了一个_List_impl _M_impl中间变量，由该类_M_impl来保存节点，并对节点做基本处理。 链表节点父类维护两个指针，子类才加入具体的value。 1234567891011121314struct _List_node_base&#123; _List_node_base* _M_next; _List_node_base* _M_prev;&#125;; template&lt;typename _Tp&gt;struct _List_node : public __detail::_List_node_base&#123; ///&lt; User&#x27;s data. _Tp _M_data;&#125;; 迭代器主要是实现++和–等操作符重载，实现链表节点的前后移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273template&lt;typename _Tp&gt; struct _List_iterator &#123; typedef _List_iterator&lt;_Tp&gt; _Self; typedef _List_node&lt;_Tp&gt; _Node; typedef ptrdiff_t difference_type; typedef std::bidirectional_iterator_tag iterator_category; typedef _Tp value_type; typedef _Tp* pointer; typedef _Tp&amp; reference; _List_iterator() _GLIBCXX_NOEXCEPT : _M_node() &#123; &#125; explicit _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT : _M_node(__x) &#123; &#125; _Self _M_const_cast() const _GLIBCXX_NOEXCEPT &#123; return *this; &#125; // Must downcast from _List_node_base to _List_node to get to _M_data. reference operator*() const _GLIBCXX_NOEXCEPT &#123; return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data; &#125; pointer operator-&gt;() const _GLIBCXX_NOEXCEPT &#123; return std::__addressof(static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_data); &#125; _Self&amp; operator++() _GLIBCXX_NOEXCEPT &#123; _M_node = _M_node-&gt;_M_next; //本质是链表节点的next指针操作 return *this; &#125; _Self operator++(int) _GLIBCXX_NOEXCEPT &#123; _Self __tmp = *this; _M_node = _M_node-&gt;_M_next; return __tmp; &#125; _Self&amp; operator--() _GLIBCXX_NOEXCEPT &#123; _M_node = _M_node-&gt;_M_prev; //本质是链表节点的prev指针操作 return *this; &#125; _Self operator--(int) _GLIBCXX_NOEXCEPT &#123; _Self __tmp = *this; _M_node = _M_node-&gt;_M_prev; return __tmp; &#125; bool operator==(const _Self&amp; __x) const _GLIBCXX_NOEXCEPT &#123; return _M_node == __x._M_node; &#125; bool operator!=(const _Self&amp; __x) const _GLIBCXX_NOEXCEPT &#123; return _M_node != __x._M_node; &#125; // The only member points to the %list element. __detail::_List_node_base* _M_node; //维护一个链表节点 &#125;; 链表数据结构实现类 _List_impl，主要用来维护链表节点，然后list类包含该类。 1234567891011121314151617181920struct _List_impl : public _Node_alloc_type &#123; __detail::_List_node_base _M_node; //其实就是维护节点，标准库中用了一个中间层来处理 _List_impl() : _Node_alloc_type(), _M_node() &#123; &#125; _List_impl(const _Node_alloc_type&amp; __a) _GLIBCXX_NOEXCEPT : _Node_alloc_type(__a), _M_node() &#123; &#125;#if __cplusplus &gt;= 201103L _List_impl(_Node_alloc_type&amp;&amp; __a) _GLIBCXX_NOEXCEPT : _Node_alloc_type(std::move(__a)), _M_node() &#123; &#125;#endif &#125;; _List_base类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546template&lt;typename _Tp, typename _Alloc&gt; class _List_base &#123; protected: typedef typename _Alloc::template rebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type; typedef typename _Alloc::template rebind&lt;_Tp&gt;::other _Tp_alloc_type; static size_t _S_distance(const __detail::_List_node_base* __first, const __detail::_List_node_base* __last) &#123; size_t __n = 0; while (__first != __last) &#123; __first = __first-&gt;_M_next; ++__n; &#125; return __n; &#125; _List_impl _M_impl; // 中间层类 // count the number of nodes size_t _M_node_count() const &#123; return _S_distance(_M_impl._M_node._M_next, std::__addressof(_M_impl._M_node)); &#125; public: typedef _Alloc allocator_type; void _M_clear() _GLIBCXX_NOEXCEPT; void _M_init() _GLIBCXX_NOEXCEPT &#123; this-&gt;_M_impl._M_node._M_next = &amp;this-&gt;_M_impl._M_node; this-&gt;_M_impl._M_node._M_prev = &amp;this-&gt;_M_impl._M_node; _M_set_size(0); &#125; &#125;; list类 12345678910111213141516171819202122232425262728293031323334353637383940template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt; class list : protected _List_base&lt;_Tp, _Alloc&gt; &#123; // concept requirements typedef typename _Alloc::value_type _Alloc_value_type; __glibcxx_class_requires(_Tp, _SGIAssignableConcept) __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept) typedef _List_base&lt;_Tp, _Alloc&gt; _Base; typedef typename _Base::_Tp_alloc_type _Tp_alloc_type; typedef typename _Base::_Node_alloc_type _Node_alloc_type; public: typedef _Tp value_type; typedef typename _Tp_alloc_type::pointer pointer; typedef typename _Tp_alloc_type::const_pointer const_pointer; typedef typename _Tp_alloc_type::reference reference; typedef typename _Tp_alloc_type::const_reference const_reference; typedef _List_iterator&lt;_Tp&gt; iterator; typedef _List_const_iterator&lt;_Tp&gt; const_iterator; typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator; typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef _Alloc allocator_type; protected: // Note that pointers-to-_Node&#x27;s can be ctor-converted to // iterator types. typedef _List_node&lt;_Tp&gt; _Node; using _Base::_M_impl; using _Base::_M_put_node; using _Base::_M_get_node; using _Base::_M_get_Tp_allocator; using _Base::_M_get_Node_allocator; ..........................................................&#125; 大概截取了stl_list实现的一部分，主要为了体现stl_list的代码结构，具体接口实现可以查看源码。 stl-list简单实现STL_List.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296#ifndef STL_LIST#define STL_LIST#include &quot;Def.h&quot;__MUNDI_BEGINtemplate &lt;typename T&gt; class list&#123;public: // The list node, the parent class maintains two pointers, and the subclass adds the specific value. struct list_node_base &#123; list_node_base* Next; list_node_base* Prev; list_node_base():Next(nullptr), Prev(nullptr)&#123;&#125; &#125;; // dataEntry node struct list_node: public list_node_base &#123; T dataEntry; &#125;; // iterator struct list_iterator &#123; typedef list_iterator _Self; typedef T value_type; typedef T* pointer; typedef T&amp; reference; list_iterator() _T_STD_NOEXCEPT &#123; m_smartPtr = nullptr; &#125; explicit list_iterator(list_node_base * pNode) _T_STD_NOEXCEPT &#123; m_smartPtr = pNode; &#125; reference operator*() _T_STD_NOEXCEPT &#123; return static_cast&lt;list_node *&gt;(m_smartPtr)-&gt;dataEntry; &#125; list_node_base* operator-&gt;() _T_STD_NOEXCEPT &#123; return m_smartPtr; &#125; _Self operator++(int) _T_STD_NOEXCEPT // post increment &#123; _Self __tmp = *this; m_smartPtr = m_smartPtr-&gt;Next; return __tmp; &#125; _Self&amp; operator++() _T_STD_NOEXCEPT // pre increment &#123; m_smartPtr = m_smartPtr-&gt;Next; return *this; &#125; _Self operator--(int) _T_STD_NOEXCEPT &#123; _Self __tmp = *this; m_smartPtr = m_smartPtr-&gt;Prev; return __tmp; &#125; _Self&amp; operator--() _T_STD_NOEXCEPT &#123; m_smartPtr = m_smartPtr-&gt;Prev; return *this; &#125; bool operator==(const list_iterator &amp; _Right) const _T_STD_NOEXCEPT &#123; return m_smartPtr == _Right.m_smartPtr; &#125; bool operator!=(const list_iterator &amp; _Right) const _T_STD_NOEXCEPT &#123; return m_smartPtr != _Right.m_smartPtr; &#125; list_node_base * m_smartPtr; // Node pointer &#125;;public: typedef list_iterator iterator;public: list() // Default constructor &#123; empty_init(); &#125; list(const list&lt;T&gt; &amp; rhs) // Copy construction &#123; if(this != &amp;rhs) &#123; empty_init(); // initialization iterator itrBegin = rhs.begin(); iterator itrEnd = rhs.end(); while(itrBegin != itrEnd) &#123; list_node * tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); push_back(tmp-&gt;dataEntry); ++itrBegin; &#125; &#125; &#125; list &amp; operator = (const list&lt;T&gt; &amp; rhs) // Assignment operator overloading &#123; if(this != &amp;rhs) &#123; // If the original list has a value, it will be emptied first. if(begin() != end()) &#123; clear(); &#125; iterator itrBegin = rhs.begin(); iterator itrEnd = rhs.end(); while(itrBegin != itrEnd) &#123; list_node * tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); push_back(tmp-&gt;dataEntry); ++itrBegin; &#125; &#125; &#125; ~list() // Destructor &#123; clear(); if(pHeadNode) &#123; delete pHeadNode; pHeadNode = nullptr; &#125; &#125; iterator begin() _T_STD_NOEXCEPT &#123; return iterator(pHeadNode-&gt;Next); &#125; iterator end() _T_STD_NOEXCEPT &#123; return iterator(pHeadNode); &#125; void push_back(const T &amp; value) &#123; insert(end(), value); &#125; void push_front(const T &amp; value) &#123; insert(begin(), value); &#125; void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; iterator tmp = end(); erase(--tmp); &#125; T &amp; front() &#123; return *begin(); &#125; T &amp; back() &#123; return *(--end()); &#125; unsigned int remove(const T &amp; value) &#123; unsigned int count = 0; iterator itrBegin = begin(); while(itrBegin != end()) &#123; if(*itrBegin == value) &#123; itrBegin = erase(itrBegin); ++count; &#125; else &#123; ++itrBegin; &#125; &#125; return count; &#125; iterator erase(iterator position) &#123; list_node_base* next_node = position.m_smartPtr-&gt;Next; list_node_base* prev_node = position.m_smartPtr-&gt;Prev; prev_node-&gt;Next = next_node; next_node-&gt;Prev = prev_node; delete position.m_smartPtr; position.m_smartPtr = nullptr; if(_size &gt; 0) &#123; _size--; &#125; return iterator(next_node); &#125; iterator insert(iterator position, const T&amp; x) &#123; list_node* tmp = new list_node(); tmp-&gt;dataEntry = x; tmp-&gt;Next = position.m_smartPtr; tmp-&gt;Prev = position.m_smartPtr-&gt;Prev; position.m_smartPtr-&gt;Prev-&gt;Next = tmp; position.m_smartPtr-&gt;Prev = tmp; ++_size; return iterator(tmp); &#125; void clear() &#123; iterator itrBegin = begin(); while(itrBegin != end()) &#123; list_node* tmp = static_cast&lt;list_node *&gt;(itrBegin.m_smartPtr); ++itrBegin; if(tmp) &#123; delete tmp; &#125; &#125; pHeadNode-&gt;Next = pHeadNode; pHeadNode-&gt;Prev = pHeadNode; _size = 0; &#125; int size() // return length &#123; return _size; &#125;private: void empty_init() &#123; pHeadNode = new list_node_base(); pHeadNode-&gt;Next = pHeadNode; // Initialize pointer to itself pHeadNode-&gt;Prev = pHeadNode; _size = 0; &#125;private: list_node_base* pHeadNode; // List head unsigned int _size; // the number of nodes, increase the efficiency of searching&#125;;__MUNDI_END#endif Def.h123456789101112131415#define __MUNDI_BEGIN namespace Mundi &#123;#define __MUNDI_END &#125;#ifndef _T_STD_NOEXCEPT# if __cplusplus &gt;= 201103L# define _T_STD_NOEXCEPT noexcept# define _T_STD_USE_NOEXCEPT noexcept# define _T_STD_THROW(_EXC)# else# define _T_STD_NOEXCEPT# define _T_STD_USE_NOEXCEPT throw()# define _T_STD_THROW(_EXC) throw(_EXC)# endif#endif","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://mundi-xu.github.io/tags/C/"},{"name":"list","slug":"list","permalink":"https://mundi-xu.github.io/tags/list/"}]},{"title":"超星学习通开启自动播放模式","slug":"学习通自动播放模式","date":"2019-08-21T03:11:00.000Z","updated":"2020-12-23T15:57:57.650Z","comments":true,"path":"2019/08/21/学习通自动播放模式/","link":"","permalink":"https://mundi-xu.github.io/2019/08/21/%E5%AD%A6%E4%B9%A0%E9%80%9A%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E6%A8%A1%E5%BC%8F/","excerpt":"为便于观看超星学习通课程视频，提高学习效率，特推出自动播放模式，仅供交流学习。","text":"In three words I can sum up everything I’ve learned about life: it goes on.几个字足以概括我学到的人生：一切都在继续。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var fa = $(&quot;body&quot;);var btn = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);var json = &#123; &quot;background&quot;: &quot;#66ccff&quot;, &quot;height&quot;: &quot;16px&quot;, &quot;padding&quot;: &quot;5px&quot;, &quot;z-index&quot;: 0xFFFFF, &quot;cursor&quot;: &quot;pointer&quot;, &quot;top&quot;: &quot;300px&quot;, &quot;right&quot;: &quot;120px&quot;, &quot;position&quot;: &quot;fixed&quot;&#125;;btn.css(json);btn.html(&quot;&lt;span id=&#x27;lfsenior&#x27;&gt;开启自动播放模式&lt;/span&gt;&quot;);fa.append(btn); btn.click(function () &#123; setInterval(function () &#123; //获取iframe var video = $(&quot;iframe&quot;).contents().find(&quot;iframe&quot;).contents(); //播放函数 var play = function () &#123; video.find(&quot;#video &gt; button&quot;).click(); var jy = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-volume-panel.vjs-control.vjs-volume-panel-vertical &gt; button&quot;); if (jy.attr(&quot;title&quot;) != &quot;取消静音&quot;) &#123; jy.click() &#125; &#125; //如果正在加载 var load = video.find(&quot;#loading&quot;); if (load.css(&quot;visibility&quot;) != &quot;hidden&quot;) &#123; return; &#125; //获取当前进度 var spans = video.find(&quot;#video &gt; div.vjs-control-bar &gt; div.vjs-progress-control.vjs-control &gt; div&quot;).attr(&quot;aria-valuenow&quot;); // 如果还没播放完 if (spans != 100) &#123; play(); &#125; $(&quot;#lfsenior&quot;).html(&quot;自动模式已开启,本章进度:&quot; + spans + &quot;%&quot;); &#125;, 100); &#125;); 以Chrome为例，按F12打开Console，复制代码回车即可。 2019-10-18更新目前部分课程网站添加了前端反调试，表现为页面不断debugger，Chrome只需Ctrl + F8禁止断点即可。","categories":[],"tags":[{"name":"something useful","slug":"something-useful","permalink":"https://mundi-xu.github.io/tags/something-useful/"},{"name":"超星学习通","slug":"超星学习通","permalink":"https://mundi-xu.github.io/tags/%E8%B6%85%E6%98%9F%E5%AD%A6%E4%B9%A0%E9%80%9A/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://mundi-xu.github.io/tags/JavaScript/"}]},{"title":"线性代数的本质（更新中）","slug":"线性代数的本质","date":"2019-06-30T08:21:00.000Z","updated":"2020-12-23T08:52:49.654Z","comments":true,"path":"2019/06/30/线性代数的本质/","link":"","permalink":"https://mundi-xu.github.io/2019/06/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"将只停留在数值运算和公式的线性代数与可视化几何结合，整理自3Blue1Brown的系列视频。","text":"序言 There is hardly any theory which is more elementary than linear algebra, in spite of the fact that generations of professors and textbook writers have obscured its simplicity by preposterous calculations with matrices.尽管一批教授和教科书作者用关于矩阵的荒谬计算掩盖了线性代数的简明性，但鲜有比之更基本的理论。 将只停留在数值运算和公式的线性代数与可视化几何直观（Visual Geometric Intuition）结合，整理自3Blue1Brown的系列视频。内容涉及到向量，线性变换，行列式，逆矩阵，点积与叉积，特征向量与特征值等，以及二次型，相似矩阵等补充内容。 我们为什么需要几何直观在开始之前，想象学习一个事物（概念）的场景：我们需要学习正弦函数 $\\sin (x)$ ，非常不幸的是，你遇到的教材告诉你，正弦函数是这样的： $\\sin (x) = x - \\frac{x^3}{3!} + \\frac{x^5}{5!} + \\cdots + (-1)^n\\frac{x^{2n+1}}{(2n+1)!} + \\cdots$ 看上去很厉害的样子，并且计算机也的确是这么计算 $\\sin (x)$ 的，而对你来说，计算$\\sin (\\frac{\\pi}{6})$可能就是把 $x= \\frac{\\pi}{6}$ 代入公式，然后神奇的发现结果越算越接近0.5 ，此时你对$\\sin (x)$与三角形之间的几何直观只有一些模糊的概念，这样的学习就十分悲催了。为什么呢？再假设一个场景：在学完$\\sin (x)$函数后，你又去参加了一个物理课程，正弦函数随处可见，其他人很快就能知道如何使用它并能得出大概值，而刚学完正弦函数的你内心戏大概是这样的：这群学物理的脑子也太强了！ 其实，你需要只是一个几何直观的灌输而已，这也从侧面佐证了一个好的老师或教材（这里的好老师真的不是他本身的学术能力有多强，而在于他擅不擅长站在学习者的角度不断的修正教学方法）是有多么重要。 教学不同层次的人：初学、入门、掌握、理解，解释的角度，方式都完全不同。更加不幸的是，为了能更加通用的用理论来描述现实生活中的规律，人类已经做了很多工作，我们常说：越通用，越抽象，这对于初学者来说堪称一段噩梦。 上述例子可能比较极端，但只为强调一件事：直观理解很重要，或者说，学习方法很重要。好的学习方法即你如何直观的去理解（可能是几何的，或是现实中的具体例子）一个抽象的事物，并层次化的建立知识与知识间的联系，构建并健壮属于自己的知识图谱。个人观点是，这种学习方法是最高效的。它唯一的要求在于，需要一定的基础知识打底，一定的量变结合方法论（点拨或领悟）就是质变。 向量究竟是什么 The introduction of numbers as coordinates is an act of violence.引入一些数作为坐标是一种鲁莽的行为。 不同视角下的向量对于向量的这个概念，大家一定并不陌生，但是这次让我们从数学，物理，计算机三个角度来看待如何定义这个向量这个概念。 物理专业角度 向量是空间中的箭头 决定一个向量的是：它的长度和它所指的方向 计算机专业角度 向量是有序的数字列表 向量不过是“列表”一个花哨的说法 向量的维度等于“列表”的长度 数学专业角度对数学来说，它的本质就是通用和抽象，所以，数学家希望概括这两种观点: 向量可以是任何东西，只需要保证：两个向量相加及数字与向量相乘有意义 向量加法和向量乘法贯穿线性代数始终，十分重要 可以通过上图直观的感受到数学家在想什么。左边是物理角度，右边是计算机角度，但是很抱歉，我能用一些抽象的定义和约束让你们变成一个东西。 坐标系把向量置于坐标系中，以原点为起点，坐标正负表示方向，可完美把两个不同的角度融合。 向量加法 物理：首尾相连 (Motion) 计算机：坐标相加 向量乘法 物理：缩放 (Scaling) 计算机：坐标和比例相乘 实际上无论你怎么看待向量都无所谓，或把向量看作空间中的箭头，或把向量看作数字列表，线性代数的效用很少体现在这些观点中的其中一个上，而是更多的体现在它能够在这些观点中互相转化。线性代数为数据分析提供了一条将大量数据列表概念化、可视化的渠道，它能让数据样式变得非常明晰，并让你大致了解其特定运算的意义。同时，线性代数给物理学家和计算机图形程序员提供了一种方法去通过计算机能处理的数字来描述并操纵空间（例如Mathematical Animation Engine)。 线性组合、基与其张成的空间 Mathematics requires a small dose, not of genius, but of an imaginative freedom which, in a larger dose, would be insanity.数学需要的不是天赋，而是少量的自由想象，但想象太过自由又会陷入疯狂。 本部分继续加深一个概念，为何向量加法与向量乘法是那么重要，并从始至终贯穿整个线性代数（关于后面的直观解释部分，强烈建议去原视频观看动画演示）。 线性组合二维空间中任意两个不共线的非零向量都可以表示该空间中的任意一个向量，写成符号语言就是： $a \\mathbf{\\vec v} + b \\mathbf{\\vec w}$ 。 至于为什么被称为“线性”，有一种几何直观：如果你固定其中一个标量，让另一个标量自由变化，所产生的向量终点会描出一条直线。（这里其实很不严谨，具体定义请参阅课本。） 空间的基 (Basis)对于我们常见的笛卡尔坐标系，有一组最直观的基：${ \\hat{\\imath},{\\hat{\\jmath}} }$，即单位向量 $\\hat{\\imath}=(1,0)$ 和 $\\hat{\\jmath}=(0,1)$,通过$\\hat{\\imath}$和${\\hat{\\jmath}}$的拉伸与相加可以组成笛卡尔坐标系中的任意一个向量。（上述的任意两个不共线的非零向量也可以作为二维空间的一组基。） 张成的空间 (Span)同理，我们可以选择不同的基向量，而这些基向量构成的空间就称为其张成的空间。张成二字比较拗口，可以类比为延伸或扩展。直观来看，就是本文所有图中的网格。笛卡尔坐标系就是一个由单位坐标${ \\hat{\\imath},{\\hat{\\jmath}} }$张成的空间（同时也是上述任意两个不共线的非零向量所张成的空间）。所有可以表示为给定向量（基）线性组合（刚刚讲了这个概念）的向量的集合，被称为给定向量（基）张成的空间。 如果你继续思考一下，会发现一个特点：**并不是每一组给定向量都可以张成一个空间**，若这两个向量共线（2D），共面（3D），它们就只能被限制在一个直线或面中，类似于“降维打击”（这也是我强调不共线且向量非零的原因）。通过这个直观的思考可以引出以下概念： 线性相关关于什么是线性相关，有两种表达： 你有多个向量，并且可以移除其中一个而不减小张成的空间（即2D共线或3D共面），我们称它们（这些向量）线性相关。 其中一个向量，可以表示为其他向量的线性组合，因为这个向量已经落在其他向量张成的空间之中。 从统计学角度来说，就是指这些向量之中有冗余。即在这一堆向量中，我们只需要其中几个（取决于维度）就可以表示所有其他的向量。由此，我们可以得出以下部分： 向量空间中一组基的严格定义向量空间的一组基是张成该空间的一个线性无关向量集。 在线性代数中，基(basis)（也称为基底）是描述、刻画向量空间的基本工具。向量空间的基是它的一个特殊的子集，基的元素称为基向量。向量空间中任意一个元素，都可以唯一地表示成基向量的线性组合。如果基中元素个数有限，就称向量空间为有限维向量空间，将元素的个数称作向量空间的维数。 使用基底可以便利地描述向量空间。 用这样的步骤来慢慢导出这个定义，个人感觉，远比在课堂的第一分钟就将这句让你迷惑的话丢给你好的多，抽象的东西只有在慢慢推倒中你才能发现它的精巧之处，非常优雅且迷人。 矩阵与线性变换 Unfortunately, no one can be told what the Matrix is. You have to see it for yourself.很遗憾，矩阵是什么是说不清的。你必须得自己亲眼看看。 矩阵，最直观的理解当然是一个写成方阵的数字 $\\begin{pmatrix}1&amp;0 \\\\ 0&amp;1 \\end{pmatrix}$，这几节的核心是为了说明：矩阵其实就是一种向量变换（至于什么是变换下面会讲），并附带一种不用死记硬背的考虑矩阵向量乘法的方法。 变换变换本质上是函数（下左图）的一种花哨的说法，它接受输入内容，并输出对应结果，特别的，在矩阵变换（下右图）中，我们接受一个向量并且输出另一个向量。 那既然变换和函数意义相同，为什么要用多余的术语困惑我们呢？因为使用变换是在暗示以特定方式来可视化这一输入$\\to$输出关系。一种理解“向量的函数”的方法就是就是使用运动。 这世界上有非常多优美的变换，如果你将他们可视化，就能得到下图： 线性变换我们说具有以下两个性质的就是线性变换（直观可视化如下图）： 直线在变换后仍然保持为直线，不能有所弯曲。 原点必须保持固定 用一句话总结就是：线性变换是保持网格线平行且等距分布的变换（如果变换后保持直线不变但原点改变则为仿射变换，即线性变换+平移）。 如何用数值描述线性变换这里需要使用上一节提到的工具，空间的基，也就是单位向量（基向量）：$\\hat{\\imath}=(1,0)$ 和 $\\hat{\\jmath}=(0,1)$ 对线性变换，我们只需要关注两个基向量 $\\hat{\\imath}$ 和 $\\hat{\\jmath}$变换后的位置即可。例如，$\\hat{\\imath}$ 变换到$(3,1)$的位置，$\\hat{\\jmath}$ 变换到$(1,2)$的位置,将$\\hat{\\imath}$变换后的坐标竖起来作为方阵的第一列（绿色表示），$\\hat{\\jmath}$变换后的坐标竖起来作为方阵的第二列（红色表示），得到矩阵$\\begin{pmatrix}\\color{green}3&amp;\\color{red}1 \\\\ \\color{green}1&amp;\\color{red}2 \\end{pmatrix}$。假设我们想要知道目标向量$(-1,2)$进行变换后的位置，那么这个矩阵就是对变换过程最好的描述，一图胜千言。 Step1： 绿色$\\hat{\\imath}$（x轴）进行移动（变换） Step2： 红色$\\hat{\\jmath}$（y轴）进行移动（变换） Step3： 目标向量x轴坐标值与$\\hat{\\imath}$变换后向量进行向量乘法 Step4： 目标向量y轴坐标值与$\\hat{\\jmath}$变换后向量进行向量乘法 Step5： 两者进行向量加法，得到线性变换结果 更加一般的情况，我们用变量来代替其中的具体值，其中绿色代表$\\hat{\\imath}$变换后的向量，红色代表$\\hat{\\jmath}$变换后的向量： $\\begin{pmatrix}\\color{green}a&amp;\\color{red}b \\\\ \\color{green}c&amp;\\color{red}d \\end{pmatrix}\\begin{pmatrix} x \\\\ y\\end{pmatrix} = \\underbrace{x \\begin{pmatrix}\\color{green}a \\\\ \\color{green}c \\end{pmatrix} + y \\begin{pmatrix} \\color{red}b \\\\ \\color{red}d \\end{pmatrix}}_{\\text{直观的部分这里}} = \\begin{pmatrix}\\color{green}{a}\\color{black}{x}+\\color{red}{b}\\color{black}{y} \\\\ \\color{green}{c}\\color{black}{x}+\\color{red}{d}\\color{black}{y}\\end{pmatrix}$ 上面的公式就是我们常说的矩阵乘法公式，现在，不要强行背诵，结合可视化的直观动图，你一辈子都不会忘记的。 线性的严格定义在给出一个数学化抽象的解释前，先做一下总结： 线性变换是操纵空间的一种手段，它保持网格线平行且等距分布，并保持原点不动 矩阵是描述这种变换的一组数字，或者说一种描述线性变换的语言 在数学上，线性的严格定义如下述公式，这些性质，会在之后进行讨论，也可以在这里就进行一些思考，为什么说向量加法和向量乘法贯穿线性代数始终？ $L(\\mathbf {\\vec v} + \\mathbf{\\vec w}) = L(\\mathbf {\\vec v}) + L(\\mathbf {\\vec w}) \\qquad 可加性（对加法封闭）$$L(c \\mathbf {\\vec v}) = c L(\\mathbf {\\vec v}) \\qquad 成比例（对数乘封闭）$ 矩阵乘法与线性变换复合 It is my experience that proofs involving matrices can be shortened by 50% if one throws the matrices out.据我的经验，如果丢掉矩阵的话，那些涉及矩阵的证明可以缩短一半。 复合变换如果对一个向量先进行一次旋转变换，再进行一次剪切变换( $\\hat {\\imath}$保持$(1,0)$不变, $\\hat{\\jmath}$移动到坐标$(1,1)$),如下图所示： 那么如果通过旋转矩阵和剪切矩阵来求得这个符合矩阵呢？为了解决这个问题，我们定义这个过程叫做**矩阵的乘法**。 矩阵乘法的计算在这里我们发现，矩阵乘法的变换顺序是从右往左读的（这一个常识很重要，你得明白这一点，有基本概念），也和我们熟知的复合函数形式 $f(g(x))$ 是一致的。 那么如何求解矩阵乘法呢？对线性代数有印象的同学现在能马上记起来那个稍显复杂的公式吗？如果有些忘记了，那么，现在，就有一个一辈子也忘不了的直观解释方法： 如图，$M_1$矩阵的第一列表示的是$\\hat{\\imath}$变换的位置，先把它拿出来，$M_2$矩阵看成对这个变换过的$\\hat{\\imath}$进行一次变换（按照前文的规则）。同理，针对$\\hat{\\jmath}$做一样的操作，就可以得出这个表达式。 矩阵乘法的运算规律通常学生在学习矩阵乘法时都会记住上述公式并通过一些特定的运算加强记忆（包括我），但是在记忆这个过程前，我希望你能养成思考矩阵乘法意义的习惯，也就是两个变换相继作用。这能形成一个更好的概念性框架，并让你更容易理解矩阵乘积的性质。举个栗子，矩阵相乘时，它们的先后顺序影响结果吗？有了上面的想法，可以自己试着在不进行计算的条件下思考一下，然后再尝试证明结合律与分配律是否成立。你会发现，原来线性代数是这么的直观，完全不需要计算。 未完待续……","categories":[],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://mundi-xu.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"一种神奇的rsa加密算法","slug":"一种神奇的rsa加密算法","date":"2018-11-29T07:21:00.000Z","updated":"2020-12-23T11:58:41.661Z","comments":true,"path":"2018/11/29/一种神奇的rsa加密算法/","link":"","permalink":"https://mundi-xu.github.io/2018/11/29/%E4%B8%80%E7%A7%8D%E7%A5%9E%E5%A5%87%E7%9A%84rsa%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"新的算法并没有透露 n，只给定了两个大整数：(p*q)^(p+q) 和 (p*q)^(p-q)，其中 ^ 是按位异或运算。","text":"新的算法并没有透露 n，只给定了两个大整数：(p*q)^(p+q) 和 (p*q)^(p-q)，其中 ^ 是按位异或运算。 12345678910111213import sympyp = sympy.randprime(2 ** 1023, 2 ** 1024)q = sympy.randprime(2 ** 1023, 2 ** 1024)a = (p * q) ^ (p + q)b = (p * q) ^ (p - q)flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()m = int.from_bytes(flag, &#x27;big&#x27;)print(a, b, pow(m, 65537, p * q)) 2018年12月20日更新我们定义 $ f_1(x,y) = (x \\ast y)^{(x+y)} 和 f_2(x,y) = (x \\ast y)^{(x-y)} $ ，我们发现这两个函数都有一个共同的性质，就是函数值的最低 n 个二进制位只和 x、y 的最低 n 个二进制位有关。也就是说，我们可以用 a 和 b 的最低 n 位来判断 p 和 q 的最低 n 位是否可能正确。如果它们的最低 n 位满足 $ f_1 $和 $f_2$ 函数，那么它们就是 p 和 q 低位的候选答案；如果不满足，它们就根本不可能是真正 p 和 q 的低位。所以我们可以从一个二进制位（n=1）开始，每次增加一位。每增加一位时，我们把原来满足条件的 p 和 q 低位的每种可能情况分别在前面加上 0 或 1，这样每种情况就变成了 4 种新的情况，然后对所有新的情况用 $ f_1 $ 和 $ f_2 $ 函数提供的约束条件进行过滤，只保留满足条件的情况。当跑到 1024 位的时候，就只会剩下真正满足条件的 p 和 q 了。然后，我们根据 RSA 的原理，在 mod (p-1)*(q-1) 的意义下对 e 求逆元，得到私钥 d，计算 pow(c, d, p*q)即可得到 flag 的大整数表示。 求解脚本如下 1234567891011121314151617181920212223242526272829303132import gmpy2a, b, c = [int(s) for s in open(&#x27;output.txt&#x27;).read().split()]#假设已将加密内容保存到 output.txt 文件中f1 = lambda p, q: (p * q) ^ (p + q)f2 = lambda p, q: (p * q) ^ (p - q)candidates = &#123;(0, 0)&#125;for m in range(1025): print(m, len(candidates)) candidates_ = set() mask = (2 &lt;&lt; m) - 1 for x, y in candidates: if f1(x, y) == a and f2(x, y) == b: p, q = x, y d = gmpy2.invert(65537, (p - 1) * (q - 1)) m = pow(c, d, p * q) print(bytes.fromhex(hex(m)[2:])) exit() for bx in range(2): for by in range(2): xx = x + (bx &lt;&lt; m) yy = y + (by &lt;&lt; m) if f1(xx, yy) &amp; mask != a &amp; mask: continue if f2(xx, yy) &amp; mask != b &amp; mask: continue candidates_.add((xx, yy))candidates = candidates_ 有几个人做出来了呢（坏笑:） [^1]hackergame2018-RSA_of_Z","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://mundi-xu.github.io/tags/ctf/"},{"name":"crypto","slug":"crypto","permalink":"https://mundi-xu.github.io/tags/crypto/"},{"name":"rsa","slug":"rsa","permalink":"https://mundi-xu.github.io/tags/rsa/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-25T09:21:30.000Z","updated":"2020-12-27T10:07:00.032Z","comments":true,"path":"2018/10/25/hello-world/","link":"","permalink":"https://mundi-xu.github.io/2018/10/25/hello-world/","excerpt":"Welcome to My Blog !","text":"Welcome to My Blog ! This is my first postMy Instagram: mundi.xuThank you for subscribing me","categories":[],"tags":[]}]}